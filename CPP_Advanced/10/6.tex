\chapter{Advanced Lock-Free: ABA \& Memory Reclamation}

В предыдущей главе мы реализовали Lock-Free стек и столкнулись с фундаментальной проблемой отсутствия Garbage Collector в C++: мы не знаем, когда безопасно вызывать \texttt{delete} для узла, исключенного из структуры данных.

Однако проблема управления памятью в Lock-Free алгоритмах глубже, чем просто утечки или Segfault. Повторное использование памяти (memory recycling) может привести к логическому разрушению структуры данных, даже если все указатели валидны. Этот феномен известен как проблема ABA.

В этой главе мы разберем механику ABA на уровне состояний памяти, изучим аппаратные методы решения (Tagged Pointers) и реализуем программный алгоритм безопасной рекламации памяти — Hazard Pointers. Также мы рассмотрим более сложную структуру — Lock-Free очередь Майкла-Скотта.

\section{Проблема ABA}

Название ABA происходит от последовательности изменения состояний: значение было $A$, стало $B$, затем снова стало $A$. Для наивного наблюдателя, использующего CAS (Compare-And-Swap), кажется, что значение не менялось, хотя мир вокруг изменился кардинально.

\subsection{Анатомия катастрофы (Сценарий на Стеке)}

Рассмотрим наш Lock-Free стек (LIFO).
Состояние стека: \texttt{Top $\to$ A $\to$ B $\to$ C}.

\textbf{Поток 1 (Жертва):}
\begin{itemize}
    \item Планирует выполнить \texttt{Pop}.
    \item Читает текущую голову: \texttt{old\_head = A} (адрес 0x1000).
    \item Читает следующий элемент: \texttt{next = A->next} (узел B, адрес 0x2000).
    \item \textit{Поток прерывается планировщиком ОС.}
\end{itemize}

\textbf{Поток 2 (Разрушитель):}
\begin{itemize}
    \item Выполняет \texttt{Pop}: Успешно удаляет A. Стек: \texttt{Top $\to$ B $\to$ C}.
    \item Удаляет узел A (\texttt{delete A}). Память по адресу 0x1000 возвращается аллокатору.
    \item Выполняет \texttt{Pop}: Успешно удаляет B. Стек: \texttt{Top $\to$ C}.
    \item Удаляет узел B (\texttt{delete B}). Адрес 0x2000 свободен.
    \item Выполняет \texttt{Push}: Создает новый узел. Аллокатор, оптимизируя работу, возвращает только что освобожденный адрес 0x1000.
    \item Записывает в новый узел (по адресу 0x1000) какие-то данные. Его \texttt{next} указывает на C.
    \item Стек: \texttt{Top $\to$ A' (0x1000) $\to$ C}.
\end{itemize}

\textbf{Поток 1 (Продолжение):}
\begin{itemize}
    \item Просыпается. Готовится выполнить CAS для смены головы.
    \item Аргументы CAS:
        \begin{itemize}
            \item Адрес переменной: \texttt{\&Top}.
            \item Ожидаемое значение: 0x1000 (узел A).
            \item Новое значение: 0x2000 (узел B, сохраненный в переменной \texttt{next}).
        \end{itemize}
    \item \textbf{CAS Проверка:} Текущий \texttt{Top} равен 0x1000? Да, равен (это новый узел A').
    \item \textbf{CAS Успех:} \texttt{Top} меняется на 0x2000 (узел B).
\end{itemize}

\textbf{Результат:} Голова стека указывает на адрес 0x2000. Но узел по этому адресу был удален Потоком 2!
Стек сломан. Следующий \texttt{Pop} приведет к чтению освобожденной памяти (Use-After-Free) или, что хуже, к чтению данных другого объекта, который аллокатор разместил по адресу 0x2000.

\section{Решение 1: Tagged Pointers (Указатели с версиями)}

Проблема ABA возникает из-за того, что указатель (адрес) не уникален во времени. Адрес 0x1000 сегодня — это узел стека, завтра — текстура видеокарты, послезавтра — снова узел стека.

Чтобы сделать указатель уникальным, нужно добавить к нему \textbf{счетчик версий} (Tag).
Каждое обновление указателя (CAS) должно инкрементировать этот счетчик. Тогда последовательность $A \to B \to A$ превратится в $A_1 \to B_2 \to A_3$. CAS, ожидающий $A_1$, провалится, увидев $A_3$.

\subsection{Реализация на x86\_64}
В 64-битных процессорах виртуальные адреса используют только младшие 48 бит. Старшие 16 бит обычно должны быть нулями (или копией 47-го бита). Мы можем использовать эти 16 бит для хранения счетчика.

\begin{cppcode}
// Упрощенная концепция (требует битхаков)
struct TaggedPointer {
    uint64_t raw; // 48 бит адрес + 16 бит тег

    static const uint64_t TAG_MASK = 0xFFFF000000000000;
    static const uint64_t PTR_MASK = 0x0000FFFFFFFFFFFF;

    Node* get_ptr() const {
        return reinterpret_cast<Node*>(raw & PTR_MASK);
    }
    
    uint16_t get_tag() const {
        return (raw & TAG_MASK) >> 48;
    }
    
    // При создании нового ptr инкрементируем tag
    static TaggedPointer make(Node* ptr, uint16_t old_tag) {
        return { (uint64_t(ptr) & PTR_MASK) | (uint64_t(old_tag + 1) << 48) };
    }
};
\end{cppcode}

В C++ для этого удобно использовать двойную ширину CAS (`cmpxchg16b` на x86\_64), который оперирует парой 64-битных чисел (итого 128 бит). Стандартный `std::atomic<shared\_ptr>` часто реализован именно так, но это дорого.

\section{Решение 2: Hazard Pointers (Опасные указатели)}

Tagged Pointers решают ABA, но не решают проблему преждевременного `delete`.
Самым надежным чисто программным решением в C++ (без использования GC) является метод \textbf{Hazard Pointers} (HP), предложенный Майклом (Maged Michael).

\textbf{Идея:} Каждый поток-читатель имеет свой личный список "опасных указателей" (обычно 1-2 слота). Перед тем как работать с указателем, поток записывает его в свой HP-слот, объявляя всем остальным: "Я читаю этот объект, не удаляйте его!".

Поток-писатель, желающий удалить объект, сначала сканирует списки HP всех потоков.
\begin{itemize}
    \item Если адрес найден в чьем-то HP — удалять нельзя. Адрес добавляется в список "на пенсию" (Retire List).
    \item Если адрес нигде не найден — можно безопасно вызвать \texttt{delete}.
\end{itemize}

\subsection{Алгоритм работы с HP в Pop}

Это сложнее, чем кажется, из-за гонок данных. Мы не можем просто записать указатель в HP, потому что к моменту записи он уже мог быть удален.

\begin{cppcode}
// Глобальный массив Hazard Pointers (по одному слоту на поток)
std::atomic<Node*> HP[MAX_THREADS];

std::optional<T> Pop(int thread_id) {
    Node* old_head;
    Node* next_node;
    
    while (true) {
        // 1. Читаем текущую голову
        old_head = head.load(std::memory_order_acquire);
        if (!old_head) return std::nullopt;

        // 2. Объявляем указатель "опасным" (защищаем его)
        HP[thread_id].store(old_head, std::memory_order_seq_cst);

        // 3. КРИТИЧЕСКАЯ ПРОВЕРКА!
        // За время между шагом 1 и 2 old_head мог быть удален.
        // Если head изменился, значит, наш HP защищает уже "мертвый" объект.
        // Нужно начать сначала.
        if (head.load(std::memory_order_acquire) != old_head) {
            HP[thread_id].store(nullptr, std::memory_order_relaxed); // Снимаем защиту
            continue;
        }

        // 4. Теперь указатель безопасно защищен. Можно читать поля.
        next_node = old_head->next; // Безопасно!

        // 5. Пытаемся удалить из стека
        if (head.compare_exchange_weak(old_head, next_node)) {
            break; // Успех! Мы извлекли элемент.
        }
        
        // Неудача: снимаем защиту и пробуем снова
        HP[thread_id].store(nullptr, std::memory_order_relaxed);
    }

    HP[thread_id].store(nullptr, std::memory_order_release); // Мы закончили
    
    // 6. Отправляем old_head на удаление
    RetireNode(old_head);
    
    return old_head->data;
}
\end{cppcode}

\subsection{RetireNode и Scan}
Функция `RetireNode` не делает `delete` сразу. Она добавляет указатель в локальный буфер потока (`thread\_local vector`). Когда буфер заполняется (например, достигает размера $2 \cdot N$, где $N$ — число потоков), запускается процедура \texttt{Scan}.

\texttt{Scan}:
1. Собирает все ненулевые указатели из глобального массива `HP` в `std::set` (или сортированный вектор).
2. Проходит по локальному буферу "пенсионеров".
3. Если указатель из буфера ЕСТЬ в множестве `HP` — оставляем его на потом.
4. Если указателя НЕТ в множестве `HP` — делаем реальный \texttt{delete}.

Это гарантирует, что мы никогда не удалим объект, который кто-то читает.

\section{Решение 3: RCU (Read-Copy-Update)}

Для структур, где чтений много, а записей мало, HP может быть слишком дорогим из-за необходимости писать в `atomic` (это сбивает кэш-линии).
Альтернатива — RCU.

Идея: разделить время на "эпохи" (generations).
1. У нас есть глобальный счетчик эпох.
2. Писатель, удаляющий данные, "публикует" новую версию структуры данных, а старую откладывает в список удаления текущей эпохи.
3. Писатель ждет, пока \textit{все} читатели, начавшие работу в старой эпохе, завершат свои операции (Quiescent State).
4. После этого старую эпоху можно безопасно чистить.

В user-space RCU сложен в реализации (нужно знать, когда читатель "вышел" из критической секции), но библиотека \texttt{liburcu} предоставляет готовые решения.

\section{Практика: Lock-Free Очередь (Queue)}

Очередь (FIFO) сложнее стека, так как имеет две точки изменения: `Head` (откуда забираем) и `Tail` (куда добавляем).
Классический алгоритм — \textbf{Michael-Scott Queue}.

\subsection{Проблемы двух указателей}
Если мы просто храним `atomic<Node*> Head` и `Tail`, мы не можем обновить их оба атомарно одной инструкцией.
Вставка в конец требует двух шагов:
\begin{enumerate}
    \item  `Tail->next = new\_node` (линковка).
    \item `Tail = new\_node` (продвижение хвоста).
\end{enumerate}

Если поток заснет между 1 и 2, `Tail` останется указывать на предпоследний элемент. Следующий поток, пришедший делать `Push`, увидит, что `Tail->next != nullptr`.

\textbf{Идея помощи (Helping):}
Lock-Free алгоритм очереди устроен так, что если поток видит "отставший" `Tail` (у которого `next` не null), он не ждет, а \textbf{помогает} завершить операцию, продвигая `Tail` вперед с помощью CAS, и только потом делает свою вставку.

\subsection{Dummy Node (Фиктивный узел)}
Чтобы избежать гонок на пустой очереди (когда `Head == Tail == nullptr`), очередь Майкла-Скотта всегда содержит хотя бы один "фиктивный" узел.
Изначально: `Head = Tail = new Node(dummy)`.
\begin{itemize}
    \item \texttt{Push}: Добавляет после `Tail`, двигает `Tail`.
    \item \texttt{Pop}: Читает `Head->next`. Если есть, возвращает данные, и делает `Head = Head->next`. Старый `Head` (бывший dummy) удаляется (через HP), а узел, который содержал данные, становится новым dummy.
\end{itemize}

\begin{summary}
\begin{itemize}
    \item Проблема ABA разрушает логику Lock-Free алгоритмов при переиспользовании памяти.
    \item \textbf{Tagged Pointers} решают ABA аппаратно, добавляя счетчик версий в неиспользуемые биты указателя.
    \item \textbf{Hazard Pointers} — де-факто стандарт для управления памятью в C++ Lock-Free. Они гарантируют безопасность доступа, но требуют накладных расходов на `store-load` барьеры при каждом чтении.
    \item Реализация очередей требует кооперации потоков: если один "застрял" посередине операции, другие должны ему помочь, чтобы сохранить свойство Lock-Free.
\end{itemize}
\end{summary}
