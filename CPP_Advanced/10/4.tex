\chapter{Linux Low-Level Sync: The Futex}

До сих пор мы рассматривали два полюса синхронизации:
\begin{enumerate}
    \item \textbf{Спинлоки (Spinlocks):} Работают полностью в User Space, используя атомарные инструкции. Они феноменально быстры при отсутствии конкуренции, но при ожидании "сжигают" процессорное время впустую, нагревая воздух.
    \item \textbf{Тяжелые мьютексы (Kernel Mutexes):} Старые реализации (например, в ранних версиях Linux) всегда обращались к ядру ОС для блокировки. Это экономит CPU (поток спит), но системный вызов (`syscall`) стоит сотни наносекунд, даже если конкуренции нет.
\end{enumerate}

Истина, как всегда, посередине. Большую часть времени мьютекс свободен, и захватывать его нужно быстро (как спинлок). Но если он занят, поток должен честно уснуть (как системный мьютекс).

Именно эту гибридную модель реализует \textbf{Futex} (Fast Userspace Mutex) — фундаментальный примитив синхронизации в Linux, на котором построены \texttt{std::mutex}, \texttt{pthread\_mutex} и механизмы синхронизации в JVM и Go runtime.

\section{Философия Futex}

Основная идея Futex звучит так: \textbf{"Не тревожь ядро, если нет конкуренции"}.

\begin{definition}{Futex (Fast Userspace Mutex)}
Механизм, позволяющий потокам синхронизироваться через общую область памяти в пространстве пользователя, прибегая к системным вызовам только в случае необходимости ожидания (блокировки) или пробуждения других потоков.
\end{definition}

Технически, futex состоит из двух компонентов:
\begin{enumerate}
    \item \textbf{Aligned Integer в User Space:} Обычная 32-битная переменная (обычно `std::atomic<int32\_t>`), хранящая состояние блокировки.
    \item \textbf{Очередь ожидания в Kernel Space:} Структура внутри ядра, где хранятся спящие потоки, привязанные к физическому адресу этой переменной.
\end{enumerate}

\section{Системный вызов futex()}

В Linux нет отдельных сисколлов `futex\_wait` или `futex\_wake`. Есть один мультиплексированный вызов `sys\_futex`. Стандартная библиотека C++ не предоставляет прямого доступа к нему, поэтому для реализации собственных примитивов приходится использовать функцию `syscall`.

\begin{cppcode}[]
#include <linux/futex.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <atomic>

// Обертка над системным вызовом
long sys_futex(void* addr1, int op, int val1, 
               const struct timespec* timeout, void* addr2, int val3) {
    return syscall(SYS_futex, addr1, op, val1, timeout, addr2, val3);
}
\end{cppcode}

Рассмотрим две главные операции.

\subsection{FUTEX\_WAIT}
Сигнатура: \texttt{futex(addr, FUTEX\_WAIT, expected\_val, ...)}

\textbf{Семантика:} "Проверь атомарно, что по адресу \texttt{addr} все еще лежит значение \texttt{expected\_val}. Если это так — усыпи текущий поток. Если значение изменилось — верни управление немедленно (код ошибки \texttt{EAGAIN})."

Эта атомарная проверка критически важна. Рассмотрим сценарий гонки без нее (Lost Wakeup Problem):
\begin{enumerate}
    \item Поток А видит, что мьютекс занят (`val == 1`).
    \item Поток А решает уснуть.
    \item \textit{В этот момент происходит переключение контекста.}
    \item Поток Б освобождает мьютекс (`val = 0`) и вызывает `WAKE`. Но никто еще не спит, уведомление уходит в пустоту.
    \item \textit{Управление возвращается к А.}
    \item Поток А вызывает "безусловный sleep" и засыпает навсегда, хотя мьютекс уже свободен.
\end{enumerate}

Futex решает это, выполняя проверку значения и засыпание как единую транзакцию внутри ядра (под спинлоком планировщика).

\subsection{FUTEX\_WAKE}
Сигнатура: \texttt{futex(addr, FUTEX\_WAKE, count, ...)}

\textbf{Семантика:} "Разбуди \texttt{count} потоков, ожидающих по этому адресу".
Обычно используют:
\begin{itemize}
    \item `count = 1`: аналог `notify\_one` (для мьютексов).
    \item `count = INT\_MAX`: аналог `notify\_all` (для cond\_var или `barrier`).
\end{itemize}

\section{Реализация Mutex на базе Futex}

Напишем простейший мьютекс. Мы будем использовать три состояния переменной `state`:
\begin{itemize}
    \item \textbf{0:} Разблокировано (Unlocked).
    \item \textbf{1:} Заблокировано, нет ожидающих (Locked, no waiters).
    \item \textbf{2:} Заблокировано, есть ожидающие (Locked, with waiters).
\end{itemize}

Состояние "2" необходимо, чтобы оптимизировать `Unlock`. Если при разблокировке мы видим "1", значит, будить никого не надо, и можно не делать дорогой сисколл `FUTEX\_WAKE`.

\begin{cppcode}
class FutexMutex {
public:
    void lock() {
        int c;
        // 1. Fast Path: Попытка атомарно сменить 0 -> 1.
        // Если успешно, мы захватили мьютекс без системных вызовов.
        if ((c = cmpxchg(0, 1)) != 0) {
            
            // 2. Slow Path: Мьютекс занят.
            // Если состояние было 1, меняем его на 2 (сигнализируя о наличии ждущего).
            if (c != 2) {
                c = xchg(2);
            }
            
            // Крутимся в цикле, пока не захватим
            while (c != 0) {
                // Пытаемся уснуть.
                // Ядро усыпит нас ТОЛЬКО если state == 2.
                // Если state изменился (кто-то сделал unlock), мы не уснем.
                sys_futex(&state, FUTEX_WAIT, 2, nullptr, nullptr, 0);
                
                // Проснулись (или не спали). Пробуем захватить 2 -> 2 
                // (фактически просто check, но нам нужно атомарно убедиться)
                // В реальной реализации тут стоит повторить попытку 0 -> 2
                c = xchg(2);
            }
        }
    }

    void unlock() {
        // 1. Fast Path: Атомарно меняем любое значение на 0.
        // fetch_sub(1) было бы оптимизацией, чтобы отличить 1 от 2,
        // но здесь для простоты используем exchange.
        if (state.exchange(0) == 2) {
            // 2. Slow Path: Будим одного ждущего, только если старое значение было 2.
            sys_futex(&state, FUTEX_WAKE, 1, nullptr, nullptr, 0);
        }
    }

private:
    // Вспомогательные обертки над std::atomic
    int cmpxchg(int expected, int desired) {
        int expected_copy = expected;
        state.compare_exchange_strong(expected_copy, desired);
        return expected_copy;
    }
    
    int xchg(int desired) {
        return state.exchange(desired);
    }

    std::atomic<int> state{0}; // Требует выравнивания (обычно 4 байта)
};
\end{cppcode}

\section{Внутри ядра: Kernel Wait Queues}

Что происходит, когда вы зовете `FUTEX\_WAIT`?

1.  \textbf{Hash Table Lookup:} Ядро не может просто взять виртуальный адрес `\&state`, так как у разных процессов разные адресные пространства (а futex может быть shared между процессами). Ядро транслирует виртуальный адрес в физический (или в уникальный ключ inode+offset для memory-mapped файлов).
2.  По этому ключу вычисляется хэш, и выбирается соответствующая цепочка (bucket) в глобальной хэш-таблице `futex\_queues`.
3.  \textbf{Spinlock:} Блокируется бакет хэш-таблицы.
4.  \textbf{Atomic Check:} Ядро читает значение из user-space памяти. Если оно не совпадает с `expected`, блокировка снимается, и функция возвращает ошибку.
5.  \textbf{Sleep:} Если значения совпадают, создается объект ожидания, добавляется в очередь, и поток переводится в состояние `TASK\_INTERRUPTIBLE`. Спинлок отпускается, вызывается планировщик (`schedule()`).

Этот механизм гарантирует, что futex является самым эффективным способом блокировки в Linux, сочетая скорость атомиков (в 99\% случаев) и корректность системного ожидания при высокой нагрузке.

\begin{note}
Понимание futex необходимо для следующей главы, так как многие Lock-Free алгоритмы используют его как "fallback mechanism" (механизм отката). Нельзя бесконечно крутиться в CAS-цикле, если ожидание затягивается; рано или поздно поток нужно усыпить.
\end{note}
