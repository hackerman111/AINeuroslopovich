\chapter{SFINAE и Концепты: Управление перегрузкой функций}

Одной из самых сложных и мощных возможностей шаблонов C++ является управление выбором перегрузок. В обычном программировании перегрузка функций тривиальна: компилятор выбирает функцию, сигнатура которой лучше всего соответствует переданным аргументам.

Однако в шаблонном метапрограммировании возникают ситуации, когда <<лучшее>> с точки зрения компилятора совпадение оказывается семантически некорректным. Нам необходим механизм, позволяющий исключать определенные шаблоны из рассмотрения (из множества перегрузки — \textbf{Overload Set}) на основе свойств типов.

Исторически этим механизмом был SFINAE, а в C++20 ему на смену пришли Концепты (Concepts).

\section{Проблема жадной перегрузки}

Рассмотрим классическую проблему, с которой сталкиваются разработчики контейнеров, подобных \texttt{std::vector}. У вектора есть два похожих конструктора:
1. Конструктор заполнения: создает $n$ элементов со значением $val$.
2. Конструктор диапазона: копирует элементы из диапазона итераторов $[first, last)$.

\begin{cppcode}[]
#include <iostream>
#include <vector>

template <typename T>
class Vector {
public:
    // Конструктор 1: Заполнение (Fill Constructor)
    Vector(size_t n, const T& val) {
        std::cout << "Fill Constructor called" << std::endl;
    }

    // Конструктор 2: Диапазон (Range Constructor)
    template <typename InputIter>
    Vector(InputIter first, InputIter last) {
        std::cout << "Range Constructor called" << std::endl;
        // Представим, что здесь происходит разыменование
        // *first; 
    }
};

int main() {
    // Case A: Работает ожидаемо
    Vector<int> v1(5, 10); 
    // Аргументы: (int, int). 
    // Конструктор 1 ждет (size_t, int). Требуется конверсия int -> size_t.
    // Конструктор 2 ждет (T, T). T выводится как int. Точное совпадение!
    
    // Компилятор выбирает Конструктор 2.
    // Внутри он пытается сделать *first (разыменовать число 5).
    // ОШИБКА КОМПИЛЯЦИИ: invalid type argument of unary '*'
}
\end{cppcode}

В примере выше мы хотели создать вектор из 5 элементов со значением 10. Однако компилятор C++ следует строгим правилам разрешения перегрузки (Overload Resolution).

\textbf{Анализ ситуации для \texttt{Vector<int> v1(5, 10)}:}
\begin{itemize}
    \item \textbf{Конструктор 1:} Ожидает \texttt{size\_t, const int\&}. Мы передаем \texttt{int, int}. Требуется стандартное преобразование типа (\texttt{int} $\to$ \texttt{size\_t}).
    \item \textbf{Конструктор 2:} Шаблонный. Компилятор выводит тип \texttt{InputIter = int}. Сигнатура становится \texttt{(int, int)}. Это \textbf{точное совпадение} (Exact Match).
\end{itemize}

Точное совпадение всегда приоритетнее преобразования типов. Компилятор выбирает Конструктор 2. Затем он инстанцирует его тело. В теле мы пытаемся обращаться с \texttt{int} как с итератором (разыменовываем его). Это приводит к ошибке компиляции внутри тела функции.

Это \textbf{Hard Error}. Компиляция прерывается. Нам же нужно, чтобы компилятор, поняв, что \texttt{int} не может быть итератором, просто молча проигнорировал этот шаблон и перешел к следующему (Конструктору 1).

\section{SFINAE: Substitution Failure Is Not An Error}

Аббревиатура SFINAE (произносится как "сфинэ") расшифровывается как \textit{"Ошибка подстановки не является ошибкой"}. Это правило, зашитое в ядро компилятора C++.

\begin{definition}{Принцип SFINAE}
Если при подстановке выведенных типов в \textbf{объявление} (сигнатуру) шаблона функции или класса получается некорректный код, это не приводит к немедленной ошибке компиляции. Вместо этого, данный шаблон просто удаляется из множества кандидатов на перегрузку (Overload Set).
\end{definition}

Критически важный нюанс: ошибка должна произойти именно в \textbf{заголовке} функции (типы аргументов, возвращаемое значение, параметры шаблона). Если ошибка происходит в \textbf{теле} функции (как в примере выше), SFINAE не работает, и мы получаем ошибку компиляции.

\subsection{Инструмент std::enable\_if}

Чтобы воспользоваться SFINAE, нам нужно искусственно создать ошибку в заголовке функции, если условие не выполняется. Для этого используется метафункция \texttt{std::enable\_if}.

\begin{cppcode}
// Упрощенная реализация enable_if
template <bool B, typename T = void>
struct enable_if {};

// Специализация для true
template <typename T>
struct enable_if<true, T> {
    using type = T;
};
\end{cppcode}

Как это работает:
\begin{itemize}
    \item Если \texttt{B == true}, структура имеет вложенный тип \texttt{type} (равный \texttt{T}).
    \item Если \texttt{B == false}, структура \textbf{пуста}. Попытка обратиться к \texttt{enable\_if<false>::type} вызовет ошибку подстановки.
\end{itemize}

\subsection{Применение SFINAE к конструктору}

Мы хотим, чтобы шаблонный конструктор существовал только тогда, когда \texttt{InputIter} \textbf{не} является целочисленным типом.

Стандартный паттерн внедрения \texttt{enable\_if} в конструкторы (у которых нет возвращаемого значения) — использование дефолтного шаблонного параметра.

\begin{cppcode}[]
#include <type_traits>

template <typename T>
class Vector {
public:
    Vector(size_t n, const T& val) { /* ... */ }

    // Этот конструктор будет рассматриваться только если
    // InputIter НЕ является интегральным типом.
    template <typename InputIter, 
              typename = std::enable_if_t<!std::is_integral_v<InputIter>>>
    Vector(InputIter first, InputIter last) {
        std::cout << "Range Constructor" << std::endl;
    }
};
\end{cppcode}

\textbf{Разбор механики:}
1. Вызов \texttt{Vector(5, 10)}.
2. Компилятор пытается инстанцировать шаблонный конструктор.
3. \texttt{InputIter} выводится как \texttt{int}.
4. Проверяется условие: \texttt{!std::is\_integral\_v<int>}. Это \texttt{false}.
5. Вычисляется \texttt{std::enable\_if\_t<false>}. Такого типа \texttt{type} не существует.
6. Происходит ошибка подстановки в параметрах шаблона.
7. Благодаря SFINAE, компилятор \textbf{молча отбрасывает} этот конструктор.
8. Единственным оставшимся кандидатом является \texttt{Vector(size\_t, const T\&)}.
9. Аргументы конвертируются, код компилируется корректно.

\section{Detection Idiom и void\_t}

Часто требуется проверить не просто тип (является ли он числом), а наличие определенного метода или вложенного типа. Например, "есть ли у типа метод \texttt{.size()}?".

Для этого используется идиома обнаружения (Detection Idiom) на базе \texttt{std::void\_t}.
\texttt{std::void\_t<Args...>} — это метафункция, которая всегда превращается в \texttt{void}, но требует, чтобы все аргументы \texttt{Args...} были валидными типами.

\begin{cppcode}
// Базовый шаблон: по умолчанию false
template <typename T, typename = void>
struct has_size : std::false_type {};

// Специализация: срабатывает, только если выражение валидно
template <typename T>
struct has_size<T, std::void_t<decltype(std::declval<T>().size())>> 
    : std::true_type {};
\end{cppcode}

Если у типа \texttt{T} есть метод \texttt{size()}, специализация становится валидной (второй аргумент \texttt{void}). Поскольку специализация более специфична, чем базовый шаблон, компилятор выбирает её, и мы получаем \texttt{true\_type}. Если метода нет — SFINAE отбрасывает специализацию, и мы падаем в базовый шаблон (\texttt{false\_type}).

\section{Концепты (Concepts) в C++20}

SFINAE — это мощный, но крайне неудобный инструмент.
1. Синтаксис ужасен (угловые скобки, \texttt{typename}, \texttt{::type}).
2. Сообщения об ошибках нечитаемы. Если ни одна перегрузка не подошла, компилятор вываливает простыню текста о том, почему не сработал \texttt{enable\_if}.
3. Это "хак" системы типов, а не штатная возможность.

C++20 ввел \textbf{Концепты} — прямой способ ограничения шаблонов.

\subsection{Синтаксис Requires}

Вместо \texttt{std::enable\_if} мы используем ключевое слово \texttt{requires} после списка параметров шаблона. Перепишем наш пример с вектором:

\begin{cppcode}[]
#include <concepts>

template <typename T>
class Vector {
public:
    Vector(size_t n, const T& val) { /* ... */ }

    // Читаемо и декларативно:
    template <typename InputIter>
    requires (!std::integral<InputIter>) // Ограничение
    Vector(InputIter first, InputIter last) {
        /* ... */
    }
};
\end{cppcode}

Более того, стандартная библиотека предоставляет готовый концепт \texttt{std::input\_iterator}, который проверяет, что тип ведет себя как итератор (поддерживает \texttt{++}, \texttt{*}, \texttt{!=}).

\begin{cppcode}
    template <std::input_iterator InputIter> // Сокращенный синтаксис
    Vector(InputIter first, InputIter last) { /* ... */ }
\end{cppcode}

Если мы теперь попытаемся передать числа в этот конструктор, сообщение об ошибке будет гласить: \textit{"template constraint not satisfied: int is not an input\_iterator"}. Это на порядок понятнее, чем ошибки подстановки SFINAE.

\subsection{Ad-hoc ограничения}

Концепты позволяют проверять валидность произвольных выражений прямо по месту, не создавая отдельных структур (как в случае с \texttt{void\_t}).

\begin{cppcode}
template <typename T>
requires requires (T x) {
    x.size();         // Должен быть метод size()
    typename T::value_type; // Должен быть вложенный тип value_type
    { x + x } -> std::convertible_to<int>; // Результат сложения приводим к int
}
void process(T obj) {
    // ...
}
\end{cppcode}

Выражение \texttt{requires (T x) \{ ... \}} создает область видимости, где мы описываем "пробный код". Компилятор проверяет, валиден ли этот код для типа \texttt{T}. Этот код никогда не исполняется, только проверяется.

\begin{summary}
\begin{itemize}
    \item \textbf{Overload Resolution} всегда предпочитает точное совпадение типов конверсии. Это опасно для обобщенных конструкторов.
    \item \textbf{SFINAE} позволяет убрать функцию из списка перегрузок, если подстановка типов создает ошибку в сигнатуре.
    \item \textbf{std::enable\_if} — основной инструмент SFINAE до C++20. Обычно применяется как дефолтный аргумент шаблона.
    \item \textbf{Concepts (C++20)} полностью заменяют SFINAE. Они делают код чище, а ошибки компиляции — понятными. Всегда предпочитайте \texttt{requires} использованию \texttt{enable\_if} в современном коде.
\end{itemize}
\end{summary}
