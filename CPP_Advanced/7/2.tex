\chapter{Метапрограммирование на Шаблонах (TMP) и Constexpr}

Метапрограммирование в C++ — это методика написания программ, которые выполняются компилятором и генерируют другие программы (или константы) в качестве своего вывода. Это Turing-complete подсистема языка, встроенная непосредственно в процесс компиляции.

Исторически метапрограммирование в C++ развивалось от случайного открытия возможности вычислений на шаблонах (Template Metaprogramming — TMP) до полноценной поддержки вычислений времени компиляции через механизм \texttt{constexpr}. В этой главе мы рассмотрим эволюцию этих подходов: от сложных рекурсивных структур к современному императивному коду, выполняемому на этапе трансляции.

\section{Классический TMP: Шаблоны как функциональный язык}

До стандарта C++11 шаблоны были единственным способом заставить компилятор выполнять произвольные вычисления. Этот подход (Legacy TMP) базируется на функциональной парадигме. В нем отсутствуют переменные (все данные иммутабельны) и циклы.

\begin{definition}{Template Metaprogramming (TMP)}
Парадигма, где:
\begin{itemize}
    \item \textbf{Функции} представлены шаблонными структурами (\texttt{struct} или \texttt{class}).
    \item \textbf{Аргументы} передаются как параметры шаблона (\texttt{<int N, typename T>}).
    \item \textbf{Возвращаемые значения} — это вложенные константы (\texttt{static const value}) или определения типов (\texttt{typedef type}).
    \item \textbf{Циклы} реализуются через рекурсию.
    \item \textbf{Ветвление} реализуется через специализацию шаблонов.
\end{itemize}
\end{definition}

\subsection{Рекурсия и Специализация: Вычисление факториала}

Классическим примером ("Hello World" от мира TMP) является вычисление факториала. Поскольку циклы \texttt{for} или \texttt{while} недоступны на уровне инстанцирования шаблонов, используется рекурсивное определение.

\begin{cppcode}[]
#include <iostream>

// Общий шаблон: N! = N * (N-1)!
template <unsigned long N>
struct Factorial {
    // "Возвращаемое значение" вычисляется рекурсивно
    static const unsigned long value = N * Factorial<N - 1>::value;
};

// Условие выхода из рекурсии: специализация для 0
// 0! = 1
template <>
struct Factorial<0> {
    static const unsigned long value = 1;
};

int main() {
    // Вычисление происходит полностью во время компиляции.
    // В бинарный код попадает только константа 3628800.
    std::cout << Factorial<10>::value << std::endl;
    return 0;
}
\end{cppcode}

\textbf{Механика работы:}
Когда компилятор встречает \texttt{Factorial<10>}, он пытается инстанцировать эту структуру. Внутри он видит обращение к \texttt{Factorial<9>}. Это запускает цепную реакцию инстанцирования:
\[ F\langle10\rangle \to F\langle9\rangle \to \dots \to F\langle1\rangle \to F\langle0\rangle \]
На этапе \texttt{Factorial<0>} компилятор выбирает специализацию, где \texttt{value} жестко задано как 1. После этого цепочка сворачивается обратно, перемножая константы.

\begin{important}
Глубина рекурсии шаблонов ограничена компилятором (обычно 900-1024 уровня). Превышение этого лимита приводит к ошибке компиляции. Это одна из главных проблем классического TMP.
\end{important}

\subsection{Ветвление времени компиляции (Static If)}

В классическом TMP нельзя написать \texttt{if}, так как инструкции процессора не существуют на этапе компиляции. Ветвление реализуется через выбор одного из двух типов.

\begin{cppcode}
// Базовый шаблон (не определен или false-ветка)
template <bool Condition, typename T, typename F>
struct If {
    using type = F; // По умолчанию выбираем False-тип
};

// Частичная специализация для true
template <typename T, typename F>
struct If<true, T, F> {
    using type = T; // Если Condition == true, выбираем True-тип
};

// Пример использования
using ResultType = If<sizeof(void*) == 8, long long, int>::type;
\end{cppcode}

Здесь \texttt{ResultType} станет \texttt{long long} на 64-битной системе и \texttt{int} на 32-битной. Это решение является предшественником \texttt{std::conditional} из стандартной библиотеки.

\section{Constexpr: Возвращение к императивному стилю}

С выходом C++11, а затем C++14 и C++20, подход к метапрограммированию кардинально изменился. Ключевое слово \texttt{constexpr} сообщает компилятору, что выражение \textit{может} быть вычислено во время компиляции.

Это позволяет писать метапрограммы на обычном C++, используя привычный синтаксис (циклы, переменные, условные операторы), вместо сложной магии шаблонов.

\subsection{Эволюция Constexpr}

\begin{enumerate}
    \item \textbf{C++11}: Функции \texttt{constexpr} были крайне ограничены. Они могли содержать только один оператор \texttt{return}. Никаких переменных, циклов или \texttt{if}.
    \begin{cppcode}
    // C++11 стиль
    constexpr int factorial(int n) {
        return (n == 0) ? 1 : n * factorial(n - 1);
    }
    \end{cppcode}
    
    \item \textbf{C++14}: Ограничения сняты. Разрешены локальные переменные, циклы \texttt{for/while}, условия \texttt{if}, при условии, что они не модифицируют глобальное состояние и не вызывают non-constexpr код.
    \begin{cppcode}
    // C++14 стиль
    constexpr int factorial(int n) {
        int result = 1;
        for (int i = 1; i <= n; ++i) {
            result *= i;
        }
        return result;
    }
    \end{cppcode}
\end{enumerate}

Теперь тот же самый факториал вычисляется без создания сотен типов \texttt{struct}, что значительно снижает нагрузку на компилятор и ускоряет сборку.

\subsection{Compile-time аллокация памяти (C++20)}

До C++20 вся память в \texttt{constexpr} контексте должна была быть стековой (локальной). Динамическое выделение памяти (\texttt{new}/\texttt{delete}) было запрещено.

C++20 ввел понятие \textbf{Transient Allocation} (временная аллокация). Теперь внутри \texttt{constexpr} функции можно выделять память через \texttt{new}, \textbf{при условии}, что эта память будет освобождена (\texttt{delete}) до завершения вычисления этой функции. Память "не может вытечь" из этапа компиляции в рантайм.

Это изменение позволило сделать методы \texttt{std::vector} и \texttt{std::string} \texttt{constexpr}. Теперь можно сортировать векторы и конкатенировать строки прямо во время компиляции.

\begin{cppcode}[]
#include <vector>
#include <numeric>
#include <algorithm>

constexpr int sum_squares(int n) {
    std::vector<int> v; // Аллокация памяти на этапе компиляции!
    for (int i = 0; i < n; ++i) v.push_back(i);
    
    // Использование STL алгоритмов
    int sum = 0;
    for (int x : v) sum += x * x;
    
    return sum; // Вектор уничтожается здесь, память освобождается.
}

// Результат вычисляется компилятором
constexpr int val = sum_squares(10); 
\end{cppcode}

\section{If Constexpr (C++17)}

Одним из важнейших дополнений C++17 стала конструкция \texttt{if constexpr}. В отличие от обычного \texttt{if}, условие в \texttt{if constexpr} должно быть известно на этапе компиляции. Главная особенность: \textbf{отбрасываемая ветка не инстанцируется}.

Это решает фундаментальную проблему обобщенного программирования: как написать код, который работает для типов с разными интерфейсами, не вызывая ошибок компиляции.

\subsection{Проблема обычного if}

Рассмотрим функцию, которая возвращает \texttt{.size()} контейнера, если метод существует, или 0, если это просто число.

\begin{cppcode}
template <typename T>
auto get_size_bad(const T& t) {
    if (std::is_integral_v<T>) {
        return 0;
    } else {
        return t.size(); // ОШИБКА КОМПИЛЯЦИИ для int!
    }
}
\end{cppcode}

Даже если мы передадим \texttt{int}, компилятор обязан скомпилировать обе ветки обычного \texttt{if}. При попытке скомпилировать \texttt{int.size()} произойдет ошибка, несмотря на то, что эта ветка никогда не выполнится в рантайме.

\subsection{Решение через if constexpr}

Используя \texttt{if constexpr}, мы указываем компилятору полностью игнорировать код в неактивной ветке. Он проверяется только на базовый синтаксис, но не на корректность методов типа \texttt{T}.

\begin{cppcode}[]
#include <type_traits>

template <typename T>
auto get_size_safe(const T& t) {
    if constexpr (std::is_integral_v<T>) {
        return 0;
    } else {
        // Эта строка компилируется ТОЛЬКО если T не интегральный тип.
        // Для int вызов .size() даже не будет проверяться.
        return t.size(); 
    }
}
\end{cppcode}

Этот механизм позволяет писать компактный обобщенный код, заменяя сложные конструкции SFINAE (которые мы рассмотрим в следующей главе) на читаемые блоки условий.

\begin{note}
Код внутри \texttt{if constexpr} все равно должен быть синтаксически корректным C++. Вы не можете написать там случайный набор символов, даже если ветка отбрасывается.
\end{note}

\begin{summary}
\begin{itemize}
    \item \textbf{Legacy TMP} использует рекурсию шаблонов и специализацию. Это мощный, но трудный для чтения и медленный при компиляции подход.
    \item \textbf{Constexpr} позволяет перенести обычную логику C++ (циклы, переменные) на этап компиляции.
    \item \textbf{C++20} разрешает динамическую память в \texttt{constexpr}, делая доступными \texttt{std::vector} и \texttt{std::string}.
    \item \textbf{if constexpr} позволяет исключать куски кода из компиляции в зависимости от свойств типов, упрощая написание шаблонов.
\end{itemize}
\end{summary}
