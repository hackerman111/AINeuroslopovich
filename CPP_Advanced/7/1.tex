
\chapter{Препроцессор и Макромагия: От текстовой подстановки до кодогенерации}

Метапрограммирование в C++ часто ассоциируется исключительно с шаблонами (templates), однако исторически первым и до сих пор широко используемым инструментом метапрограммирования является препроцессор. 

Препроцессор языка C (и C++) — это утилита, которая обрабатывает исходный код \textbf{до} этапа компиляции. Он не знает синтаксиса C++, не понимает типов данных, областей видимости или классов. Для препроцессора ваш код — это просто поток текста (набор токенов), над которым производятся операции подстановки, склейки и условного включения.

\section{Фундаментальные механики}

Работа препроцессора управляется директивами, начинающимися с символа \texttt{\#}. Эти директивы выполняются на самом раннем этапе трансляции, превращая исходный файл \texttt{.cpp} в единицу трансляции (translation unit), готовую к синтаксическому анализу компилятором.

\subsection{Include Guards и условная компиляция}

Одной из базовых задач препроцессора является управление зависимостями и платформо-зависимым кодом. Директива \texttt{\#include} буквально копирует содержимое указанного файла в точку вызова. Это создает проблему множественного включения: если заголовочный файл \texttt{A.h} включен в \texttt{B.h} и \texttt{C.h}, а \texttt{main.cpp} включает и \texttt{B}, и \texttt{C}, то содержимое \texttt{A.h} попадет в \texttt{main.cpp} дважды, что приведет к ошибкам переопределения символов (ODR — One Definition Rule).

Традиционное решение — Include Guards:

\begin{cppcode}[]
#ifndef MY_HEADER_H
#define MY_HEADER_H

struct MyStruct { /* ... */ };

#endif // MY_HEADER_H
\end{cppcode}

Также препроцессор используется для проверки окружения. Макросы позволяют включать или исключать куски кода в зависимости от ОС, компилятора или конфигурации сборки (Debug/Release).

\begin{cppcode}[]
#ifdef _WIN32
    #include <Windows.h>
#elif defined(__unix__)
    #include <unistd.h>
#else
    #error "Unknown platform"
#endif
\end{cppcode}

\begin{important}
Директива \texttt{\#error} прерывает компиляцию с указанным сообщением. Это полезно для гарантии того, что код не будет собран на неподдерживаемой архитектуре, вместо того чтобы получить тысячи непонятных синтаксических ошибок далее.
\end{important}

\subsection{Предопределенные макросы}

Компилятор предоставляет набор стандартных макросов, которые содержат информацию о текущем контексте компиляции. Они часто используются для логирования и отладки.

\begin{itemize}
    \item \texttt{\_\_LINE\_\_} (int): Текущий номер строки в исходном файле.
    \item \texttt{\_\_FILE\_\_} (string literal): Имя текущего файла.
    \item \texttt{\_\_func\_\_} (string literal): Имя текущей функции (стандартизировано в C99/C++11). В GCC/Clang также доступен нестандартный \texttt{\_\_PRETTY\_FUNCTION\_\_}, который выводит полную сигнатуру функции, включая типы аргументов и шаблонов.
\end{itemize}

Имена, начинающиеся с двух подчеркиваний (\texttt{\_\_}) или с одного подчеркивания и заглавной буквы (\texttt{\_Big}), зарезервированы стандартом для реализации. Определение собственных макросов с такими именами является Undefined Behavior.

\section{Макросы как функции}

Функциональные макросы позволяют выполнять текстовую подстановку аргументов. В отличие от шаблонов или \texttt{inline}-функций, макросы не проверяют типы и вычисляются путем простой замены токенов.

\subsection{Опасность приоритета операций}

При написании макросов критически важно оборачивать каждый аргумент и все выражение целиком в скобки. Поскольку препроцессор просто вставляет текст, операторы с низким приоритетом могут "захватить" соседние выражения.

Рассмотрим некорректный макрос:
\begin{cppcode}[]
#define MUL(a, b) a * b

int res = MUL(2 + 3, 4 + 5); 
// Раскрывается в: 2 + 3 * 4 + 5
// Результат: 2 + 12 + 5 = 19
// Ожидалось: 5 * 9 = 45
\end{cppcode}

Корректная реализация:
\begin{cppcode}[]
#define MUL(a, b) ((a) * (b))
\end{cppcode}

\subsection{Stringification (Оператор \#)}

Оператор решетки \texttt{\#} используется для превращения аргумента макроса в строковый литерал. Это невозможно сделать средствами самого C++, так как имена переменных теряются после компиляции.

Это ключевой механизм для реализации \texttt{assert}-ов, которые выводят само проверяемое выражение при ошибке.

\begin{cppcode}[]
#include <iostream>
#include <cstdlib>

#define MY_ASSERT(expr) \
    if (!(expr)) { \
        std::cerr << "Assertion failed: " << #expr \
                  << ", file " << __FILE__ \
                  << ", line " << __LINE__ << std::endl; \
        std::abort(); \
    }

int main() {
    int x = 5;
    // Вывод: Assertion failed: x == 2, file main.cpp, line 15
    MY_ASSERT(x == 2); 
}
\end{cppcode}

Обратите внимание: препроцессор видит выражение \texttt{x == 2} как последовательность токенов, а оператор \texttt{\#} превращает их в строку \texttt{"x == 2"}.

\subsection{Идиома do-while(0)}

При создании многострочных макросов возникает проблема корректного синтаксиса в управляющих конструкциях. Если просто обернуть код в фигурные скобки \texttt{\{ \}}, использование макроса в ветке \texttt{if} может сломать \texttt{else}.

Пример проблемы:
\begin{cppcode}[]
#define LOG_ERROR(msg) \
    { std::cerr << "Error: "; std::cerr << msg << std::endl; }

if (cond)
    LOG_ERROR("Fail"); // Точка с запятой здесь завершает if!
else                   // ОШИБКА: else без if
    /* ... */
\end{cppcode}

Раскрытие кода:
\begin{cppcode}
if (cond)
    { std::cerr << "Error: "; std::cerr << "Fail" << std::endl; };
else // Синтаксическая ошибка: лишняя ; перед else
\end{cppcode}

Решение — использование цикла \texttt{do \{ ... \} while(0)}. Эта конструкция требует точки с запятой на конце, что делает вызов макроса синтаксически идентичным вызову обычной функции.

\begin{cppcode}[]
#define LOG_ERROR(msg) \
    do { \
        std::cerr << "Error: "; \
        std::cerr << msg << std::endl; \
    } while(0)
\end{cppcode}

\section{Variadic Macros и перегрузка}

C99 и C++11 принесли поддержку макросов с переменным числом аргументов. Они обозначаются многоточием \texttt{...}, а доступ к аргументам осуществляется через идентификатор \texttt{\_\_VA\_ARGS\_\_}.

Одной из самых мощных (и неочевидных) техник является перегрузка макросов по количеству аргументов. Поскольку препроцессор не поддерживает перегрузку функций напрямую, приходится использовать трюк с подменой макроса-диспетчера.

\subsection{Механизм выбора N-го аргумента}

Задача: реализовать макрос \texttt{ENSURE}, который можно вызывать как \texttt{ENSURE(cond)} или \texttt{ENSURE(cond, message)}.

Алгоритм:
1. Создать два макроса реализации: \texttt{ENSURE\_1(cond)} и \texttt{ENSURE\_2(cond, msg)}.
2. Создать макрос-селектор, который выбирает нужную реализацию в зависимости от количества переданных аргументов.

\begin{cppcode}
// Реализации
#define ENSURE_1(cond) \
    if (!(cond)) { std::cerr << "Check failed: " << #cond << std::endl; std::abort(); }

#define ENSURE_2(cond, msg) \
    if (!(cond)) { std::cerr << msg << std::endl; std::abort(); }

// Магия выбора
// Этот макрос принимает набор аргументов и возвращает 3-й аргумент
#define GET_3RD_ARG(arg1, arg2, arg3, ...) arg3

// Макрос-диспетчер
// Если передано 1 аргумент (x):
//   GET_3RD_ARG(x, ENSURE_2, ENSURE_1) -> вернет ENSURE_1
// Если передано 2 аргумента (x, y):
//   GET_3RD_ARG(x, y, ENSURE_2, ENSURE_1) -> вернет ENSURE_2
#define ENSURE_MACRO_CHOOSER(...) \
    GET_3RD_ARG(__VA_ARGS__, ENSURE_2, ENSURE_1)

// Итоговый макрос
#define ENSURE(...) \
    ENSURE_MACRO_CHOOSER(__VA_ARGS__)(__VA_ARGS__)
\end{cppcode}

Этот механизм работает за счет сдвига аргументов. Макрос \texttt{GET\_3RD\_ARG} всегда возвращает третий элемент из списка. Подставляя в него пользовательские аргументы \texttt{\_\_VA\_ARGS\_\_} в начало, мы сдвигаем служебные имена макросов (\texttt{ENSURE\_2}, \texttt{ENSURE\_1}) на нужную позицию.

\section{X-Macros: Кодогенерация списков}

Одной из самых частых проблем C++ является отсутствие рефлексии. Например, при объявлении \texttt{enum} для цветов, мы теряем текстовое представление имени цвета. Чтобы вывести имя цвета в лог, приходится писать функцию \texttt{ToString} с большим \texttt{switch-case}, дублируя имена констант.

Техника \textbf{X-Macros} позволяет определить данные один раз и генерировать различный код (enum, массив строк, switch-case) путем многократного включения списка.

\subsection{Реализация X-Macro}

Идея состоит в том, чтобы список элементов был определен как последовательность вызовов некоторого (пока не определенного) макроса \texttt{X}.

\begin{cppcode}
// colors.def (или просто #define внутри файла)
#define LIST_OF_COLORS(X) \
    X(Red) \
    X(Green) \
    X(Blue) \
    X(Yellow)
\end{cppcode}

Теперь мы можем использовать этот список для генерации кода.

\textbf{Шаг 1: Генерация enum}
Мы определяем макрос \texttt{X(name)} так, чтобы он разворачивался в \texttt{name,}.

\begin{cppcode}
enum class Color {
    #define X(name) name,
    LIST_OF_COLORS(X)
    #undef X
};
// Раскроется в:
// enum class Color {
//     Red,
//     Green,
//     Blue,
//     Yellow,
// };
\end{cppcode}

\textbf{Шаг 2: Генерация функции ToString}
Мы переопределяем \texttt{X(name)} так, чтобы он генерировал \texttt{case}.

\begin{cppcode}
const char* ToString(Color c) {
    switch (c) {
        #define X(name) case Color::name: return #name;
        LIST_OF_COLORS(X)
        #undef X
    }
    return "Unknown";
}
// Раскроется в:
// switch (c) {
//     case Color::Red: return "Red";
//     case Color::Green: return "Green";
//     ...
// }
\end{cppcode}

\begin{definition}{X-Macros}
Это паттерн использования препроцессора, при котором данные отделяются от их представления. Данные описываются в виде списка вызовов макроса-заглушки, который переопределяется контекстно для генерации различных структур кода (объявлений, массивов, операторов switch).
\end{definition}

Эта техника широко используется в крупных проектах (например, в LLVM или ClickHouse) для синхронизации конфигураций, кодов ошибок или настроек CLI, гарантируя, что добавление нового элемента в список автоматически обновит все связанные структуры данных.

\begin{summary}
\begin{itemize}
    \item Препроцессор — мощный инструмент текстовой генерации, работающий до компилятора.
    \item Всегда используйте скобки вокруг аргументов макроса и идиому \texttt{do-while(0)} для многострочных макросов.
    \item Оператор \texttt{\#} позволяет получить строковое представление кода (полезно для отладки и сериализации).
    \item X-Macros позволяют эмулировать рефлексию и избегать дублирования кода при работе с перечислениями и списками свойств.
\end{itemize}
\end{summary}
