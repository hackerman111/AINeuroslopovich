\chapter{Кризис конкурентности и абстракция Корутины}

В основе современной архитектуры высоконагруженных систем лежит проблема эффективной утилизации вычислительных ресурсов. Процессор (CPU) — дорогостоящий ресурс, который должен выполнять инструкции максимально плотно. Однако анализ работы большинства программ показывает парадоксальную картину: CPU редко загружен на 100\%, при этом пропускная способность системы (throughput) не растет.

В этой главе мы рассмотрим физические причины простоя процессора, недостатки классической модели многопоточности и архитектурный переход к кооперативной многозадачности в User Space через абстракцию корутин.

\section{Проблема утилизации CPU}

Программы делятся на два класса по типу нагрузки:
\begin{enumerate}
    \item \textbf{Compute-bound (Вычислительно-емкие):} Хэширование, перемножение матриц, рендеринг. Утилизируют CPU полностью.
    \item \textbf{I/O-bound (Зависимые от ввода-вывода):} Работа с сетью, диском, базой данных.
\end{enumerate}

Большинство прикладного ПО относится ко второму типу. Рассмотрим цикл работы I/O-bound потока:
1. Выполнение логики запроса (CPU busy).
2. Отправка запроса в сеть или на диск (System Call).
3. Синхронное ожидание ответа (Blocked state).

В момент ожидания (пункт 3) поток операционной системы (OS Thread) заблокирован. С точки зрения планировщика ОС, поток не готов к исполнению. Ядро процессора переключается на другой поток. Если активных потоков, готовых к вычислениям, нет, процессор переходит в режим ожидания (idle).

\begin{important}
В синхронной модели ввода-вывода поток бездействует большую часть времени жизни, но продолжает занимать физические ресурсы операционной системы (стек, структуры ядра).
\end{important}

\section{Кризис модели «Thread per Request»}

В начале 2000-х годов (эпоха Apache HTTP Server) стандартом архитектуры была модель \textbf{Thread per Request}: на каждое входящее соединение создавался отдельный поток ОС.

Этот подход масштабируется до определенного предела. При росте нагрузки (C10K problem — 10 000 одновременных соединений) система деградирует из-за накладных расходов.

\subsection{1. Расход памяти (Stack Memory)}
Каждый поток ОС требует выделения стека.
\begin{itemize}
    \item Стандартный размер стека в Linux: 8 МБ (configurable, `ulimit -s`).
    \item Минимальный разумный размер: ~64 КБ – 2 МБ.
\end{itemize}
При 10 000 потоков даже с минимальным стеком в 256 КБ потребление памяти составит $10^4 \times 256 \text{ КБ} \approx 2.5 \text{ ГБ}$. Это память, выделенная только под инфраструктуру, без учета полезных данных приложения.

\subsection{2. Переключение контекста (Context Switching)}
Планировщик ОС (OS Scheduler) работает в режиме вытесняющей многозадачности (Preemptive Multitasking). Переключение между потоками — дорогая операция.
\begin{itemize}
    \item \textbf{Kernel Space Transition:} Процессор переходит в привилегированный режим (Ring 0).
    \item \textbf{Cache Pollution:} Сброс L1/L2 кэшей, TLB (Translation Lookaside Buffer).
    \item \textbf{Latency:} Одно переключение занимает микросекунды (1-5 мкс). При тысячах активных потоков процессор тратит существенное время (overhead) не на полезную работу, а на сам процесс переключения.
\end{itemize}

\begin{note}
Операционная система не обладает контекстом приложения (Application Knowledge). Она не знает, какой поток получит данные первым или какой поток выполняет критически важную задачу. Планирование происходит «вслепую» на основе приоритетов и квантов времени.
\end{note}

\section{User Space Scheduling}

Решение проблемы — отказ от маппинга «один запрос — один поток». Вместо этого используется пул потоков (Thread Pool), количество которых равно количеству физических ядер CPU.

\begin{definition}{User Space Scheduling}
Планирование задач выполняется внутри процесса пользователя, без участия ядра ОС.
\end{definition}

Задачи (Tasks) становятся легкими объектами. Когда задача блокируется на I/O, она не блокирует поток ОС. Вместо этого она \textbf{приостанавливается} (Suspend), её состояние сохраняется, а поток берет следующую задачу из очереди.

Эту модель называют \textbf{Кооперативной многозадачностью}: задачи сами отдают управление, когда им нужно подождать.

\section{Анатомия Корутины}

Корутина (Coroutine) — это обобщение понятия функции.

Для обычной функции (Subroutine) определены две операции:
\begin{enumerate}
    \item \textbf{Call (Invoke):} Создание стекового кадра, передача аргументов, переход на первую инструкцию.
    \item \textbf{Return:} Уничтожение стекового кадра, возврат результата, переход к точке вызова.
\end{enumerate}

Корутина добавляет две новые операции:
\begin{enumerate}
    \item \textbf{Suspend (Приостановка):} Сохранение текущего состояния исполнения (локальные переменные, instruction pointer) в выделенную область памяти (не на стек потока!). Управление возвращается вызывающей стороне (Caller) или планировщику.
    \item \textbf{Resume (Возобновление):} Восстановление состояния из памяти и продолжение исполнения с точки остановки.
\end{enumerate}

\begin{figure}[h]
\centering
\begin{tcolorbox}[colback=white, colframe=nordDark, title=Операции управления потоком]
\textbf{Subroutine:}
\begin{itemize}
    \item Start $\rightarrow$ Execute $\rightarrow$ Terminate
\end{itemize}

\textbf{Coroutine:}
\begin{itemize}
    \item Start $\rightarrow$ Execute $\rightarrow$ \textbf{Suspend} (Save State) $\rightarrow$ Return Control
    \item ... (Time passes) ...
    \item \textbf{Resume} (Restore State) $\rightarrow$ Execute $\rightarrow$ Terminate
\end{itemize}
\end{tcolorbox}
\end{figure}

\section{Прототипирование ментальной модели (Python)}

Прежде чем переходить к C++, рассмотрим семантику корутин на языке Python. Механизм генераторов в Python концептуально идентичен тому, что мы хотим получить в C++, хотя реализация кардинально отличается (интерпретатор vs компилятор).

Задача: реализовать генератор последовательности чисел (аналог `range`), который не хранит весь массив в памяти, а вычисляет следующее число по требованию.

\begin{pythoncode}
def range_gen(max_val):
    num = 0
    while True:
        # yield возвращает значение и "замораживает" функцию
        yield num  
        num += 1
        if num >= max_val:
            return

# Использование
gen = range_gen(3)

print(next(gen)) # Вывод: 0. Функция дошла до yield num
print(next(gen)) # Вывод: 1. Функция продолжилась с num += 1
print(next(gen)) # Вывод: 2
# print(next(gen)) # StopIteration
\end{pythoncode}

\subsection{Разбор механики}

Ключевое слово \texttt{yield} выполняет роль \textbf{Suspend + Output}.

\begin{enumerate}
    \item 
 При первом вызове `next(gen)` функция запускается, инициализирует `num = 0`.
    \item 
 Доходит до `yield num`.
    \item 
 Интерпретатор сохраняет состояние (значение `num`, позицию инструкции) в объект генератора `gen`.
    \item 
 Функция «возвращает» 0 и приостанавливается.
    \item 
 При следующем вызове `next(gen)` состояние восстанавливается. Исполнение продолжается \textbf{сразу после} `yield`. Выполняется `num += 1`.
    \item 
 Цикл `while` отправляет исполнение снова на `yield`.
\end{enumerate}

\begin{important}
С точки зрения вызывающего кода (Caller), корутина — это объект, который можно опрашивать. С точки зрения самой корутины — это непрерывный поток выполнения, который иногда ставится на паузу.
\end{important}

В C++20 мы стремимся к аналогичной семантике, но с требованием \textbf{Zero Overhead}. Компилятор должен преобразовать код с точками остановки в конечный автомат (State Machine) на этапе компиляции, избегая динамической аллокации тяжелых структур интерпретатора.

\begin{summary}
\begin{itemize}
    \item Классические потоки неэффективны для I/O-нагрузки из-за накладных расходов на контекст и память.
    \item Корутины реализуют User Space Scheduling, позволяя «останавливать» вычисления без блокировки ядра.
    \item Основные примитивы корутин: Suspend (сохранить состояние) и Resume (восстановить состояние).
    \item Генераторы Python — хорошая ментальная модель для понимания потока управления (Control Flow) в корутинах.
\end{itemize}
\end{summary}
