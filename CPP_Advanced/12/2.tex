\chapter{Архитектурный выбор: Stackful vs Stackless}

При разработке стандарта C++20 перед комитетом стоял фундаментальный выбор архитектуры корутин. Существует два полярных подхода к реализации асинхронности: \textbf{Stackful} (с собственным стеком) и \textbf{Stackless} (бесстековые).

Этот выбор определяет не только синтаксис, но и характеристики производительности, потребление памяти и возможности оптимизации. C++ пошел по пути \textit{Stackless}, что отличает его от Go (Goroutines) или Java (Project Loom). В этой главе мы разберем технические детали обоих подходов и причины выбора C++.

\section{Stackful Coroutines (Fibers)}

Stackful корутины (часто называемые Файберами или Зелеными потоками) — это прямая проекция модели потоков операционной системы в пространство пользователя.

\subsection{Механика работы}
Каждая Stackful корутина при создании аллоцирует \textbf{собственный непрерывный блок памяти под стек}. Этот стек используется для хранения:
\begin{itemize}
    \item Локальных переменных текущей функции.
    \item Адресов возврата (Return Addresses) при вложенных вызовах функций.
    \item Аргументов функций.
\end{itemize}

Переключение контекста (Context Switch) между двумя файберами выглядит так:
\begin{enumerate}
    \item 
 Сохранить регистры процессора (CPU Registers: RIP, RSP, RBP и регистры общего назначения) в текущий стек или специальную структуру контекста.
    \item 
 Подменить указатель стека (\texttt{RSP}) на стек целевого файбера.
    \item 
 Восстановить регистры целевого файбера.
    \item 
 Выполнить инструкцию перехода (\texttt{JMP} или \texttt{RET}).
\end{enumerate}

С точки зрения исполняемого кода, файбер ничем не отличается от потока. Функция может уйти в глубокую рекурсию, вызвать десять вложенных функций, и где-то на глубине 11-го уровня вызвать `yield()`. Поскольку у файбера есть свой стек, всё состояние цепочки вызовов сохраняется автоматически.

\subsection{Достоинства и Недостатки}

\textbf{Плюсы:}
\begin{itemize}
    \item \textbf{Прозрачность для кода:} Можно взять старую синхронную библиотеку, запустить её внутри файбера, и если она использует блокирующие вызовы (переопределенные через `yield`), она станет асинхронной без переписывания кода.
    \item \textbf{Произвольная вложенность:} Приостановка возможна в любой точке стека вызовов.
\end{itemize}

\textbf{Минусы:}
\begin{itemize}
    \item \textbf{Накладные расходы на память:} Это главная проблема. Сколько памяти выделить под стек?
    \begin{itemize}
        \item Если выделить мало (4 КБ), возможен \textit{Stack Overflow} при глубокой рекурсии.
        \item Если выделить много (1 МБ) с запасом, то миллион корутин потребует 1 ТБ виртуальной памяти.
    \end{itemize}
    \item \textbf{Segmented Stacks / Stack Copying:} Чтобы решить проблему размера, языки вроде Go используют динамически растущие стеки. Это вносит оверхед: при каждом вызове функции нужно проверять, хватает ли стека, и при необходимости переаллоцировать его и копировать данные. Это нарушает ABI C++ и несовместимо с указателями на локальные переменные (адреса меняются при перемещении стека).
\end{itemize}

\section{Stackless Coroutines (C++20)}

C++20 выбрал модель Stackless. В этой модели корутина \textbf{не имеет собственного стека}. Она использует стек вызывающего потока (Thread Stack) для выполнения кода между точками приостановки.

\begin{definition}{Stackless Coroutine}
Функция, которая может быть приостановлена только на верхнем уровне своего тела (в точках использования ключевых слов `co\_await`/`co\_yield`). Состояние сохраняется не на стеке, а в специально сгенерированном объекте в куче.
\end{definition}

\subsection{State Machine Transformation}
Компилятор преобразует функцию-корутину в конечный автомат (State Machine).
\begin{enumerate}
    \item Анализируется тело функции.
    \item Все локальные переменные, время жизни которых пересекает точку приостановки (\texttt{suspend point}), переносятся из стека в поля класса-автомата.
    \item Точки входа в корутину размечаются через `switch/case` или `goto` метки.
\end{enumerate}

Это фундаментальное отличие. Вместо сохранения \textit{всего} стека, сохраняется только \textit{минимально необходимое} состояние конкретной функции.

\section{Under the hood: Трансформация кода}

Рассмотрим, как концептуально происходит трансформация.

\textbf{Исходный код корутины (C++):}

\begin{cppcode}
generator<int> sequence(int start) {
    int x = start;       // Локальная переменная
    int y = 42;          // Переменная, живущая "сквозь" yield
    
    // Точка остановки 1
    co_yield x;          
    
    x += y;
    
    // Точка остановки 2
    co_yield x;          
}
\end{cppcode}

\textbf{Результат компиляции (Псевдокод C++):}

Компилятор генерирует структуру, часто называемую \textit{Coroutine Frame}.

\begin{cppcode}
struct Sequence_Frame {
    // 1. Служебные поля (Promise, Resume Point)
    int _resume_point = 0; // Индекс точки возобновления
    promise_type _promise;
    
    // 2. Сохраненные аргументы
    int start;
    
    // 3. Сохраненные локальные переменные
    // 'x' и 'y' нужны после resume, поэтому они здесь.
    // Если бы была переменная 'z', которая умирает до co_yield,
    // она бы осталась на стеке и не попала в Frame.
    int x;
    int y;
    
    void resume() {
        switch (_resume_point) {
            case 0: goto STATE_0;
            case 1: goto STATE_1;
            case 2: goto STATE_2;
        }

    STATE_0:
        x = start;
        y = 42;
        
        // co_yield x -> suspend
        _promise.value = x;
        _resume_point = 1;
        return; // Возврат управления вызывающему (Caller)

    STATE_1:
        x += y; // Восстановили контекст, выполняем операцию
        
        // co_yield x -> suspend
        _promise.value = x;
        _resume_point = 2;
        return;

    STATE_2:
        // Завершение корутины
        _promise.return_void();
    }
};
\end{cppcode}

\subsection{Анализ эффективности}
\begin{itemize}
    \item \textbf{Размер:} Структура `Sequence\_Frame` занимает ровно столько байт, сколько нужно для хранения `int x, int y` и служебных полей. Это десятки байт, а не килобайты стека.
    \item \textbf{Аллокация:} Фрейм выделяется в куче (Heap Allocation) один раз при старте корутины. C++ позволяет оптимизировать это через HALO (Heap Allocation Elision), если компилятор видит, что время жизни корутины полностью вложено в вызывающую функцию.
    \item \textbf{Переключение:} Вызов `resume()` — это непрямой вызов функции (indirect function call) плюс `switch`. Это дешевле, чем подмена регистров и стека процессора.
\end{itemize}

\section{Почему C++ выбрал Stackless?}

Выбор в пользу Stackless был продиктован философией C++: \textbf{"Zero Overhead Abstraction"}.

\begin{enumerate}
    \item \textbf{Масштабируемость (Scalability):}
    Stackless корутины потребляют память пропорционально количеству реальных данных, а не глубине резервируемого стека. Это позволяет создавать \textbf{миллиарды} корутин на одной машине. В случае Stackful, даже 4 КБ стека на корутину ограничили бы нас ~250 000 корутин на 1 ГБ памяти.
    
    \item \textbf{Отсутствие магического рантайма:}
    Stackful корутины требуют сложного менеджера памяти для стеков (сборка мусора стеков, сплит-стеки). Stackless корутины компилируются в простые структуры данных, с которыми можно работать стандартными аллокаторами.
    
    \item \textbf{Взаимодействие с C ABI:}
    Stackless корутина при возобновлении использует обычный стек потока. Это значит, что внутри корутины можно вызывать обычный C-код, использовать указатели на стек и все оптимизации компилятора. Stackful реализации часто ломают совместимость с существующим кодом из-за перемещения стеков в памяти.
\end{enumerate}

\begin{summary}
\begin{itemize}
    \item \textbf{Stackful (Fibers):} Эмуляция потоков. Просто писать код, но дорого по памяти. Требует отдельного стека.
    \item \textbf{Stackless (C++20):} Синтаксический сахар над конечными автоматами. Нет своего стека.
    \item C++ использует \textbf{Stackless} для минимизации оверхеда. Компилятор "нарезает" функцию на куски и сохраняет локальные переменные в объект-фрейм в куче.
\end{itemize}
\end{summary}
