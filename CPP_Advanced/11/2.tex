\chapter{Теория гарантий прогресса: Lock-free и Wait-free}

В разработке многопоточных систем термины \textit{lock-free} и \textit{wait-free} часто используются ошибочно как синонимы "высокой производительности". Однако в строгом академическом смысле это не метрики скорости, а гарантии прогресса системы (\textit{progress guarantees}).

Эти гарантии описывают поведение алгоритма в условиях максимальной конкуренции (\textit{contention}) или при нештатном поведении планировщика (например, приостановка потоков).

\section{Lock-freedom: Глобальный прогресс}

\begin{definition}{Lock-free (LF)}
Алгоритм называется \textbf{lock-free}, если гарантируется, что при непрерывном выполнении системы хотя бы один поток сделает полезный прогресс за конечное число шагов.
\end{definition}

Свойство \textit{lock-freedom} является глобальным (system-wide). Оно не гарантирует, что конкретный поток $T_1$ когда-либо завершит свою операцию. Оно лишь гарантирует, что система в целом не зависнет. Если $T_1$ не может завершить операцию, это происходит только потому, что какой-то другой поток $T_2$ \textit{успешно} завершил свою операцию, изменив состояние разделяемой структуры.

\subsection{Критерий приостановки (Suspension Criterion)}

Интуитивный способ проверки алгоритма на lock-freedom — мысленный эксперимент с "заморозкой" потока.

\begin{important}
Если мы произвольно остановим (suspend) любой поток (например, в отладчике или из-за троттлинга ОС) в любой точке выполнения, другие потоки \textbf{должны} иметь возможность продолжать выполнение и завершать свои операции.
\end{important}

Если остановка одного потока приводит к тому, что остальные потоки начинают бесконечно ожидать (как в случае с захваченным мьютексом), алгоритм \textbf{не является} lock-free.

\section{Wait-freedom: Локальный прогресс}

\begin{definition}{Wait-free (WF)}
Алгоритм называется \textbf{wait-free}, если гарантируется, что \textbf{каждый} поток сделает прогресс (завершит операцию) за конечное, ограниченное число шагов, независимо от действий других потоков.
\end{definition}

Это более строгое требование. Wait-free алгоритм исключает не только взаимные блокировки (deadlocks), но и голодание (starvation). Никакая конкуренция не может заставить поток выполняться бесконечно долго.

Иерархия гарантий выглядит так:
\[ \text{Wait-free} \subset \text{Lock-free} \subset \text{Blocking (с блокировками)} \]
Любой wait-free алгоритм является lock-free, но обратное неверно.

\section{Классификация алгоритмов синхронизации}

Рассмотрим классические примитивы через призму гарантий прогресса.

\subsection{1. Mutex и Spinlock (Blocking)}

Использование \texttt{std::mutex} или самописного спинлока автоматически выводит алгоритм из категории lock-free.

\begin{cppcode}
std::mutex mtx;

void blocked_op() {
    mtx.lock();
    // CRITICAL SECTION
    // Если поток будет остановлен здесь (OS scheduler, crash),
    // то НИКТО больше не сможет войти в секцию.
    // Прогресс системы равен нулю.
    mtx.unlock();
}
\end{cppcode}

Спинлок, реализованный на атомиках (как в Главе 1), технически использует lock-free инструкции процессора (CAS, test-and-set), но \textit{алгоритмически} является блокирующим. Ожидание в цикле \texttt{while} зависит от действий другого потока (владельца), что нарушает определение lock-freedom.

\subsection{2. CAS-Loop (Lock-free)}

Классический паттерн для реализации атомарных транзакций (например, добавление в стек) — цикл Compare-And-Swap.

\begin{cppcode}
void lock_free_op(std::atomic<int>& shared_data) {
    int old_val = shared_data.load();
    int new_val;
    
    do {
        new_val = complex_calculation(old_val);
        // Пытаемся атомарно обновить:
        // Если shared_data == old_val, то пишем new_val и выходим (true).
        // Если нет, в old_val записывается актуальное значение, повторяем (false).
    } while (!shared_data.compare_exchange_weak(old_val, new_val));
}
\end{cppcode}

\textbf{Анализ прогресса:}
\begin{itemize}
    \item Представим, что 10 потоков одновременно зашли в этот цикл.
    \item Они конкурируют за \texttt{compare\_exchange}.
    \item В конкретный момент времени только \textbf{один} поток выиграет гонку (у него CAS вернет \texttt{true}). Он совершит прогресс и выйдет из функции.
    \item Остальные 9 потоков получат \texttt{false}, обновят свои локальные копии \texttt{old\_val} и пойдут на следующую итерацию.
    \item \textbf{Результат:} Система совершила прогресс (одна операция выполнена), несмотря на то, что 9 потоков "потратили время впустую".
\end{itemize}

Этот алгоритм — \textbf{Lock-free}, но не \textbf{Wait-free}, так как теоретически возможен сценарий, где "поток-неудачник" бесконечно проигрывает гонку CAS более быстрым потокам (livelock/starvation). Однако система в целом продолжает работать.

\subsection{3. Атомарные Load/Store (Wait-free)}

Простейшие операции над \texttt{std::atomic} (если они аппаратно поддерживаются) являются wait-free.

\begin{cppcode}
std::atomic<int> flag{0};

void set_flag() {
    // Выполняется за фиксированное число инструкций процессора.
    // Не содержит циклов.
    // Не зависит от других потоков.
    flag.store(1); 
}
\end{cppcode}

Wait-free алгоритмы сложнее в реализации для комплексных структур данных, так как требуют механизмов помощи (\textit{helping}), когда один поток, видя, что другой застрял, помогает ему завершить операцию.

\section{Зачем нужны эти гарантии?}

Частое заблуждение: "Lock-free код быстрее". Как показано в бенчмарках (Глава 1), это не всегда так из-за высокой стоимости CAS-инструкций и cache-contention. Главная ценность lock-free не в пропускной способности (\textit{throughput}), а в надежности и предсказуемости задержек (\textit{latency}).

\subsection{1. Устойчивость к инверсии приоритетов (Priority Inversion)}
В системах с блокировками возможна ситуация, когда низкоприоритетный поток захватывает мьютекс и прерывается планировщиком. Высокоприоритетный поток, ожидающий этот мьютекс, вынужден ждать, пока низкоприоритетный получит процессорное время. В lock-free алгоритмах высокоприоритетный поток может просто выполнить свою операцию (через CAS), "перебив" или завершив работу за медленный поток.

\subsection{2. Устойчивость к сбоям (Fault Tolerance)}
Если поток, владеющий мьютексом, аварийно завершается (segfault, kill), мьютекс остается "зависшим" (в несогласованном состоянии), что приводит к дедлоку всей системы (если не использовать специальные \textit{robust mutexes}). Lock-free структуры данных всегда остаются в согласованном состоянии: сбой потока посередине CAS-цикла не портит данные, так как изменение либо произошло целиком, либо не произошло вовсе.

\begin{summary}
\begin{itemize}
    \item \textbf{Lock-free:} Гарантирует отсутствие взаимных блокировок (deadlock). Система всегда движется вперед, но отдельные потоки могут голодать.
    \item \textbf{Wait-free:} Гарантирует отсутствие голодания (starvation). Время выполнения операции ограничено сверху.
    \item Lock-free алгоритмы необходимы там, где недопустима блокировка всей системы из-за остановки одного потока (системы реального времени, обработчики сигналов, ядра ОС).
\end{itemize}
\end{summary}
