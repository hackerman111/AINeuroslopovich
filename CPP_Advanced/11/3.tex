\chapter{Паттерн CAS-Loop и сложные атомарные операции}

Стандартная библиотека C++ предоставляет ограниченный набор атомарных операций модификации: сложение (\texttt{fetch\_add}), вычитание (\texttt{fetch\_sub}) и побитовые операции (\texttt{and}, \texttt{or}, \texttt{xor}). Однако на практике часто требуются более сложные транзакции, например, атомарное умножение, вычисление максимума или обновление битовых полей по маске.

Для реализации любой произвольной операции Read-Modify-Write (RMW) используется универсальный примитив: \textbf{Compare-And-Swap (CAS)}.

\section{Анатомия Compare-And-Swap}

Инструкция CAS — это самая "тяжелая" и мощная операция в арсенале атомиков. На ней строятся все lock-free структуры данных.

В C++ она представлена семейством методов \texttt{compare\_exchange}.

\subsection{Сигнатура и семантика}

\begin{cppcode}
bool compare_exchange_weak(T& expected, T desired, ...);
bool compare_exchange_strong(T& expected, T desired, ...);
\end{cppcode}

Ключевая особенность, которую часто упускают новички: первый аргумент \texttt{expected} передается \textbf{по ссылке}. Он играет двойную роль: входного параметра (ожидание) и выходного (реальность).

Логика работы метода (псевдокод):
\begin{cppcode}
// Атомарно внутри процессора:
if (this->value == expected) {
    this->value = desired; // Успех: записали новое значение
    return true;
} else {
    expected = this->value; // Неудача: обновили expected реальным значением
    return false;
}
\end{cppcode}

Это избавляет программиста от необходимости делать повторный \texttt{load()} при неудаче. Метод сам сообщает: "Ты ожидал А, но там лежит Б. Я записал Б в твою переменную \texttt{expected}, попробуй еще раз".

\section{Weak vs Strong: Цена гарантий}

Стандарт C++ разделяет CAS на две версии.

\begin{definition}{Spurious Failure (Ложный отказ)}
Ситуация, когда \texttt{compare\_exchange} возвращает \texttt{false}, и значение не обновляется, даже если текущее значение атомика \textbf{равно} \texttt{expected}.
\end{definition}

\subsection{compare\_exchange\_weak}
Разрешает ложные отказы. На некоторых архитектурах (ARM, PowerPC) атомарные операции реализуются через пару инструкций LL/SC (Load Linked / Store Conditional). Если между ними произошло прерывание или другой поток тронул кэш-линию, запись может не пройти, даже если значение не менялось.
\begin{itemize}
    \item \textbf{Преимущество:} Генерирует более эффективный машинный код на RISC-архитектурах.
    \item \textbf{Использование:} Всегда используется в циклах.
\end{itemize}

\subsection{compare\_exchange\_strong}
Гарантирует отсутствие ложных отказов. Возвращает \texttt{false} только если значение реально не совпадает.
\begin{itemize}
    \item \textbf{Цена:} На RISC-архитектурах компилятор генерирует вложенный цикл для сокрытия ложных отказов.
    \item \textbf{Использование:} Когда операция выполняется однократно (вне цикла) и повтор вычисления \texttt{desired} слишком дорог.
\end{itemize}

\begin{important}
В 99\% случаев при написании lock-free алгоритмов вы будете использовать паттерн цикла. В цикле \textbf{всегда} используйте \texttt{weak} версию. Использование \texttt{strong} в цикле приводит к двойной вложенности циклов на уровне ассемблера.
\end{important}

\section{Реализация Atomic Fetch-Max}

Рассмотрим задачу: реализовать атомарную функцию, обновляющую переменную значением \texttt{max(current, value)}. Стандартного \texttt{fetch\_max} нет.

Мы используем паттерн \textbf{CAS-Loop}.

\begin{cppcode}[]
#include <atomic>
#include <algorithm>

void atomic_fetch_max(std::atomic<int>& atom, int val) {
    // 1. Предварительная загрузка текущего состояния (Snapshot)
    // Можно использовать memory_order_relaxed, так как порядок пока не важен
    int prev = atom.load(std::memory_order_relaxed);

    // 2. Цикл попыток (CAS Loop)
    while (prev < val) {
        // 3. Попытка атомарной подмены
        // Если atom == prev, то записать val. Вернуть true.
        // Если atom != prev, то prev = atom. Вернуть false.
        if (atom.compare_exchange_weak(prev, val, 
                                       std::memory_order_release, 
                                       std::memory_order_relaxed)) {
            break; // Успех!
        }
        
        // 4. Неявная ветвь else (при неудаче):
        // compare_exchange_weak УЖЕ обновил переменную 'prev' 
        // актуальным значением из атомика.
        // Мы просто идем на следующую итерацию while.
        // Там условие (prev < val) проверится заново с новым prev.
    }
}
\end{cppcode}

\subsection{Построчный разбор механики}

\begin{enumerate}
    \item \texttt{int prev = atom.load(...)}: Мы делаем локальную копию значения. Это наше предположение о состоянии мира.
    \item \texttt{while (prev < val)}: Оптимизация. Если текущее значение в атомике уже больше или равно \texttt{val}, нам не нужно ничего писать. Мы выходим без дорогих операций записи.
    \item \texttt{compare\_exchange\_weak(prev, val, ...)}: Это точка синхронизации.
        \begin{itemize}
            \item \textbf{Сценарий Успеха:} Между \texttt{load} (или предыдущей попыткой) и этой инструкцией никто не трогал \texttt{atom}. Значение успешно обновлено.
            \item \textbf{Сценарий Провала:} Другой поток успел записать свое значение. В \texttt{atom} теперь лежит условное число 100, а мы думали там 50.
        \end{itemize}
    \item \textbf{Автоматическое обновление:} При провале переменная \texttt{prev} по ссылке получает значение 100. На следующей итерации цикла мы проверим \texttt{100 < val} и попробуем сделать CAS(100, val).
\end{enumerate}

\section{Доказательство свойства Lock-free}

Почему этот алгоритм является Lock-free, но не Wait-free?

\textbf{1. Не Wait-free:}
Теоретически возможна ситуация, когда поток-неудачник бесконечно крутится в цикле \texttt{while}. Это происходит, если между моментом проверки условия и вызовом CAS всегда вклинивается другой поток, изменяющий переменную. Время выполнения операции для конкретного потока не ограничено сверху.

\textbf{2. Является Lock-free:}
Цикл продолжается только тогда, когда CAS возвращает \texttt{false}.
CAS возвращает \texttt{false} (игнорируя spurious failure) только тогда, когда значение в атомике \textbf{изменилось}.
Значение меняется только в том случае, если какой-то другой поток успешно выполнил свой CAS (или \texttt{store}).

\begin{summary}
Следовательно, бесконечное выполнение цикла в одном потоке означает бесконечное количество успешных обновлений данных в других потоках. Глобальный прогресс системы гарантирован.
\end{summary}

\begin{note}
CAS-loop — это оптимистичная блокировка. Мы предполагаем, что конфликта не будет, делаем работу локально, а в конце пытаемся "закоммитить" результат. Если конфликт был — откатываемся и повторяем. Это выгоднее мьютексов при низкой и средней конкуренции.
\end{note}
