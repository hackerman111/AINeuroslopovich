\chapter{Модели памяти: Sequentially Consistent vs Relaxed}

При работе с атомарными переменными программист обязан явно или неявно выбирать \textbf{модель памяти} (Memory Order). Этот выбор определяет, какие гарантии компилятор и процессор предоставляют относительно порядка выполнения инструкций и видимости изменений между потоками.

Ошибочный выбор модели памяти приводит к гейзенбагам, которые невозможно воспроизвести в отладчике, но которые гарантированно возникают под высокой нагрузкой на специфическом оборудовании (например, на архитектуре ARM).

\section{Sequentially Consistent (SC)}

Модель по умолчанию в C++ — \texttt{std::memory\_order\_seq\_cst} (Sequentially Consistent).

\begin{definition}{Sequential Consistency}
Модель исполнения, при которой результат работы многопоточной программы эквивалентен некоторому последовательному чередованию (\textit{interleaving}) инструкций всех потоков на одноядерном процессоре.
\end{definition}

Это самая сильная ("строгая") модель. Она интуитивно понятна человеку, так как сохраняет причинно-следственные связи.

\textbf{Гарантии SC:}
\begin{enumerate}
    \item \textbf{Total Order:} Существует единый глобальный порядок всех модификаций всех SC-атомиков. Все потоки видят изменения в одном и том же порядке.
    \item \textbf{Отсутствие переупорядочивания:} Инструкции исходного кода не могут "перепрыгивать" через SC-операции ни вверх, ни вниз.
\end{enumerate}

\subsection{Цена абстракции}
За простоту приходится платить производительностью. Чтобы обеспечить SC, компилятор обязан:
\begin{itemize}
    \item Отключить многие оптимизации (перестановка инструкций).
    \item Вставить аппаратные барьеры памяти (\textit{memory fences/barriers}). На x86 это часто инструкции \texttt{MFENCE} или \texttt{LOCK prefixed instructions}, которые сбрасывают конвейер процессора и принудительно синхронизируют буферы записи.
\end{itemize}

\section{Аппаратная реальность: Store Buffers}

Чтобы понять необходимость более слабых моделей, нужно рассмотреть архитектуру процессора. Запись в оперативную память (RAM) — операция экстремально медленная (сотни тактов CPU).

Чтобы не останавливать конвейер на каждой инструкции записи, процессоры используют \textbf{Store Buffer} (буфер записи).

\textbf{Механика:}
\begin{enumerate}
    \item Ядро выполняет инструкцию записи \texttt{x = 1}.
    \item Значение помещается в локальный Store Buffer ядра, а не в кэш L1/RAM. Процессор продолжает выполнение следующих инструкций \textbf{мгновенно}.
    \item Спустя время буфер сбрасывается (\textit{flush}) в когерентный кэш, и только тогда изменение становится видимым другим ядрам.
\end{enumerate}

\begin{important}
Наличие Store Buffer приводит к тому, что порядок \textit{выполнения} инструкций (Program Order) не совпадает с порядком \textit{видимости} изменений (Visibility Order) для других ядер.
\end{important}

\section{Relaxed Ordering (Ослабленная модель)}

Модель \texttt{std::memory\_order\_relaxed} снимает все ограничения на синхронизацию и порядок видимости, оставляя только одну гарантию: \textbf{атомарность} самой операции над переменной.

\begin{itemize}
    \item \textbf{Нет Happends-Before:} Запись \texttt{x.store(1, relaxed)} в одном потоке не гарантирует, что другой поток увидит это значение "своевременно" относительно других переменных.
    \item \textbf{Свобода компилятора:} Компилятор может менять местами Relaxed-инструкции с обычными операциями, если это не ломает однопоточную логику.
\end{itemize}

Это самая дешевая модель. На большинстве архитектур она компилируется в обычные инструкции \texttt{MOV} без барьеров.

\section{Парадокс Store Buffer: "Невозможный" результат}

Рассмотрим классический пример, демонстрирующий разницу между SC и Relaxed (пример Деккера).

У нас есть две атомарные переменные \texttt{x} и \texttt{y}, инициализированные нулями.

\begin{cppcode}
std::atomic<int> x{0}, y{0};

// Поток 1
void thread_1() {
    x.store(1, std::memory_order_relaxed); // (A)
    int r1 = y.load(std::memory_order_relaxed); // (B)
}

// Поток 2
void thread_2() {
    y.store(1, std::memory_order_relaxed); // (C)
    int r2 = x.load(std::memory_order_relaxed); // (D)
}
\end{cppcode}

\subsection{Анализ в Sequential Consistency}
Если бы мы использовали \texttt{seq\_cst}, возможны разные чередования, например:
\begin{itemize}
    \item $A \rightarrow B \rightarrow C \rightarrow D \implies r1=0, r2=1$
    \item $C \rightarrow D \rightarrow A \rightarrow B \implies r1=1, r2=0$
    \item $A \rightarrow C \rightarrow B \rightarrow D \implies r1=1, r2=1$
\end{itemize}
Исход $r1=0, r2=0$ \textbf{невозможен}. Чтобы $r1$ был 0, (B) должно выполниться до (C). Чтобы $r2$ был 0, (D) должно выполниться до (A). Это создает цикл противоречий.

\subsection{Анализ в Relaxed (Store Buffer Reality)}
При использовании \texttt{relaxed} исход \textbf{$r1=0, r2=0$} становится \textbf{возможным}.

\textbf{Физическое объяснение:}
\begin{enumerate}
    \item Поток 1 выполняет (A): \texttt{x=1}. Значение попадает в Store Buffer ядра 1. В основной памяти \texttt{x} все еще 0.
    \item Поток 1 сразу выполняет (B): читает \texttt{y}. В памяти \texttt{y} равно 0. Результат: \texttt{r1=0}.
    \item Поток 2 выполняет (C): \texttt{y=1}. Значение попадает в Store Buffer ядра 2.
    \item Поток 2 сразу выполняет (D): читает \texttt{x}. Ядро 2 не видит буфер ядра 1. В памяти \texttt{x} все еще 0. Результат: \texttt{r2=0}.
    \item Спустя время буферы сбрасываются в память, но слишком поздно — потоки уже прочитали нули.
\end{enumerate}

С точки зрения внешнего наблюдателя, произошло переупорядочивание: чтение (Load) выполнилось раньше, чем запись (Store) — эффект \textbf{StoreLoad Reordering}.

\begin{summary}
\begin{itemize}
    \item Используйте \texttt{seq\_cst} по умолчанию. Это безопасно и предсказуемо.
    \item Используйте \texttt{relaxed} только для счетчиков статистики или когда порядок видимости переменной абсолютно не влияет на логику других потоков.
    \item Никогда не используйте \texttt{relaxed} для реализации механизмов публикации данных (флаг готовности, указатель на объект), так как данные могут стать видимы \textit{позже}, чем флаг готовности.
\end{itemize}
\end{summary}
