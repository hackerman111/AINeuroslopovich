\chapter{Практикум: Разработка Lock-free Stack и его фатальные ошибки}

Разработка lock-free контейнеров кардинально отличается от разработки их блокирующих аналогов. Если в \texttt{std::stack} под мьютексом мы можем использовать \texttt{std::vector}, то в lock-free мире динамический массив практически неприменим. Переаллокация памяти (resizing) требует эксклюзивного доступа ко всему массиву, что противоречит идее lock-free.

Поэтому стандартом де-факто для lock-free стека является односвязный список (Treiber Stack).

\section{Базовая архитектура}

Структура данных предельно проста: атомарный указатель на вершину списка (\texttt{head}).

\begin{cppcode}[]
#include <atomic>

template <typename T>
struct Node {
    T data;
    Node* next;
    
    Node(const T& d) : data(d), next(nullptr) {}
};

template <typename T>
class LockFreeStack {
    std::atomic<Node<T>*> head;

public:
    LockFreeStack() : head(nullptr) {}
    // ... методы ...
};
\end{cppcode}

\section{Реализация операции Push}

Операция вставки элемента является безопасной и относительно простой. Мы создаем новый узел (который пока невидим для других потоков) и атомарно подменяем \texttt{head}.

\begin{cppcode}
void push(const T& data) {
    Node<T>* new_node = new Node<T>(data);
    
    // 1. Загружаем текущую голову
    new_node->next = head.load();

    // 2. CAS-цикл
    // Мы пытаемся сделать new_node новой головой.
    // Если head изменился за это время, CAS обновит new_node->next
    // (через параметр expected) и мы попробуем снова.
    while (!head.compare_exchange_weak(new_node->next, new_node)) {
        // Тело цикла пустое. 
        // new_node->next автоматически обновлен актуальным значением head.
    }
}
\end{cppcode}

Этот код корректен и является lock-free. Новый узел является локальным для потока до момента успешного CAS, поэтому гонок данных на нем нет.

\section{Наивная реализация Pop}

Кажется, что удаление элемента симметрично вставке. Нам нужно прочитать \texttt{head}, запомнить следующий элемент и атомарно переставить \texttt{head} на следующий.

\begin{cppcode}
// ВНИМАНИЕ: ЭТОТ КОД СОДЕРЖИТ КРИТИЧЕСКИЕ ОШИБКИ
bool pop(T& result) {
    Node<T>* old_head = head.load();

    while (old_head && 
           !head.compare_exchange_weak(old_head, old_head->next)) {
        // Если CAS не удался, old_head обновлен.
        // Крутимся, пока не удалим или пока стек не станет пустым.
    }

    if (old_head == nullptr) {
        return false; // Стек пуст
    }

    result = old_head->data; // Извлечение данных
    delete old_head;         // Освобождение памяти
    return true;
}
\end{cppcode}

Данная реализация иллюстрирует "проблему наивного lock-free". Она компилируется, проходит простые тесты, но неизбежно приведет к падению (segfault) и коррупции данных под нагрузкой.

\section{Фатальная ошибка №1: Use-After-Free}

В многопоточной среде нельзя просто так разыменовать указатель, полученный из общей структуры данных. Между моментом чтения указателя и доступом к его полям объект мог быть удален другим потоком.

В строке \texttt{compare\_exchange\_weak(old\_head, old\_head->next)} происходит обращение к \texttt{old\_head->next}. Рассмотрим сценарий краха:

\begin{enumerate}
    \item \textbf{Поток A:} Читает \texttt{head}. Пусть это адрес \texttt{0x1000}.
    \item \textbf{Поток A:} Прерывается планировщиком ОС сразу после чтения, но ДО вызова CAS.
    \item \textbf{Поток B:} Вызывает \texttt{pop()}. Успешно удаляет узел \texttt{0x1000}.
    \item \textbf{Поток B:} Вызывает \texttt{delete 0x1000}. Память возвращена ОС или аллокатору.
    \item \textbf{Поток A:} Просыпается. Пытается вычислить второй аргумент для CAS: \texttt{old\_head->next}.
    \item \textbf{Результат:} Обращение к освобожденной памяти (\texttt{0x1000}). Segmentation Fault.
\end{enumerate}

\begin{important}
В lock-free алгоритмах с динамической памятью \textbf{нельзя} использовать \texttt{delete} сразу после извлечения узла, если есть вероятность, что другие потоки всё ещё держат на него ссылки.
\end{important}

\section{Фатальная ошибка №2: Проблема ABA}

Даже если мы решим проблему чтения мусора (например, не будем удалять память, а положим её в список переиспользования), нас поджидает проблема ABA (ABA Problem). Она связана с тем, что CAS проверяет равенство \textit{значений} (адресов), а не \textit{идентичность} объектов во времени.

Пусть стек выглядит так: \textbf{Top -> A -> B -> C}.

\begin{enumerate}
    \item \textbf{Поток 1:} Начинает \texttt{pop}.
    \begin{itemize}
        \item Читает \texttt{old\_head = A}.
        \item Читает \texttt{next = A->next} (это \textbf{B}).
        \item Засыпает перед CAS. Он "думает", что хочет заменить A на B.
    \end{itemize}
    
    \item \textbf{Поток 2:} Вытесняет Поток 1 и работает агрессивно.
    \begin{itemize}
        \item \texttt{pop()}: Удаляет A. Стек: \textbf{B -> C}. Узел A освобожден.
        \item \texttt{pop()}: Удаляет B. Стек: \textbf{C}. Узел B освобожден.
        \item \texttt{push(D)}: Добавляет D. Стек: \textbf{D -> C}.
        \item \texttt{push(E)}: Аллокатор памяти, видя, что адрес от узла A свободен, \textbf{переиспользует} его для нового узла E.
        \item Теперь адрес E равен адресу A.
        \item Стек: \textbf{A(новый) -> D -> C}.
    \end{itemize}
    
    \item \textbf{Поток 1:} Просыпается.
    \begin{itemize}
        \item Выполняет \texttt{CAS(expected=A, desired=B)}.
        \item Процессор сравнивает текущий \texttt{head} и \texttt{expected}. Оба равны адресу A. \textbf{CAS успешен!}
        \item Поток 1 устанавливает \texttt{head} в \textbf{B}.
    \end{itemize}
\end{enumerate}

\textbf{Катастрофа:}
Текущее состояние стека: \textbf{Top -> B}.
Но узел B был давно удален! Узлы D и C потеряны (утечка памяти), структура списка сломана, \texttt{head} указывает на освобожденную память.

\section{Стратегии решения}

Написание корректного lock-free стека (MPMC — Multi-Producer Multi-Consumer) требует сложных схем управления памятью (Memory Reclamation).

\subsection{1. Tagged Pointers (Версионирование)}
В 64-битных процессорах используются не все 64 бита адреса (обычно только 48). Мы можем упаковать счетчик обновлений (tag) в неиспользуемые биты указателя.
При каждом изменении \texttt{head} мы инкрементируем счетчик.
Теперь CAS сравнивает пару \texttt{\{ptr, counter\}}.
В примере с ABA: адрес будет тот же (A), но счетчик изменится. CAS провалится.

\subsection{2. Hazard Pointers}
Потоки публикуют список указателей ("Hazard Pointers"), которые они сейчас читают, в глобальном массиве. Поток, желающий удалить узел, сначала сканирует массивы Hazard Pointers всех потоков. Если на узел кто-то смотрит — удаление откладывается.

\subsection{3. Ослабление требований (MPSC)}
Если алгоритм допускает наличие только одного потребителя (Single Consumer), то проблемы ABA и Use-After-Free при \texttt{pop} исчезают, так как конфликт возникает только между методами \texttt{pop} и \texttt{pop}. \texttt{push} остается безопасным для многих потоков.

\begin{summary}
Lock-free программирование — это не просто расстановка атомиков. Это борьба с моделью памяти, аллокатором и самой природой конкурентности. Без применения Hazard Pointers или RCU написание корректного связного списка на C++ невозможно.
\end{summary}
