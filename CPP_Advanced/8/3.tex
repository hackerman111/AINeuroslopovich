\chapter{Гонки данных и модель памяти}

Введение многопоточности в программу фундаментально меняет модель её исполнения. Если в однопоточном коде поведение строго детерминировано (инструкции выполняются последовательно), то в многопоточном окружении порядок исполнения инструкций разных потоков относительно друг друга не определен. Это приводит к двум классам проблем: состоянию гонки (Race Condition) и гонке данных (Data Race). Хотя эти термины часто используют как синонимы, в C++ между ними существует принципиальная разница: первое — это логическая ошибка, второе — неопределенное поведение (Undefined Behavior).

\section{Race Condition vs Data Race}

Для начала разграничим понятия.

\begin{definition}{Race Condition (Состояние гонки)}
Ситуация, когда результат работы программы (или её состояние) зависит от того, в каком порядке планировщик ОС решит исполнять потоки. Это семантическая ошибка. Программа технически корректна с точки зрения языка, но делает не то, что ожидал программист.
\end{definition}

\begin{definition}{Data Race (Гонка данных)}
Ситуация, когда два и более потока одновременно обращаются к одной и той же ячейке памяти, при этом:
\begin{enumerate}
    \item Минимум один из потоков выполняет запись (модификацию).
    \item Между обращениями нет синхронизации (atomic, mutex).
\end{enumerate}
В стандарте C++ это строго классифицируется как \textbf{Undefined Behavior}.
\end{definition}

\section{Пример 1: Вывод в консоль (Race Condition)}

Рассмотрим классический пример, с которого начинают изучение потоков.

\begin{cppcode}[]
#include <thread>
#include <iostream>

void print_hello(int id) {
    // Оператор << вызывается цепочкой
    std::cout << "Thread " << id << " says hello!" << std::endl;
}

int main() {
    std::thread t1(print_hello, 1);
    std::thread t2(print_hello, 2);
    t1.join();
    t2.join();
}
\end{cppcode}

При запуске этой программы вы можете получить корректный вывод, а можете увидеть что-то вроде:
\texttt{Thread 1 says Thread 2 says hello!hello!}

Это \textbf{Race Condition}. Стандартная библиотека C++ гарантирует, что глобальные объекты вроде \texttt{std::cout} потокобезопасны в том смысле, что их внутреннее состояние не будет разрушено (программа не упадет). Однако атомарность гарантируется только на уровне одного вызова функции (одного оператора \texttt{<<}).

Выражение \texttt{std::cout << "A" << "B"} — это два последовательных вызова функции. Планировщик может прервать первый поток после вывода "A", переключиться на второй, который выведет свои данные, и только потом вернуться к первому.

\subsection{Решение: std::osyncstream}

В C++20 появился синхронизируемый поток вывода \texttt{std::osyncstream} (заголовок \texttt{<syncstream>}). Он накапливает вывод во внутреннем буфере и атомарно сбрасывает его в выходной поток при уничтожении или вызове \texttt{emit()}.

\begin{cppcode}[]
#include <syncstream>

void safe_print(int id) {
    std::osyncstream(std::cout) << "Thread " << id << " says hello!\n";
    // При выходе из выражения временный объект osyncstream разрушается 
    // и атомарно пишет в cout.
}
\end{cppcode}

\section{Пример 2: Инкремент (Data Race)}

Теперь рассмотрим ситуацию, которая является фатальной ошибкой. Пусть у нас есть глобальный счетчик, который инкрементируют несколько потоков.

\begin{cppcode}[]
#include <thread>
#include <vector>
#include <iostream>

int counter = 0; // Разделяемый ресурс

void worker() {
    for (int i = 0; i < 100000; ++i) {
        counter++; // Data Race!
    }
}

int main() {
    std::thread t1(worker);
    std::thread t2(worker);
    t1.join();
    t2.join();
    std::cout << "Result: " << counter << std::endl;
}
\end{cppcode}

Ожидаемый результат: 200 000. Реальный результат: случайное число, например, 142 583. Или 200 000 (если повезет).

\subsection{Анатомия гонки}

Операция инкремента \texttt{counter++} не является атомарной. На уровне процессора (x86) она раскладывается на три этапа (Read-Modify-Write):
\begin{enumerate}
    \item \texttt{MOV EAX, [addr]} — Загрузить значение из памяти в регистр.
    \item \texttt{INC EAX} — Увеличить значение в регистре.
    \item \texttt{MOV [addr], EAX} — Записать значение обратно в память.
\end{enumerate}

Если два потока выполняют эти инструкции одновременно, происходит следующее:
\begin{enumerate}
    \item Поток 1 читает 0 в свой регистр.
    \item Поток 2 читает 0 в свой регистр (так как Поток 1 еще не записал результат).
    \item Поток 1 увеличивает 0 до 1 и пишет 1 в память.
    \item Поток 2 увеличивает 0 до 1 и пишет 1 в память.
\end{enumerate}
Два инкремента превратились в один. Потеря данных произошла.

\subsection{Почему это Undefined Behavior?}

Может показаться, что проблема только в "потере" инкрементов. Но стандарт C++ объявляет это UB, что дает компилятору право на агрессивные оптимизации.

Компилятор видит, что переменная \texttt{counter} не является атомарной. Согласно модели памяти C++ (которая подразумевает single-threaded execution, если нет явной синхронизации), он может предположить, что переменную никто другой не меняет. Он может загрузить \texttt{counter} в регистр в начале цикла, прибавить к нему 100 000, и записать обратно только в самом конце. Или вообще выкинуть промежуточные записи.

В многопоточной среде такие оптимизации ломают логику программы полностью. Именно поэтому использование обычных переменных (\texttt{int}, \texttt{bool}) для синхронизации без мьютексов или атомиков — это всегда ошибка.

\section{ThreadSanitizer (TSan)}

Поиск гонок данных вручную крайне сложен, так как они проявляются недетерминировано. Ошибка может не воспроизводиться на машине разработчика, но "стрелять" в продакшене под нагрузкой.

Для автоматического детектирования используется инструмент \textbf{ThreadSanitizer (TSan)}. Это модуль для компиляторов Clang и GCC.

Для использования нужно скомпилировать код с флагом:
\texttt{-fsanitize=thread -g}

TSan инструментирует код, отслеживая все обращения к памяти во время исполнения. Если он видит два обращения к одному адресу из разных потоков, одно из которых — запись, и между ними не было "happens-before" связи (захвата мьютекса, join потока), он выдает подробный отчет об ошибке.

\begin{important}
TSan замедляет выполнение программы в 5-15 раз и потребляет много памяти. Используйте его на этапах тестирования и в CI, но не в релизной сборке для клиентов.
\end{important}

\section{Ловушка std::vector<bool>}

Существует особый случай гонки данных, который неочевиден для многих разработчиков. Это использование \texttt{std::vector<bool>} в многопоточной среде.

\begin{cppcode}
std::vector<bool> flags(16, false);

// Поток 1
std::thread t1([&]{ 
    flags[0] = true; 
});

// Поток 2
std::thread t2([&]{ 
    flags[1] = true; 
});
\end{cppcode}

Казалось бы, потоки обращаются к \textbf{разным} элементам вектора (индексы 0 и 1). Логически пересечения нет. Однако, согласно спецификации, \texttt{std::vector<bool>} — это псевдо-контейнер, который специализируется для экономии памяти. Он упаковывает 8 булевых значений в один байт.

\begin{itemize}
    \item Процессор не умеет адресовать отдельные биты. Минимальная адресуемая единица — байт.
    \item Чтобы записать \texttt{true} в 0-й бит, процессор должен: прочитать весь байт, наложить битовую маску (OR), записать байт обратно.
    \item Поток 1 читает байт, меняет 0-й бит.
    \item Поток 2 одновременно читает \textbf{тот же самый байт}, меняет 1-й бит.
\end{itemize}

В результате возникает классический Data Race на уровне байта. Изменения одного из потоков могут быть потеряны, или байт превратится в мусор.

\begin{summary}
\begin{itemize}
    \item \textbf{Race Condition} — ошибка логики (порядок действий), \textbf{Data Race} — ошибка доступа к памяти (UB).
    \item Любая запись в общую память без синхронизации — потенциальный Data Race.
    \item Используйте \textbf{ThreadSanitizer} для поиска гонок.
    \item Остерегайтесь \texttt{std::vector<bool>}: разные индексы не гарантируют безопасность потоков, так как они могут делить один байт памяти.
\end{itemize}
\end{summary}
