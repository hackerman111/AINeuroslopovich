\chapter{Практикум: Управление памятью и Smart Pointers в многопоточности}

Мы завершаем наш цикл, объединяя знания о многопоточности с фундаментальной темой C++ — управлением памятью. Умные указатели (smart pointers) стали стандартом де-факто для владения ресурсами, но их поведение в многопоточной среде часто понимается превратно. Является ли \texttt{std::shared\_ptr} потокобезопасным? Ответ "да, но..." требует детального разбора.

Кроме того, мы рассмотрим реальный кейс из разработки интерпретаторов (на примере учебного Scheme) — реализацию сборщика мусора (Garbage Collector) по алгоритму Mark and Sweep, где вопросы достижимости объектов и управления графом становятся критическими.

\section{Потокобезопасность std::shared\_ptr}

Вопрос "потокобезопасен ли shared\_ptr?" — один из самых популярных на собеседованиях. Правильный ответ состоит из двух частей, так как \texttt{std::shared\_ptr} управляет двумя сущностями:
\begin{enumerate}
    \item \textbf{Control Block (Управляющий блок):} Хранит счетчик ссылок (\texttt{ref\_count}) и счетчик слабых ссылок (\texttt{weak\_count}).
    \item \textbf{Managed Object (Управляемый объект):} Тот самый \texttt{T*}, на который указывает умный указатель.
\end{enumerate}

\subsection{Гарантии стандарта}

Стандарт C++ дает следующие гарантии:

\begin{itemize}
    \item \textbf{Счетчик ссылок — потокобезопасен.} Операции инкремента (копирование \texttt{shared\_ptr}) и декремента (уничтожение) являются атомарными. Вы можете безопасно копировать \texttt{shared\_ptr}, указывающий на один объект, в разных потоках. Гонки данных на счетчике не будет.
    \item \textbf{Управляемый объект — НЕ потокобезопасен.} Если два потока имеют доступ к одному объекту через разные копии \texttt{shared\_ptr}, и один из них пишет в объект — нужна внешняя синхронизация (мьютекс).
    \item \textbf{Сам экземпляр shared\_ptr — НЕ потокобезопасен.} Если два потока пытаются изменить \textbf{один и тот же экземпляр} \texttt{shared\_ptr} (например, глобальный указатель, присваивая ему новое значение), это гонка данных.
\end{itemize}

\begin{cppcode}
std::shared_ptr<int> global_ptr = std::make_shared<int>(42);

void thread1() {
    // Безопасно: создается локальная копия. 
    // Счетчик атомарно увеличивается.
    std::shared_ptr<int> local = global_ptr; 
    
    // Опасно! Чтение объекта без мьютекса (если кто-то пишет в *local)
    std::cout << *local; 
}

void thread2() {
    // ОПАСНО! Гонка данных на самом global_ptr.
    // Присваивание изменяет внутренности глобального объекта (ptr и control block).
    // thread1 может прочитать "разорванное" значение.
    global_ptr = std::make_shared<int>(100); 
}
\end{cppcode}

Для безопасной модификации самого экземпляра \texttt{shared\_ptr} в C++20 введены \texttt{std::atomic<std::shared\_ptr<T>>}. До C++20 приходилось использовать внешние функции \texttt{std::atomic\_store(\&ptr, ...)}, что было неудобно и опасно.

\section{Thread Local Storage (TLS)}

Иногда нам вообще не нужно делить данные между потоками. Напротив, нам нужно, чтобы у каждого потока была своя, уникальная копия переменной. Для этого используется спецификатор \texttt{thread\_local}.

\begin{cppcode}[]
#include <random>

// Глобальный генератор случайных чисел? Плохая идея (мьютекс убьет скорость).
// thread_local создает генератор для каждого потока отдельно.
int get_random() {
    thread_local std::mt19937 gen(std::clock());
    std::uniform_int_distribution<int> dist(0, 100);
    return dist(gen);
}
\end{cppcode}

Переменные \texttt{thread\_local}:
\begin{itemize}
    \item Инициализируются при первом обращении к ним в потоке (lazy initialization).
    \item Уничтожаются при завершении потока.
    \item Живут в специальной области памяти (TLS segment), доступ к которой обычно осуществляется через регистр сегмента (например, \texttt{fs} на x86\_64), что очень быстро.
\end{itemize}

Это идеальное решение для кэшей, буферов (например, строковых билдеров) и генераторов случайных чисел в многопоточных сервисах.

\section{Case Study: Сборщик мусора (Mark and Sweep)}

В курсе мы разрабатываем интерпретатор Scheme. Языки Lisp-семейства славятся тем, что в них легко создаются циклические структуры данных (списки, ссылающиеся сами на себя, замыкания).

\subsection{Почему shared\_ptr не подходит?}

Если использовать \texttt{std::shared\_ptr} для узлов графа объектов Scheme, мы столкнемся с проблемой циклических ссылок.
Объект A ссылается на B, B ссылается на A. Их \texttt{ref\_count} никогда не станет нулем, даже если они оба недостижимы из остальной программы. Это классическая утечка памяти.

Решение — реализовать собственный Garbage Collector (GC). Самый простой и надежный алгоритм — \textbf{Mark and Sweep} (Пометь и Удали).

\subsection{Алгоритм}

Идея алгоритма базируется на понятии \textbf{достижимости} (reachability). Объект "жив", если до него можно добраться по ссылкам от "корней" (Roots).

\begin{enumerate}
    \item \textbf{Root Set (Корневое множество):} Это объекты, которые гарантированно живы. В нашем случае это Глобальный Скоуп (Global Scope) интерпретатора и, возможно, временные переменные на стеке вычислений.
    \item \textbf{Фаза Mark (Пометка):}
    Мы запускаем обход графа (DFS/BFS) от корней. Каждый посещенный объект помечается флагом \texttt{is\_marked = true}. Если мы встречаем уже помеченный объект, останавливаемся (защита от зацикливания).
    \item \textbf{Фаза Sweep (Удаление):}
    Мы проходим по \textbf{всем} выделенным объектам в куче (нам нужен список всех аллокаций).
    \begin{itemize}
        \item Если у объекта \texttt{is\_marked == true}, мы сбрасываем флаг в \texttt{false} (готовим к следующему циклу) и оставляем его жить.
        \item Если у объекта \texttt{is\_marked == false}, значит он недостижим (мусор). Мы вызываем \texttt{delete} и удаляем его из списка аллокаций.
    \end{itemize}
\end{enumerate}

\begin{cppcode}
// Упрощенная модель объекта
struct Object {
    bool is_marked = false;
    std::vector<Object*> children; // Ссылки на другие объекты
    virtual ~Object() = default;
};

void mark(Object* obj) {
    if (!obj || obj->is_marked) return;
    
    obj->is_marked = true;
    for (auto* child : obj->children) {
        mark(child);
    }
}

void sweep(std::vector<Object*>& all_objects) {
    auto it = all_objects.begin();
    while (it != all_objects.end()) {
        if ((*it)->is_marked) {
            (*it)->is_marked = false; // Сброс для следующего раза
            ++it;
        } else {
            delete *it; // Удаление мусора
            // Удаление из списка всех объектов (swap-and-pop для вектора)
            *it = all_objects.back();
            all_objects.pop_back(); 
            // Итератор не инкрементируем, проверяем новый элемент на этом месте
        }
    }
}
\end{cppcode}

Этот подход решает проблему циклов: если группа объектов замкнута сама на себя, но недостижима от Global Scope, алгоритм \texttt{mark} до них не дойдет, их флаги останутся \texttt{false}, и \texttt{sweep} их удалит.

\subsection{Инструментарий: Leak Sanitizer}

Для проверки корректности работы GC в задачах мы используем \textbf{Leak Sanitizer} (LSan). Это часть набора санитайзеров (как и TSan/ASan). Он запускается в конце работы программы и проверяет, остались ли в куче аллокации, которые не были освобождены.

Если ваш GC работает корректно, на выходе LSan молчит. Если вы забыли удалить циклические ссылки, LSan выдаст отчет об утечке, показав стек вызовов, где была выделена память.

\begin{summary}
\begin{itemize}
    \item \texttt{std::shared\_ptr} гарантирует атомарность счетчика, но не безопасность данных внутри.
    \item Модификация одного экземпляра \texttt{shared\_ptr} из разных потоков — гонка данных.
    \item \texttt{thread\_local} позволяет создавать уникальные копии данных для потоков без мьютексов.
    \item Для сложных структур с циклами (графы, интерпретаторы) \texttt{shared\_ptr} недостаточен. Требуется полноценный Garbage Collection (Mark and Sweep).
\end{itemize}
\end{summary}
