\chapter{Управление потоками в C++: API и стоимость абстракций}

Понимание аппаратной части многопоточности, рассмотренное в предыдущей главе, позволяет нам перейти к программным абстракциям. Стандарт C++11 ввел в язык нативную поддержку потоков, предоставив класс \texttt{std::thread} как обертку над системными вызовами (pthreads в Linux, WinAPI Threads в Windows). В этой главе мы разберем не только синтаксис, но и цену, которую приходится платить за создание потоков, а также распространенные архитектурные ошибки, приводящие к деградации производительности.

\section{Базовый API: std::thread}

Класс \texttt{std::thread} (заголовочный файл \texttt{<thread>}) представляет собой объект, владеющий системным потоком исполнения. Конструктор \texttt{std::thread} принимает функцию (или любой Callable объект), которую поток начнет выполнять сразу после создания.

\subsection{Запуск и передача аргументов}

При создании потока аргументы передаются в конструктор. Здесь действует семантика, схожая с \texttt{std::bind}: аргументы копируются во внутреннее хранилище потока (обычно в кучу или стек нового потока).

\begin{cppcode}[]
#include <thread>
#include <iostream>
#include <string>

void worker(int id, const std::string& data) {
    // std::this_thread::get_id() возвращает уникальный идентификатор
    std::cout << "Thread " << id 
              << " (" << std::this_thread::get_id() << ") processing: " 
              << data << std::endl;
}

int main() {
    int id = 1;
    std::string message = "Hello";

    // message будет скопирован!
    std::thread t1(worker, id, message);

    // Если нужно передать ссылку, используем std::ref / std::cref
    std::thread t2(worker, 2, std::cref(message)); 

    t1.join();
    t2.join();
    return 0;
}
\end{cppcode}

\begin{important}
По умолчанию аргументы копируются. Если передаваемый объект тяжелый или не копируемый (например, \texttt{std::unique\_ptr}), его необходимо перемещать с помощью \texttt{std::move}, а если функция ожидает ссылку — явно оборачивать в \texttt{std::ref}.
\end{important}

\section{Проблема времени жизни: join() и detach()}

После запуска потока основной поток (родитель) обязан определить судьбу дочернего потока до того, как объект \texttt{std::thread} будет уничтожен (выдет из области видимости).

\begin{itemize}
    \item \textbf{join()}: Родитель блокируется и ждет завершения дочернего потока. Это точка синхронизации. После возврата из \texttt{join()} поток считается завершенным, а ресурсы ОС очищенными.
    \item \textbf{detach()}: Поток "отпускается" в свободное плавание. Связь с объектом \texttt{std::thread} разрывается. Поток продолжит работать в фоне, пока не завершится сам или пока не завершится программа.
\end{itemize}

\subsection{Ловушка деструктора std::thread}

Одним из самых спорных решений в дизайне C++11 является поведение деструктора \texttt{std::thread}. Если на момент вызова деструктора поток все еще "присоединен" (joinable) — то есть для него не был вызван ни \texttt{join()}, ни \texttt{detach()} — программа аварийно завершается.

\begin{cppcode}
void dangerous_code() {
    std::thread t([]{ 
        std::this_thread::sleep_for(std::chrono::seconds(1)); 
    });
    
    // Забыли t.join()!
    // При выходе из функции вызывается ~thread().
    // Так как t.joinable() == true, вызывается std::terminate().
} 
\end{cppcode}

Это сделано намеренно. Если бы деструктор делал неявный \texttt{join()}, это могло бы привести к неочевидным зависаниям программы (деструктор ждет вечно). Если бы он делал \texttt{detach()}, поток продолжил бы обращаться к локальным переменным уже уничтоженного стека родительской функции, что привело бы к UB. Комитет стандартизации выбрал "fail fast" — немедленное падение, сигнализирующее об ошибке в логике.

\section{RAII для потоков: std::jthread}

В стандарте C++20 был добавлен класс \texttt{std::jthread} (joining thread), который исправляет неудобство обычного \texttt{std::thread}. Он реализует идиому RAII: в своем деструкторе он автоматически вызывает \texttt{join()} (если поток еще работает), либо ничего не делает (если поток уже завершен).

\begin{cppcode}[]
#include <thread>

void safe_code() {
    // std::jthread автоматически присоединится при выходе из scope
    std::jthread t([]{ 
        // ... работа ...
    });
} // Здесь будет вызван t.join()
\end{cppcode}

Кроме того, \texttt{std::jthread} поддерживает механизм токенов отмены (\texttt{std::stop\_token}), позволяя вежливо попросить поток завершиться, но это тема отдельного разговора.

\section{Стоимость создания потока}

Частой ошибкой новичков является отношение к потокам как к "легковесным" сущностям (по аналогии с горутинами в Go или файберами). В C++ поток \texttt{std::thread} обычно отображается 1:1 на поток операционной системы (kernel thread).

Создание потока — дорогая операция. Рассмотрим, что происходит "под капотом" в Linux (системный вызов \texttt{clone}):

\begin{enumerate}
    \item \textbf{Аллокация стека:} По умолчанию размер стека составляет около 2-8 МБ (зависит от \texttt{ulimit -s}). Даже если физическая память выделяется лениво (по мере обращения к страницам), это все равно нагрузка на менеджер виртуальной памяти (VMA).
    \item \textbf{Структуры ядра:} Создается запись в таблице процессов (\texttt{task\_struct}), выделяются дескрипторы.
    \item \textbf{Планировщик:} Новый поток нужно добавить в очередь планировщика.
\end{enumerate}

Время создания потока на современном железе измеряется \textbf{десятками микросекунд} (на порядок больше, чем просто вызов функции).

\subsection{Бенчмарк: Создание потоков в цикле}

Рассмотрим пример неэффективного кода, который создает новый поток для каждой микро-задачи (вычисление корня).

\begin{cppcode}
// Плохой паттерн: создание потока на каждую итерацию
void SlowSum() {
    double sum = 0;
    for (int i = 0; i < 100000; ++i) {
        std::thread t([i, &sum] { 
            sum += std::sqrt(i); 
        });
        t.join(); // Ждем завершения сразу же
    }
}
\end{cppcode}

Запуск такого кода через профилировщик (\texttt{perf} или \texttt{strace -T}) покажет, что программа проводит больше времени в системных вызовах \texttt{clone} и \texttt{mmap} (выделение памяти под стек), чем в полезных вычислениях.

\begin{important}
Если ваша задача выполняется быстрее, чем время создания потока (10-50 мкс), распараллеливание через создание новых потоков \textbf{замедлит} программу.
\end{important}

\section{Проблема Oversubscription}

Другая крайность — запуск слишком большого количества потоков одновременно. Если количество активных (выполняющих работу) потоков значительно превышает количество физических ядер (\texttt{std::thread::hardware\_concurrency()}), возникает явление \textbf{Oversubscription}.

Операционная система вынуждена часто переключать контекст между потоками, чтобы дать каждому квант времени. Как мы обсуждали в Главе 1, переключение контекста портит кэши. В предельном случае (Context Switch Storm) процессор тратит почти все время на переключение задач, а не на их выполнение.

\section{Ловушка std::async}

В C++11 была предпринята попытка сделать высокоуровневую абстракцию для асинхронных вычислений — \texttt{std::async}. Она возвращает объект \texttt{std::future}, через который можно получить результат.

Однако реализации стандартной библиотеки (в частности, libstdc++ в GCC и Clang) часто реализуют политику запуска \texttt{std::launch::async} самым примитивным способом: \textbf{всегда создается новый поток}.

\begin{cppcode}
// Опасно: может положить систему
std::vector<std::future<double>> futures;
for (int i = 0; i < 100000; ++i) {
    // Каждая итерация порождает новый поток ОС!
    futures.push_back(std::async(std::launch::async, [i]{ 
        return std::sqrt(i); 
    }));
}
\end{cppcode}

Этот код может привести к исчерпанию ресурсов (ошибка \texttt{std::system\_error} или \texttt{Resource temporarily unavailable}), так как он попытается создать 100 000 потоков одновременно. В MSVC есть внутренний глобальный тред-пул, но полагаться на это в кроссплатформенном коде нельзя.

\section{Решение: Thread Pool}

Чтобы избежать накладных расходов на создание потоков и проблем с oversubscription, в промышленном коде используется паттерн \textbf{Thread Pool} (Пул потоков).

Идея проста:
\begin{enumerate}
    \item При старте программы создается фиксированное количество потоков (обычно равное числу ядер).
    \item Потоки крутятся в бесконечном цикле, ожидая задачи из потокобезопасной очереди.
    \item Основной поток не создает новые потоки, а кладет задачи (функции/лямбды) в эту очередь.
\end{enumerate}

Это позволяет платить цену за создание потоков только один раз — при инициализации. Мы разберем реализацию очереди и пула в следующих главах, когда изучим примитивы синхронизации.

\begin{summary}
\begin{itemize}
    \item Используйте \texttt{std::jthread} (C++20) или убедитесь, что всегда вызываете \texttt{join()} для \texttt{std::thread}.
    \item Создание потока — тяжелая операция (аллокация стека, syscall). Не создавайте потоки в горячих циклах.
    \item Избегайте \texttt{std::async} с политикой \texttt{launch::async} в циклах, так как это неявное создание потоков.
    \item Оптимальное число рабочих потоков для вычислений равно числу ядер процессора.
\end{itemize}
\end{summary}
