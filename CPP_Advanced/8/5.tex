\chapter{Атомики и низкоуровневая синхронизация}

Мьютексы, рассмотренные нами ранее, являются механизмами синхронизации уровня операционной системы. Когда поток не может захватить мьютекс, он "усыпляется" ядром ОС, что влечет за собой накладные расходы на системные вызовы и переключение контекста. Однако для простейших операций, таких как инкремент счетчика или установка флага, эти расходы могут быть неприемлемо высоки.

В этой главе мы спустимся на уровень ниже — к атомарным операциям и инструкциям процессора. Мы разберем, как работает \texttt{std::atomic}, развеем опасный миф о \texttt{volatile} и напишем собственный примитив синхронизации — спинлок (Spinlock).

\section{Миф о volatile}

Прежде чем переходить к правильным инструментам, необходимо разобрать одну из самых живучих ошибок в C++ программировании. Многие разработчики, пришедшие из мира микроконтроллеров или старых версий Java, ошибочно полагают, что ключевое слово \texttt{volatile} обеспечивает потокобезопасность.

\begin{important}
\textbf{volatile в C++ не имеет отношения к многопоточности!}
Оно не гарантирует атомарность. Оно не создает барьеров памяти. Оно не предотвращает гонки данных.
\end{important}

Ключевое слово \texttt{volatile} сообщает компилятору лишь одно: "значение этой переменной может измениться извне, поэтому не кэшируй его в регистрах". Это необходимо для работы с \textbf{MMIO} (Memory-Mapped I/O) — когда адрес в памяти на самом деле является портом ввода-вывода устройства (например, датчика температуры).

Рассмотрим пример Data Race с использованием \texttt{volatile}:

\begin{cppcode}
volatile int counter = 0;

void increment() {
    // ОШИБКА: Это все еще Read-Modify-Write операция.
    // volatile лишь заставит процессор каждый раз читать из памяти,
    // но не запрещает другому потоку вклиниться между чтением и записью.
    counter++; 
}
\end{cppcode}

Если запустить этот код в несколько потоков, результат будет неверным. Единственное применение \texttt{volatile} в современном C++ — это взаимодействие с железом или обработчиками сигналов UNIX. Для потоков используйте \texttt{std::atomic}.

\section{std::atomic}

Шаблон \texttt{std::atomic<T>} (заголовок \texttt{<atomic>}) предоставляет интерфейс для работы с данными, операции над которыми гарантированно выполняются атомарно.

\subsection{Базовые операции: load и store}

Атомики запрещают компилятору и процессору переупорядочивать инструкции (reordering) опасным образом и гарантируют, что чтение или запись переменной произойдет целиком.

\begin{cppcode}
std::atomic<int> flag = 0;

void writer() {
    flag.store(1); // Атомарная запись
}

void reader() {
    // Атомарное чтение. Гарантируется, что мы не прочитаем 
    // "частично записанное" значение (torn read).
    int val = flag.load(); 
}
\end{cppcode}

\subsection{Read-Modify-Write (RMW)}

Самая мощная возможность атомиков — это операции, которые читают, изменяют и записывают значение как единое неделимое действие.

\begin{itemize}
    \item \texttt{fetch\_add(val)}: прибавляет значение, возвращает \textit{старое}.
    \item \texttt{fetch\_sub(val)}: вычитает значение.
    \item \texttt{exchange(val)}: записывает новое значение, возвращает \textit{старое}.
\end{itemize}

\begin{cppcode}
std::atomic<int> counter = 0;

void worker() {
    // Эквивалентно fetch_add(1). 
    // На x86 компилируется в инструкцию LOCK XADD.
    counter++; 
}
\end{cppcode}

Важно понимать разницу между атомарностью самой переменной и последовательности действий.

\begin{note}
\texttt{atomic\_val = atomic\_val + 1} — \textbf{НЕ} атомарно!
Это последовательность: (1) атомарное чтение, (2) локальное сложение, (3) атомарная запись. Между (1) и (3) может вклиниться другой поток.
Для атомарного инкремента используйте только \texttt{fetch\_add} или оператор \texttt{++}.
\end{note}

\section{Compare-And-Swap (CAS)}

Фундаментом всех lock-free структур данных (очередей, списков без мьютексов) является операция Compare-And-Swap. В C++ она представлена методами \texttt{compare\_exchange\_strong} и \texttt{compare\_exchange\_weak}.

Логика CAS следующая: "Проверь, равно ли текущее значение \texttt{expected}. Если да, запиши \texttt{desired} и верни true. Если нет, обнови \texttt{expected} текущим значением и верни false".

\begin{cppcode}
std::atomic<int> current_head;

void push(int new_val) {
    int old_head = current_head.load();
    // Пытаемся обновить head, только если он не изменился с момента чтения.
    // Если изменился (кто-то другой успел запушить), повторяем цикл.
    while (!current_head.compare_exchange_weak(old_head, new_val)) {
        // Тело цикла может быть пустым, old_head обновляется автоматически внутри CAS
    }
}
\end{cppcode}

\begin{itemize}
    \item \textbf{weak}: Может вернуть \texttt{false}, даже если значение равно ожидаемому (spurious failure). Это особенность архитектур типа ARM и PowerPC. Используется в циклах.
    \item \textbf{strong}: Гарантирует успех, если значения равны. Используется, когда цикл неудобен, но стоит дороже на некоторых платформах.
\end{itemize}

\section{Реализация Spinlock}

Используя атомик, мы можем реализовать собственный примитив синхронизации — спинлок. В отличие от мьютекса, спинлок не усыпляет поток, а заставляет его крутиться в цикле ("spin"), ожидая освобождения флага.

Для реализации идеально подходит \texttt{std::atomic\_flag}. Это единственный тип, для которого стандарт гарантирует lock-free реализацию на любой платформе.

\begin{cppcode}[]
#include <atomic>
#include <thread>

class Spinlock {
    // ATOMIC_FLAG_INIT устарело в C++20, конструктор по умолчанию ставит в false (clear)
    std::atomic_flag flag; 

public:
    void lock() {
        // test_and_set атомарно ставит флаг в true и возвращает ПРЕДЫДУЩЕЕ значение.
        // Если вернулось true -> значит флаг уже был занят -> продолжаем крутиться.
        // Если вернулось false -> мы успешно захватили спинлок.
        while (flag.test_and_set(std::memory_order_acquire)) {
            // Hint для процессора, что мы в цикле ожидания (снижает энергопотребление)
            // В C++20: std::atomic::wait
             #if defined(__x86_64__) || defined(_M_X64)
                 _mm_pause(); 
             #endif
        }
    }

    void unlock() {
        flag.clear(std::memory_order_release);
    }
};
\end{cppcode}

\section{Spinlock vs Mutex: Цена решения}

Когда стоит использовать спинлок, а когда мьютекс?

\textbf{Spinlock:}
\begin{itemize}
    \item \textbf{Плюсы:} Не требует системных вызовов. Захват происходит за десятки наносекунд (если свободен). Не сбрасывает кэш процессора (нет переключения контекста).
    \item \textbf{Минусы:} Если спинлок занят долго, ожидающий поток сжигает 100\% процессорного времени впустую (busy-wait).
    \item \textbf{Применение:} Критические секции длиной в несколько инструкций (например, инкремент счетчика или перестановка указателя).
\end{itemize}

\textbf{Mutex:}
\begin{itemize}
    \item \textbf{Плюсы:} Если ресурс занят, поток уступает ядро другим задачам. Экономит энергию.
    \item \textbf{Минусы:} Захват/освобождение требуют обращения к ядру ОС, что долго.
    \item \textbf{Применение:} Длительные операции (ввод-вывод, сложная логика).
\end{itemize}

\begin{important}
Линус Торвальдс и многие эксперты считают, что использование спинлоков в userspace (пользовательском пространстве) вредно. Причина — \textbf{Priority Inversion} и планировщик ОС. Если поток, захвативший спинлок, будет вытеснен планировщиком (кончился квант времени), все остальные потоки будут крутиться впустую целый квант, ожидая его возвращения. Современные реализации \texttt{std::mutex} (futex в Linux) гибридны: они немного "крутятся" в userspace перед тем, как уйти в сон.
\end{important}

\section{Модель памяти (Memory Ordering)}

В примерах выше мы видели странные аргументы \texttt{std::memory\_order\_acquire/release}. Это управление моделью памяти.
По умолчанию C++ использует \textbf{Sequential Consistency} (\texttt{seq\_cst}). Это самая строгая модель: она гарантирует, что все потоки видят все изменения в одном и том же глобальном порядке. Это безопасно, но может быть медленно, так как требует блокировки шины или сброса буферов записи процессора.

Более слабые модели (\texttt{acquire}, \texttt{release}, \texttt{relaxed}) позволяют процессору переупорядочивать инструкции ради производительности, сохраняя лишь необходимые гарантии видимости. Программирование с weak ordering — это высший пилотаж C++, где любая ошибка приводит к неуловимым багам. До тех пор, пока профайлер не покажет, что узкое место именно в синхронизации кэшей, используйте дефолтный \texttt{seq\_cst}.

\begin{summary}
\begin{itemize}
    \item \textbf{volatile} не для потоков. Никогда не используйте его для синхронизации.
    \item \textbf{std::atomic} — единственный корректный способ работы с общими простыми типами без мьютексов.
    \item \textbf{RMW операции} (\texttt{fetch\_add}, \texttt{exchange}) позволяют менять данные безопасно.
    \item \textbf{Spinlock} эффективен для сверхкоротких блокировок, но опасен в общем случае из-за сжигания CPU.
    \item \textbf{CAS (Compare-And-Swap)} — основа lock-free алгоритмов.
\end{itemize}
\end{summary}
