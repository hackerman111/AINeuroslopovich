\chapter{Оптимизация под железо: False Sharing}

В предыдущих главах мы добились логической корректности многопоточных программ, используя мьютексы и атомики. Мы устранили гонки данных (Data Race) и неопределенное поведение. Однако в высокопроизводительных системах логической корректности недостаточно.

Существует класс проблем, при которых программа работает абсолютно правильно, не имеет блокировок (lock-free), использует все ядра процессора на 100\%, но при этом выполняется в десятки раз медленнее, чем однопоточная версия. Причина кроется в физической организации подсистемы памяти, а именно в явлении, называемом \textbf{False Sharing} (Ложное разделение).

\section{Физика кэш-линий}

Процессор никогда не читает из оперативной памяти (RAM) отдельные байты. Это было бы крайне неэффективно с точки зрения пропускной способности шины. Обмен данными между оперативной памятью и кэшами процессора (L1/L2/L3) происходит блоками фиксированного размера, которые называются \textbf{кэш-линиями} (Cache Lines).

\begin{note}
На большинстве современных архитектур (x86\_64, многие ARM) размер кэш-линии составляет \textbf{64 байта}.
\end{note}

Это означает, что если вы читаете переменную типа \texttt{int} (4 байта) по адресу \texttt{0x1000}, процессор загрузит в кэш весь блок от \texttt{0x1000} до \texttt{0x103F}. Вместе с нужной вам переменной в кэш попадут и соседние данные ("хвост" длиной 60 байт).

\subsection{Протоколы когерентности (MESI)}

В многоядерных системах каждый процессор (ядро) имеет свой собственный L1 и L2 кэш. Если два ядра закэшировали одну и ту же область памяти, возникает проблема синхронизации (когерентности). Если одно ядро изменит данные у себя в L1, другое ядро должно узнать об этом, иначе оно будет работать с устаревшим значением.

Для решения этой задачи существуют аппаратные протоколы когерентности, такие как \textbf{MESI} (Modified, Exclusive, Shared, Invalid). Упрощенно логика выглядит так:
\begin{enumerate}
    \item Чтобы ядро могло записать данные в кэш-линию, оно должно получить её в эксклюзивное владение (состояние \textit{Exclusive} или \textit{Modified}).
    \item Если эта линия находится в кэшах других ядер (состояние \textit{Shared}), то перед записью инициатор посылает сигнал инвалидации (\textit{Invalidate}).
    \item Другие ядра помечают свои копии линии как невалидные (\textit{Invalid}) и выбрасывают их.
    \item При следующей попытке чтения эти ядра вынуждены заново загружать линию из памяти (или из кэша пишущего ядра), что очень дорого.
\end{enumerate}

\section{Феномен False Sharing}

Ложное разделение возникает, когда два или более потока одновременно модифицируют \textbf{логически разные} переменные, которые случайно оказались на \textbf{одном и том же} физическом носителе — в одной кэш-линии.

\subsection{Сценарий "Пинг-понг"}

Представим структуру, содержащую два атомарных счетчика:

\begin{cppcode}
struct SharedData {
    std::atomic<int> a; // 4 байта
    std::atomic<int> b; // 4 байта
}; 
// sizeof(SharedData) == 8 байт. Оба поля лежат в одной кэш-линии.
\end{cppcode}

Пусть Поток 1 (Ядро 0) инкрементирует \texttt{a}, а Поток 2 (Ядро 1) инкрементирует \texttt{b}.

\begin{enumerate}
    \item \textbf{Ядро 0} хочет записать в \texttt{a}. Оно запрашивает линию эксклюзивно.
    \item \textbf{Ядро 1} вынуждено сбросить свою копию линии (Invalidate), даже если оно работало только с \texttt{b}.
    \item Ядро 0 меняет \texttt{a}. Линия в состоянии Modified на Ядре 0.
    \item \textbf{Ядро 1} хочет записать в \texttt{b}. Промах кэша (L1 Miss). Оно запрашивает линию у Ядра 0.
    \item Ядро 0 сбрасывает свои изменения в общий кэш/память (Write Back) и отдает владение. Линия на Ядре 0 становится Invalid.
    \item Ядро 1 меняет \texttt{b}.
\end{enumerate}

Происходит "пинг-понг" кэш-линии между ядрами. Вместо того чтобы работать на скорости L1 кэша (1 нс), ядра ждут синхронизации через шину (десятки нс). Производительность может упасть в 10-50 раз по сравнению с теоретическим максимумом.

Термин "ложное" (False) означает, что разделения данных на логическом уровне нет (потоки не трогают данные друг друга), но процессор этого не знает — он видит разделение на уровне 64-байтного блока.

\section{Демонстрация и диагностика}

Рассмотрим пример кода, демонстрирующий этот эффект. Мы запустим несколько потоков, каждый из которых инкрементирует свой собственный счетчик в массиве.

\begin{cppcode}[]
#include <thread>
#include <vector>
#include <atomic>
#include <new> // для hardware_destructive_interference_size

// Плохая структура: данные упакованы плотно
struct PackedCounter {
    std::atomic<long> value{0};
};

// Хорошая структура: принудительное выравнивание
struct AlignedCounter {
    alignas(64) std::atomic<long> value{0};
};

template <typename CounterType>
void benchmark() {
    std::vector<CounterType> counters(4); 
    std::vector<std::thread> threads;
    
    // Каждый поток работает строго со своим индексом!
    // Логического пересечения нет.
    for (int i = 0; i < 4; ++i) {
        threads.emplace_back([&counters, i] {
            for (int j = 0; j < 100'000'000; ++j) {
                counters[i].value.fetch_add(1, std::memory_order_relaxed);
            }
        });
    }
    
    for (auto& t : threads) t.join();
}
\end{cppcode}

\subsection{Анализ памяти}

В случае \texttt{PackedCounter}: \texttt{sizeof(atomic<long>)} равен 8 байтам. Четыре счетчика займут 32 байта. Они гарантированно поместятся в одну 64-байтную кэш-линию. Четыре ядра будут драться за право владения этой единственной линией.

В случае \texttt{AlignedCounter}: спецификатор \texttt{alignas(64)} заставляет компилятор размещать каждый объект по адресу, кратному 64. Размер структуры станет 64 байта (8 байт полезных данных + 56 байт padding). Каждый счетчик гарантированно окажется в своей уникальной кэш-линии.

\begin{important}
Профилирование такого кода (например, через \texttt{perf c2c} в Linux) покажет огромное количество событий \textbf{Hitm} (Hit Modified) — ситуаций, когда ядро запрашивает данные, которые были модифицированы в кэше другого ядра.
\end{important}

\section{Решение: Padding и alignas}

Единственный способ борьбы с False Sharing — разнести часто изменяемые данные (hot spots) по разным кэш-линиям. Это делается путем добавления "мусорных" данных (padding) между полезными переменными.

В старом C++ это делалось вручную добавлением массивов \texttt{char pad[64]}. В современном C++ (с C++11) используется спецификатор выравнивания \texttt{alignas}.

\begin{cppcode}
// Гарантируем, что атомики не попадут в одну линию
struct SafeMetrics {
    alignas(64) std::atomic<int> success_count;
    alignas(64) std::atomic<int> error_count;
};
\end{cppcode}

Это увеличивает потребление оперативной памяти (trade-off: память в обмен на скорость процессора), но в контексте глобальных счетчиков или структур синхронизации это ничтожная плата за многократный прирост производительности.

\section{Проблема переносимости и ABI}

Возникает вопрос: почему мы пишем \texttt{alignas(64)}? Откуда взялось число 64?

Хотя 64 байта — стандарт де-факто для x86\_64 (Intel/AMD), другие архитектуры могут иметь другие размеры линии (например, 128 байт на некоторых PowerPC или Apple Silicon). Если мы скомпилируем код с \texttt{alignas(64)} для процессора с линией 128 байт, False Sharing вернется, так как два 64-байтных блока попадут в одну 128-байтную линию.

В C++17 в заголовок \texttt{<new>} были добавлены константы:
\begin{itemize}
    \item \texttt{std::hardware\_destructive\_interference\_size}: минимальный отступ, гарантирующий отсутствие False Sharing (размер кэш-линии).
    \item \texttt{std::hardware\_constructive\_interference\_size}: максимальный размер непрерывных данных, которые гарантированно влезут в одну линию (для оптимизации локальности).
\end{itemize}

\subsection{Дилемма ABI}

К сожалению, использование этих констант сопряжено с проблемами ABI (Application Binary Interface). Если библиотека скомпилирована с одним значением этой константы (на старом компиляторе/железе), а приложение с другим, размеры структур не совпадут, что приведет к краху программы.

Из-за этого, например, компилятор GCC долгое время выдавал предупреждение при использовании этих констант, а в некоторых стандартных библиотеках они реализованы просто как жестко заданные значения.

\begin{summary}
\begin{itemize}
    \item Процессор обменивается данными кэш-линиями (обычно 64 байта).
    \item \textbf{False Sharing} возникает, когда разные потоки пишут в разные переменные, лежащие в одной кэш-линии.
    \item Симптомом является резкое падение производительности при высокой нагрузке на CPU без видимых блокировок.
    \item Решение — использование \texttt{alignas(64)} (или больше) для разнесения "горячих" данных в памяти.
    \item Это классический пример трейдоффа: мы тратим лишнюю память (padding), чтобы выиграть в скорости шины.
\end{itemize}
\end{summary}
