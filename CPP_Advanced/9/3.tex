\chapter{Построение абстракций синхронизации: Event, Semaphore, Latch}

Механизм \texttt{std::condition\_variable}, рассмотренный ранее, является низкоуровневым строительным блоком. В прикладном коде прямое использование связки \texttt{mutex} + \texttt{cv} + \texttt{bool} часто приводит к дублированию кода и ошибкам. 

Для решения типовых задач синхронизации строятся высокоуровневые абстракции, инкапсулирующие управление состоянием и блокировками. В этой главе мы реализуем три фундаментальных примитива: Событие (Event), Семафор (Semaphore) и Защелку (Latch), разбирая их внутреннюю механику и сценарии использования.

\section{Событие (Event)}

Абстракция \textbf{Event} (в терминологии Windows API) или "одноразовый сигнал" позволяет одному потоку уведомить другой (или несколько других) о наступлении определенного факта. В отличие от сырой условной переменной, класс \texttt{Event} хранит свое состояние внутри.

Существует два основных типа событий:
\begin{itemize}
    \item \textbf{Manual Reset Event:} После перехода в сигнальное состояние остается в нем до явного сброса. Все потоки, пришедшие в \texttt{Wait}, проходят сквозь него немедленно.
    \item \textbf{Auto Reset Event:} После пробуждения одного потока событие автоматически сбрасывается в несигнальное состояние.
\end{itemize}

Реализуем вариант с ручным сбросом (Manual Reset), так как он наиболее наглядно демонстрирует работу с разделяемым флагом.

\begin{cppcode}[title=Реализация класса Event]
class Event {
public:
    // Перевод события в сигнальное состояние
    void Signal() {
        {
            // Захват мьютекса обязателен для изменения флага
            std::lock_guard lock{mtx_};
            ready_ = true;
        }
        // Оптимизация: уведомление после разблокировки мьютекса
        // позволяет проснувшимся потокам сразу захватить его
        cv_.notify_all();
    }

    // Блокирующее ожидание события
    void Wait() {
        std::unique_lock lock{mtx_};
        // Стандартный паттерн ожидания с предикатом
        cv_.wait(lock, [this] { return ready_; });
    }

    // Неблокирующая проверка состояния
    bool Ready() {
        std::lock_guard lock{mtx_};
        return ready_;
    }
    
    // Сброс события (для повторного использования)
    void Reset() {
        std::lock_guard lock{mtx_};
        ready_ = false;
    }

private:
    std::mutex mtx_;
    std::condition_variable cv_;
    bool ready_ = false;
};
\end{cppcode}

В методе \texttt{Signal} мы используем \texttt{notify\_all}, так как событие подразумевает, что "информация стала доступна", и это может быть интересно множеству подписчиков.

\section{Семафор (Semaphore)}

Если мьютекс обеспечивает \textbf{эксклюзивный} доступ (в критической секции находится ровно 1 поток), то семафор управляет пулом ресурсов, допуская одновременный доступ для $N$ потоков.

Семафор содержит внутренний счетчик доступных "токенов" (разрешений).
\begin{itemize}
    \item \textbf{Acquire (P-операция):} Если счетчик $>0$, уменьшает его и продолжает работу. Если счетчик $==0$, поток блокируется.
    \item \textbf{Release (V-операция):} Увеличивает счетчик и будит один из ожидающих потоков.
\end{itemize}

\textbf{Сценарий использования:} Ограничение количества одновременных подключений к базе данных или внешнему API (Rate Limiting). Например, если внешний сервис разрешает не более 10 параллельных запросов, семафор с начальным значением 10 обеспечит соблюдение этого лимита на уровне архитектуры приложения.

\begin{cppcode}[title=Реализация Counting Semaphore]
class Semaphore {
public:
    explicit Semaphore(int initial_count) : counter_{initial_count} {}

    // Захват ресурса (аналог lock)
    void acquire() {
        std::unique_lock lock{mutex_};
        // Ждем, пока появятся свободные слоты (counter > 0)
        not_empty_.wait(lock, [this] { return counter_ > 0; });
        --counter_;
    }

    // Освобождение ресурса (аналог unlock)
    void release() {
        {
            std::unique_lock lock{mutex_};
            ++counter_;
        }
        // Будим только один поток, так как освободился всего один слот
        not_empty_.notify_one();
    }

private:
    int counter_;
    std::mutex mutex_;
    std::condition_variable not_empty_;
};
\end{cppcode}

Важное отличие от мьютекса: у семафора нет концепции "владельца". Поток, вызвавший \texttt{acquire}, не обязан вызывать \texttt{release}. Разрешение может быть возвращено любым другим потоком (хотя в классическом RAII-подходе это происходит в деструкторе гарда).

Начиная с C++20, в стандарте доступны \texttt{std::counting\_semaphore} и \texttt{std::binary\_semaphore}, которые могут быть реализованы более эффективно (через атомики и футексы без тяжелых мьютексов), но приведенная реализация демонстрирует их логическую суть.

\section{Защелка (Latch)}

Защелка (Latch) — это примитив синхронизации обратного отсчета. Она инициализируется значением $N$. Потоки могут уменьшать это значение (\texttt{Arrive}). Потоки могут ждать, пока значение не станет равным нулю (\texttt{Wait}).
В отличие от \texttt{Barrier}, защелка одноразовая: после достижения нуля она не сбрасывается.

\textbf{Сценарий использования:} Ожидание завершения инициализации $N$ сервисов перед запуском основного цикла обработки, или ожидание завершения $N$ параллельных подзадач в алгоритме MapReduce.

\subsection{Наивная реализация}

\begin{cppcode}[title=Latch на базе мьютекса]
class Latch {
public:
    explicit Latch(int count) : count_{count} {}

    void Arrive() {
        std::lock_guard lock{mtx_};
        if (--count_ == 0) {
            cv_.notify_all(); // Будим всех ожидающих
        }
    }

    void Wait() {
        std::unique_lock lock{mtx_};
        cv_.wait(lock, [this] { return count_ == 0; });
    }

private:
    std::mutex mtx_;
    std::condition_variable cv_;
    int count_;
};
\end{cppcode}

В этой реализации есть проблема производительности. Если 100 рабочих потоков завершают работу почти одновременно и вызывают \texttt{Arrive}, они создают высокую конкуренцию (contention) на одном мьютексе \texttt{mtx\_}. Каждое уменьшение счетчика требует захвата и освобождения мьютекса, что дорого.

\subsection{Оптимизация с использованием std::atomic}

Заметим, что мьютекс нам нужен по факту только для одного события: уведомления ожидающего потока (когда счетчик переходит из 1 в 0). Все остальные декременты (из 100 в 99, из 99 в 98 и т.д.) можно выполнить атомарно без полной блокировки.

\begin{cppcode}[title=Оптимизированный Latch]
#include <atomic>

class Latch {
public:
    explicit Latch(int count) : count_{count} {}

    void Arrive() {
        // Атомарный декремент. fetch_sub возвращает СТАРОЕ значение.
        // Блокировка не захватывается для декремента.
        if (count_.fetch_sub(1) == 1) {
            // Если старое значение было 1, значит теперь стало 0.
            // Именно этот поток "выключил свет" и должен уведомить остальных.
            
            // Формально notify_all можно вызывать без лока, но 
            // в некоторых реализациях CV это может быть безопасно
            // только если мы уверены в времени жизни объекта.
            // Для строгости стандарта захватим лок или используем atomic notify (C++20).
            std::lock_guard lock{mtx_}; 
            cv_.notify_all();
        }
    }

    void Wait() {
        std::unique_lock lock{mtx_};
        // Предикат читает атомик
        cv_.wait(lock, [this] { return count_.load() == 0; });
    }

private:
    std::mutex mtx_;
    std::condition_variable cv_;
    std::atomic<int> count_; // Теперь это atomic
};
\end{cppcode}

В оптимизированном варианте 99 из 100 потоков выполнят лишь одну процессорную инструкцию \texttt{lock xadd} (на x86) и продолжат выполнение, не затрагивая мьютекс и планировщик ОС. Лишь последний поток заплатит цену за синхронизацию. Это существенно снижает накладные расходы при большом количестве воркеров.

\begin{important}
C++20 вводит \texttt{std::latch} и \texttt{std::barrier}, которые реализованы максимально эффективно (часто вообще без использования \texttt{std::mutex} и \texttt{std::condition\_variable}, опираясь только на атомики и системные вызовы типа futex).
\end{important}
