\chapter{Механизм Condition Variable: Корректное ожидание}

Как мы выяснили в предыдущей главе, для эффективного ожидания событий необходима поддержка со стороны операционной системы. В стандартной библиотеке C++ таким механизмом является \texttt{std::condition\_variable}. Это примитив синхронизации, который позволяет одному или нескольким потокам заблокироваться (уйти в сон) до тех пор, пока другой поток не отправит уведомление о том, что состояние разделяемых данных изменилось.

\section{Триада синхронизации}

Для корректной работы с условными переменными всегда требуются три компонента, работающие в связке:
\begin{enumerate}
    \item \textbf{Разделяемое состояние} (Shared State) — данные, изменения которых мы ждем (например, флаг \texttt{bool is\_ready} или очередь задач).
    \item \textbf{Мьютекс} (\texttt{std::mutex}) — для защиты доступа к разделяемому состоянию.
    \item \textbf{Условная переменная} (\texttt{std::condition\_variable}) — механизм сигнализации.
\end{enumerate}

Важная особенность интерфейса \texttt{std::condition\_variable::wait} заключается в том, что он принимает не просто мьютекс, а \texttt{std::unique\_lock<std::mutex>}. Использование \texttt{std::lock\_guard} здесь невозможно. Это продиктовано механикой работы: \texttt{wait} должен иметь возможность программно разблокировать и снова заблокировать мьютекс, чем \texttt{lock\_guard} (владеющий мьютексом до конца области видимости) не управляет.

Рассмотрим канонический пример взаимодействия Producer и Consumer:

\begin{cppcode}[]
#include <mutex>
#include <condition_variable>
#include <iostream>
#include <thread>

std::mutex m;
std::condition_variable cv;
bool ready = false; // Разделяемое состояние
int data = 0;

void producer() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    {
        // 1. Захватываем мьютекс для модификации состояния
        std::lock_guard<std::mutex> lk(m);
        data = 42;
        ready = true;
    } // Мьютекс освобождается здесь
    
    // 2. Уведомляем ожидающий поток
    cv.notify_one();
}

void consumer() {
    // 1. Захватываем мьютекс через unique_lock
    std::unique_lock<std::mutex> lk(m);
    
    // 2. Ждем выполнения условия
    // wait принимает блокировку и предикат
    cv.wait(lk, []{ return ready; });
    
    // 3. Здесь мьютекс снова захвачен, а ready == true
    std::cout << "Data received: " << data << "\n";
}
\end{cppcode}

\section{Механика метода wait}

Что именно происходит внутри вызова \texttt{cv.wait(lk)}? Это сложная составная операция, которую можно разложить на следующие этапы:

\begin{enumerate}
    \item \textbf{Проверка предиката (опционально):} Если передан предикат (лямбда \texttt{[]\{ return ready; \}}), он выполняется. Если он возвращает \texttt{true}, метод немедленно возвращает управление, поток продолжает работу.
    \item \textbf{Атомарное освобождение и сон:} Если предикат вернул \texttt{false} (или не был передан), \texttt{condition\_variable} атомарно выполняет два действия:
    \begin{itemize}
        \item Разблокирует мьютекс (\texttt{lk.unlock()}).
        \item Переводит текущий поток в список ожидания на данной условной переменной и усыпляет его (Syscall `futex wait` в Linux).
    \end{itemize}
    Атомарность здесь критически важна: между освобождением мьютекса и уходом в сон не может "вклиниться" другой поток и отправить уведомление, которое мы бы пропустили (проблема Lost Wakeup).
    \item \textbf{Ожидание:} Поток спит. Он не потребляет CPU.
    \item \textbf{Пробуждение:} Поток просыпается по сигналу (\texttt{notify}) или системному событию.
    \item \textbf{Захват мьютекса:} Перед тем как вернуть управление пользовательскому коду, \texttt{wait} обязан снова захватить мьютекс (\texttt{lk.lock()}). Если мьютекс занят другим потоком, наш поток блокируется на мьютексе.
\end{enumerate}

\section{Ложные пробуждения (Spurious Wakeups)}

Один из самых неочевидных и опасных аспектов работы с условными переменными — это феномен ложных пробуждений.

\begin{important}
Поток, заблокированный в \texttt{cv.wait()}, может проснуться \textbf{даже если никто не вызывал} \texttt{notify\_one()} или \texttt{notify\_all()}.
\end{important}

Это не баг стандартной библиотеки C++, а особенность реализации планировщиков операционных систем (в частности, POSIX Threads). Причины могут быть разными: обработка сигналов процессом, оптимизации реализации условных переменных (например, использование широковещательного пробуждения вместо точечного в некоторых гонках внутри ядра).

Из-за этого факта использование \texttt{if} для проверки условия является грубой ошибкой:

\begin{cppcode}[title=Некорректный код (Anti-pattern)]
std::unique_lock<std::mutex> lk(m);
if (!ready) {
    cv.wait(lk); // ОШИБКА!
}
// Если произошло ложное пробуждение, мы попадем сюда,
// хотя ready все еще false.
process(data); // Обработка невалидных данных
\end{cppcode}

Единственно верный паттерн использования — цикл \texttt{while}. Стандартный метод \texttt{cv.wait(lock, predicate)} является синтаксическим сахаром для следующего цикла:

\begin{cppcode}[title=Корректная реализация цикла ожидания]
while (!ready) {
    cv.wait(lk);
}
\end{cppcode}

Алгоритм работы потребителя с учетом ложных пробуждений выглядит как диаграмма состояний:
\begin{enumerate}
    \item Захватить мьютекс.
    \item Проверить условие. Если \texttt{true} — выйти из цикла.
    \item Если \texttt{false} — освободить мьютекс и уснуть.
    \item ... (сон) ...
    \item Проснуться (по любой причине).
    \item Захватить мьютекс.
    \item Перейти к шагу 2.
\end{enumerate}

Таким образом, даже если ОС разбудит поток "просто так", цикл снова проверит переменную \texttt{ready}, увидит \texttt{false} и снова отправит поток спать.

\section{Проблема потерянного уведомления (Lost Wakeup)}

Почему так важно изменять разделяемую переменную (\texttt{ready = true}) под мьютексом? Рассмотрим сценарий без мьютекса:

\begin{cppcode}[title=Сценарий гонки (Race Condition)]
// Поток 1 (Producer)          // Поток 2 (Consumer)
                               while (!ready) {
ready = true;                      // 1. Прочитал ready (false)
cv.notify_one();                   // 2. Отправил сигнал (в пустоту)
                                   cv.wait(lk); // 3. Уснул навечно
                               }
\end{cppcode}

Если уведомление отправляется в момент между проверкой условия (шаг 1) и входом в состояние сна (шаг 3), оно "теряется". Условная переменная не хранит состояние (в отличие от Семафора или Event в Windows), она работает как мгновенный сигнал. Если в момент свистка на платформе никого не было, никто этот свисток не услышит и позже не узнает о нем.

Мьютекс гарантирует, что проверка условия и переход в режим ожидания являются атомарной последовательностью относительно изменения условия.

\section{Стратегии уведомления: notify\_one vs notify\_all}

\texttt{std::condition\_variable} предоставляет два метода пробуждения:
\begin{itemize}
    \item \texttt{notify\_one()}: Будит \textit{один} из ожидающих потоков. Какой именно — не определено стандартом (зависит от планировщика). Используется, когда событие подразумевает эксклюзивную обработку (один элемент в очереди — один рабочий поток).
    \item \texttt{notify\_all()}: Будит \textit{все} ожидающие потоки. Используется, когда событие касается всех (например, сигнал остановки приложения или открытие "ворот" барьера).
\end{itemize}

Использование \texttt{notify\_all()} в сценарии, когда задачу может выполнить только один поток, приводит к проблеме \textbf{Thundering Herd} ("Эффект разорвавшейся бомбы" или "Стадо бизонов"). 
Представьте 100 потоков, ждущих на одном мьютексе. При \texttt{notify\_all()} все 100 просыпаются. Все 100 пытаются захватить один и тот же мьютекс. Один выигрывает, 99 блокируются снова (теперь уже на мьютексе, а не на CV). Это вызывает огромный всплеск переключений контекста и деградацию производительности.

\section{Оптимизация: Уведомление вне блокировки}

Рассмотрим внимательно код продюсера:

\begin{cppcode}[]
{
    std::lock_guard<std::mutex> lk(m);
    ready = true;
    cv.notify_one(); // (А) Уведомление под мьютексом
}
\end{cppcode}

В варианте (А) происходит следующее:
\begin{enumerate}
    \item Продюсер будит консьюмера (сигнал внутри ядра).
    \item Консьюмер просыпается в ядре, планировщик ставит его на исполнение.
    \item Консьюмер пытается выйти из \texttt{wait}, для чего ему нужно захватить мьютекс \texttt{m}.
    \item Но мьютекс \texttt{m} все еще захвачен продюсером!
    \item Консьюмер снова блокируется, теперь уже ожидая освобождения мьютекса.
    \item Продюсер выходит из скоупа, освобождает мьютекс.
    \item Консьюмер снова просыпается и захватывает мьютекс.
\end{enumerate}

Это называется "Hurry up and Wait". Чтобы избежать лишнего переключения контекста, можно вынести уведомление из-под мьютекса:

\begin{cppcode}[title=Оптимизированный Producer]
{
    std::lock_guard<std::mutex> lk(m);
    ready = true;
} // Мьютекс освобожден
cv.notify_one(); // Уведомление
\end{cppcode}

Теперь, когда консьюмер проснется, мьютекс будет свободен, и он сможет захватить его сразу.

\begin{note}
Эта оптимизация безопасна в большинстве случаев, но требует осторожности, если объект \texttt{cv} может быть уничтожен сразу после разблокировки мьютекса (например, если ожидающий поток отвечает за удаление структуры данных, содержащей CV). Однако в стандартных сценариях долгоживущих очередей или пулов потоков это рекомендуемый паттерн.
\end{note}

В следующей главе мы используем эти знания для построения более высокоуровневых примитивов синхронизации, таких как События и Семафоры.
