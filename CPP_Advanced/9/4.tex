\chapter{Управление потоками: Blocking Queue и Thread Pool}

В предыдущих главах мы рассматривали механизмы синхронизации на примере взаимодействия небольшого количества потоков. Однако в реальных высоконагруженных системах создание нового потока (\texttt{std::thread}) на каждую задачу является архитектурной ошибкой.

Стоимость создания потока в современных операционных системах не является нулевой. Она включает в себя:
\begin{itemize}
    \item Аллокацию стека (обычно 1–8 МБ адресного пространства).
    \item Создание структур данных ядра (Kernel Thread Control Block).
    \item Системные вызовы для регистрации потока в планировщике.
\end{itemize}

Замеры показывают, что запуск потока может занимать от десятков до сотен микросекунд. Если полезная нагрузка задачи сопоставима с этим временем (например, вычисление квадратного корня или короткий сетевой запрос), система будет тратить больше времени на администрирование потоков, чем на вычисления.

Решением является паттерн \textbf{Thread Pool} (Пул потоков): создание фиксированного набора потоков при старте приложения и переиспользование их для выполнения множества задач. Центральным элементом этой архитектуры выступает \textbf{Blocking Queue} (Блокирующая очередь).

\section{Блокирующая очередь (Blocking Queue)}

Блокирующая очередь — это потокобезопасный буфер, реализующий паттерн Producer-Consumer.
\begin{itemize}
    \item Метод \texttt{Put} добавляет элемент в очередь и уведомляет ожидающие потоки.
    \item Метод \texttt{Take} извлекает элемент. Если очередь пуста, вызывающий поток блокируется до появления данных.
\end{itemize}

Ключевой сложностью при реализации очереди является не сама синхронизация доступа (она тривиальна через мьютекс), а механизм корректного завершения работы (Graceful Shutdown).

\subsection{Проблема остановки (Shutdown)}

Рассмотрим ситуацию, когда приложение завершается. Пул потоков должен остановиться. Если мы просто вызовем деструкторы потоков или \texttt{std::terminate}, мы рискуем прервать задачи на середине или получить утечки ресурсов.
Нам нужен механизм, который сообщает потокам-потребителям: "Больше данных не будет, доделывайте текущую работу и выходите".

Этот механизм реализуется через внутренний флаг \texttt{stopped\_} и изменение сигнатуры метода \texttt{Take}. Вместо \texttt{T} он должен возвращать \texttt{std::optional<T>}:
\begin{itemize}
    \item \texttt{std::nullopt} — сигнал о том, что очередь закрыта и пуста.
    \item \texttt{Value} — валидная задача для исполнения.
\end{itemize}

\subsection{Реализация UnboundedBlockingQueue}

Ниже представлена реализация неограниченной блокирующей очереди с поддержкой механизма остановки.

\begin{cppcode}[title=Реализация блокирующей очереди]
template <typename T>
class UnboundedBlockingQueue {
public:
    bool Put(T value) {
        std::lock_guard<std::mutex> guard(mutex_);
        if (stopped_) {
            return false; // Нельзя добавлять в закрытую очередь
        }
        buffer_.push_back(std::move(value));
        not_empty_.notify_one(); // Будим одного воркера
        return true;
    }

    std::optional<T> Take() {
        std::unique_lock<std::mutex> guard(mutex_);
        
        // КРИТИЧЕСКИЙ МОМЕНТ: Предикат ожидания
        // Мы ждем, пока:
        // 1. Очередь остановлена (stopped_ == true)
        // ИЛИ
        // 2. В очереди есть данные (!buffer_.empty())
        not_empty_.wait(guard, [this] { 
            return stopped_ || !buffer_.empty(); 
        });

        // После пробуждения проверяем:
        // Если очередь остановлена И пуста -> возвращаем nullopt
        if (stopped_ && buffer_.empty()) {
            return std::nullopt;
        }

        // Иначе забираем элемент
        T result = std::move(buffer_.front());
        buffer_.pop_front();
        return result;
    }

    // Graceful Shutdown: доработать оставшиеся задачи
    void Close() {
        CloseImpl(/*clear=*/false);
    }

    // Hard Shutdown: выбросить все задачи и остановиться
    void Cancel() {
        CloseImpl(/*clear=*/true);
    }

private:
    void CloseImpl(bool clear) {
        std::lock_guard<std::mutex> guard(mutex_);
        stopped_ = true;
        if (clear) {
            buffer_.clear();
        }
        // Важно: будим ВСЕХ, чтобы они проснулись, увидели stopped_
        // и корректно завершили свои циклы
        not_empty_.notify_all();
    }

private:
    std::mutex mutex_;
    std::condition_variable not_empty_;
    bool stopped_{false};
    std::deque<T> buffer_; // std::deque эффективнее vector для FIFO
};
\end{cppcode}

\begin{important}
Обратите внимание на вызов \texttt{not\_empty\_.notify\_all()} в методе \texttt{CloseImpl}. Если 10 потоков спят в методе \texttt{Take}, и мы закроем очередь, нам нужно разбудить их всех, чтобы они могли проверить флаг \texttt{stopped\_} и вернуть \texttt{std::nullopt}. Если использовать \texttt{notify\_one}, 9 потоков останутся спать навечно, и программа зависнет при выходе (deadlock при \texttt{join}).
\end{important}

\section{Пул потоков (Thread Pool)}

Пул потоков представляет собой владельца рабочих потоков (Workers) и очереди задач. 
Для хранения произвольных задач используется \texttt{std::function<void()>}. Это техника стирания типа (Type Erasure), позволяющая хранить в одном контейнере лямбда-выражения, функторы и указатели на функции с разным контекстом захвата, при условии, что они имеют сигнатуру вызова \texttt{void()}.

\begin{cppcode}[title=Реализация ThreadPool]
#include <vector>
#include <thread>
#include <functional>

class ThreadPool {
public:
    using Task = std::function<void()>;

    explicit ThreadPool(size_t num_threads) {
        workers_.reserve(num_threads);
        for (size_t i = 0; i < num_threads; ++i) {
            // Запускаем потоки, каждый из которых исполняет метод Run
            workers_.emplace_back([this] { Run(); });
        }
    }

    // Добавление задачи
    void Submit(Task task) {
        queue_.Put(std::move(task));
    }

    // Явное ожидание завершения
    void Join() {
        queue_.Close(); // Сообщаем потокам о закрытии
        for (auto& t : workers_) {
            if (t.joinable()) {
                t.join(); // Ждем завершения каждого потока
            }
        }
    }

    // Деструктор обеспечивает безопасность (RAII)
    ~ThreadPool() {
        Join();
    }

private:
    // Цикл рабочего потока
    void Run() {
        // Цикл работает, пока Take() возвращает значение
        while (auto task = queue_.Take()) {
            try {
                (*task)(); // Выполняем задачу
            } catch (...) {
                // В простейшем пуле исключения в задачах 
                // не должны убивать рабочий поток.
                // В реальном коде здесь нужно логирование.
            }
        }
        // Выход из цикла означает, что очередь закрыта и пуста
    }

private:
    UnboundedBlockingQueue<Task> queue_;
    std::vector<std::thread> workers_;
};
\end{cppcode}

\section{Анализ архитектуры}

Данная реализация демонстрирует классическую схему "One Queue - Multiple Workers".

\subsection{Достоинства}
\begin{enumerate}
    \item \textbf{Балансировка нагрузки:} Свободный поток сразу забирает следующую задачу. Нет простоя, пока есть работа.
    \item \textbf{Простота:} Вся синхронизация инкапсулирована в \texttt{BlockingQueue}. Код пула минималистичен.
\end{enumerate}

\subsection{Недостатки и ограничения}
\begin{enumerate}
    \item \textbf{Contention (Конкуренция):} Все потоки борются за один мьютекс внутри очереди. При очень большом количестве потоков (>32-64) и коротких задачах мьютекс становится узким местом. В таких случаях используют \textit{Work Stealing Queue} (очередь на каждый поток + кража задач).
    \item \textbf{Исключения:} Если задача выбросит исключение, которое не будет поймано внутри \texttt{Run}, функция потока завершится аварийно, и \texttt{std::terminate} убьет все приложение. Поэтому вызов задачи обернут в \texttt{try-catch}.
    \item \textbf{Блокирующие задачи:} Если все потоки пула заняты задачами, которые ожидают ввода-вывода или других событий (например, спят), пул встанет (Thread Starvation). Для блокирующих операций рекомендуется использовать отдельные пулы или асинхронный I/O.
\end{enumerate}

\begin{summary}
Пул потоков с блокирующей очередью — это стандарт де-факто для параллельной обработки CPU-bound задач в C++. Он позволяет амортизировать накладные расходы на создание потоков и контролировать уровень параллелизма в системе.
\end{summary}
