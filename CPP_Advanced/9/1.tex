\chapter{От активного ожидания к поддержке ядра: Проблема синхронизации}

Одной из фундаментальных задач многопоточного программирования является координация действий между потоками. Часто возникает сценарий producer-consumer, где один поток готовит данные, а второй должен дождаться их готовности перед обработкой. В этой главе мы рассмотрим эволюцию подходов к ожиданию события: от наивного активного цикла до использования механизмов ядра операционной системы.

\section{Активное ожидание (Polling)}

Самый очевидный способ заставить поток ждать изменения состояния — это запустить бесконечный цикл проверки условия. Этот подход называется активным ожиданием (busy wait) или поллингом (polling).

\begin{cppcode}[]
#include <atomic>
#include <chrono>
#include <thread>
#include <iostream>

std::atomic<bool> is_ready(false);

void producer() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    is_ready.store(true);
}

void consumer() {
    // Busy wait цикл
    while (!is_ready.load()) {
        // Поток бесконечно проверяет переменную
    }
    std::cout << "Data processed\n";
}

int main() {
    std::thread t(producer);
    consumer();
    t.join();
}
\end{cppcode}

С точки зрения логики программы этот код корректен: поток `consumer` действительно дождется установки флага. Однако с точки зрения архитектуры системы это решение неприемлемо.

Цикл `while` в `consumer` представляет собой непрерывный поток инструкций для процессора. Планировщик операционной системы (OS Scheduler) видит, что поток готов к исполнению, и выделяет ему квант времени (time slice). Поток тратит этот квант на бесконечную проверку `false`, не выполняя полезной работы.

\begin{important}
Активное ожидание приводит к загрузке ядра процессора на 100\% ("греет воздух"). Это увеличивает энергопотребление, нагрев CPU и может приводить к троттлингу частот. Кроме того, в условиях конкуренции за ресурсы (например, на одноядерной машине или при большом количестве потоков), активный поток отбирает время у потока-продюсера, замедляя наступление ожидаемого события (Starvation).
\end{important}

Попытка смягчить проблему с помощью `std::this\_thread::yield()` не решает ее фундаментально:
\begin{cppcode}[]
while (!is_ready.load()) {
    std::this_thread::yield();
}
\end{cppcode}

`yield()` сообщает планировщику, что поток готов отдать остаток своего кванта времени. Однако, если в очереди планировщика нет других готовых к исполнению потоков (или их приоритет ниже), управление немедленно вернется к текущему потоку, и цикл продолжится. В нагруженной системе это лишь увеличивает накладные расходы на переключение контекста (Context Switch Overhead).

\section{Наивное решение: Сон (Sleep)}

Следующая итерация попытки решить проблему без специальных примитивов синхронизации — добавление задержки в цикл проверки.

\begin{cppcode}[]
while (!is_ready.load()) {
    std::this_thread::sleep_for(std::chrono::milliseconds(2));
}
\end{cppcode}

Здесь поток добровольно уходит в состояние ожидания, и планировщик исключает его из очереди на исполнение на указанное время. Загрузка CPU падает почти до нуля. Однако появляются две критические проблемы:

\subsection{1. Латентность (Latency)}
Если событие (`is\_ready = true`) произойдет через 0.1 мс после начала сна, поток-потребитель узнает об этом только через 1.9 мс, когда проснется. В высокопроизводительных системах (HFT, Real-Time Systems) задержка в миллисекунды недопустима. Уменьшение времени сна приближает нас обратно к активному ожиданию и лишним переключениям контекста.

\subsection{2. Зависимость от планировщика}
Аргумент функции `sleep\_for` — это \textit{минимальное} время сна. Реальное время зависит от гранулярности системного таймера и загруженности планировщика.
\begin{itemize}
    \item В Windows дефолтная гранулярность таймера может достигать 15.6 мс. Запрос на сон в 1 мс фактически усыпит поток на 15 мс.
    \item Операционная система не гарантирует мгновенного пробуждения. Поток проснется, попадет в очередь готовых к исполнению, и только когда до него дойдет очередь, он получит процессорное время.
\end{itemize}

Использование "магических констант" (например, 2 мс) — признак плохого дизайна. Время выполнения операций может варьироваться на порядки в зависимости от железа, и подобранная константа будет либо слишком большой (латентность), либо слишком маленькой (нагрузка на CPU).

\section{Атомарные операции и Livelock}

Иногда разработчики пытаются реализовать механизмы синхронизации на базе сложных атомарных операций, таких как `compare\_exchange\_weak` (CAS), надеясь избежать использования "тяжелых" мьютексов.

\begin{cppcode}[]
void wait_for_flag(std::atomic<int>& counter) {
    int expected = 1;
    // Пытаемся атомарно изменить значение, если оно равно expected
    while (!counter.compare_exchange_weak(expected, 0)) {
        expected = 1; // Сброс expected, так как CAS обновляет его при неудаче
        // Busy wait
    }
}
\end{cppcode}

Хотя `std::atomic` обеспечивает корректность с точки зрения гонок данных (Data Race Free), с точки зрения использования ресурсов это тот же самый busy loop. Атомарные операции (особенно RMW — Read-Modify-Write) значительно дороже обычных операций чтения/записи, так как требуют блокировки шины памяти или использования протоколов когерентности кэшей (MESI) между ядрами.

В таком сценарии возможен \textbf{Livelock}. В отличие от Deadlock, где потоки заблокированы и не двигаются, в Livelock потоки активно выполняют инструкции, меняют свои локальные состояния, но глобальный прогресс системы отсутствует или крайне мал из-за постоянной конкуренции за кэш-линию (cache contention).

\section{Необходимость поддержки ядра}

Все рассмотренные выше методы работают в пространстве пользователя (User Space) и пытаются эмулировать ожидание. Эффективное решение невозможно без участия ядра операционной системы.

Нам нужен механизм, который позволяет:
\begin{enumerate}
    \item Перевести поток в состояние блокировки (Blocked/Waiting), полностью убрав его из очереди планировщика.
    \item Гарантировать, что поток будет разбужен \textbf{только} тогда, когда наступит определенное событие (или придет сигнал).
    \item Выполнить пробуждение максимально быстро после наступления события.
\end{enumerate}

В Linux для этого используется системный вызов \texttt{futex} (fast userspace mutex), в Windows — \texttt{WaitOnAddress} или объекты ядра (Event, Semaphore). В стандарте C++ эти механизмы абстрагированы в примитив \textbf{Condition Variable} (условная переменная), который мы рассмотрим в следующей главе.
