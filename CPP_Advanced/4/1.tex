\chapter{Анатомия типов и оптимизация памяти (Layout \& EBO)}

\section{Семантика и механика типов}

Тип в C++ — это контракт, определяющий множество допустимых операций над объектом и интерпретацию битов в памяти. В отличие от языка ассемблера, где байт — это просто байт, система типов C++ накладывает семантические ограничения (invariants), которые компилятор использует для генерации корректного машинного кода и оптимизаций.

\subsection{Struct vs Class}

Существует распространенное заблуждение о фундаментальных различиях между \texttt{struct} и \texttt{class}. Технически, в C++ это идентичные конструкции за исключением одного свойства: модификатора доступа по умолчанию.

\begin{definition}{Struct vs Class}
\begin{itemize}
    \item \textbf{class}: Все поля и наследование по умолчанию \texttt{private}.
    \item \textbf{struct}: Все поля и наследование по умолчанию \texttt{public}.
\end{itemize}
\end{definition}

Следующие два объявления генерируют идентичный layout в памяти и идентичный машинный код:

\begin{cppcode}[]
class A {
public:
    int x;
};

struct B {
    int x;
};
\end{cppcode}

Выбор между ними — вопрос конвенции. Обычно \texttt{struct} используется для POD-типов (Plain Old Data), представляющих собой набор открытых полей без сложной инвариантной логики, а \texttt{class} — для сущностей, требующих инкапсуляции и поддержания инвариантов.

\section{Инвариант ненулевого размера}

Одним из фундаментальных правил объектной модели C++ является гарантия уникальности адресов (identity) для различных объектов одного типа.

\begin{important}
В C++ размер любого законченного объекта типа не может быть равен нулю. \texttt{sizeof(T) >= 1}.
\end{important}

Даже если структура не содержит полей данных, компилятор обязан выделить ей минимум 1 байт памяти.

\begin{cppcode}[]
struct Empty {};
static_assert(sizeof(Empty) == 1);
\end{cppcode}

\subsection{Причина ограничения}
Это требование продиктовано необходимостью адресной арифметики, в частности для массивов. Рассмотрим массив из двух пустых структур:

\begin{cppcode}[]
Empty arr[2];
\end{cppcode}

Если бы \texttt{sizeof(Empty)} был равен 0, то адреса \texttt{\&arr[0]} и \texttt{\&arr[1]} совпадали бы. Это нарушило бы логику указателей: указатель на первый элемент массива был бы неотличим от указателя на второй. Чтобы гарантировать \texttt{\&arr[i] != \&arr[j]} при \texttt{i != j}, каждый элемент должен занимать физическое место в памяти.

\begin{note}
В языке Rust существуют \textit{Zero Sized Types (ZST)}, которые действительно занимают 0 байт. Это возможно, так как в Rust иная модель памяти и правил адресной арифметики для таких типов. В C++ это невозможно из-за гарантий обратной совместимости и модели указателей.
\end{note}

\section{Проблема накладных расходов (Memory Overhead)}

Инвариант ненулевого размера создает проблему при композиции объектов. Рассмотрим классический пример контейнера, такого как \texttt{std::vector}. Вектор должен хранить аллокатор для управления памятью. Аллокатор по умолчанию \texttt{std::allocator} не имеет состояния (stateless), то есть не содержит полей данных.

Наивная реализация вектора могла бы выглядеть так:

\begin{cppcode}[]
template <typename T, typename Alloc = std::allocator<T>>
class Vector {
    T* begin_;      // 8 байт (на 64-бит)
    T* end_;        // 8 байт
    T* cap_;        // 8 байт
    Alloc alloc_;   // 1 байт (минимум)
    // + 7 байт padding для выравнивания
};
\end{cppcode}

В 64-битной архитектуре указатели требуют выравнивания по границе 8 байт. Если структура содержит три указателя (24 байта) и поле типа \texttt{Alloc} (1 байт), компилятор вынужден добавить 7 байт padding'а, чтобы размер структуры был кратен выравниванию самого строгого поля (8 байт).

Итоговый размер: $24 + 1 + 7 = 32$ байта.
Мы платим 8 байт памяти за хранение объекта, который логически пуст. Это недопустимый overhead для системных библиотек.

\section{Empty Base Optimization (EBO)}

Стандарт C++ предоставляет исключение из правила ненулевого размера. Оно применимо только к базовым классам.

\begin{definition}{Empty Base Optimization (EBO)}
Если пустой класс используется в качестве базового класса, компилятору разрешено не выделять под него отдельную память, при условии, что это не нарушает требование уникальности адресов.
\end{definition}

Если мы перепишем \texttt{Vector}, используя наследование от аллокатора, размер уменьшится:

\begin{cppcode}[]
template <typename T, typename Alloc>
class Vector : private Alloc { // Наследование вместо композиции
    T* begin_;
    T* end_;
    T* cap_;
};
\end{cppcode}

Здесь размер \texttt{Vector} составит ровно 24 байта. Базовый класс \texttt{Alloc} "схлопывается" и имеет нулевой размер внутри layout'а наследника.

Для реализации этого паттерна в стандартной библиотеке долгое время использовался вспомогательный шаблон \texttt{std::compressed\_pair} (или внутренние реализации типа \texttt{\_\_compressed\_pair}), который наследовался от одного или обоих типов, если они пусты.

\subsection{Ограничения EBO и коллизии адресов}

EBO не применяется, если нарушается инвариант уникальности адресов подобъектов. Если первый член структуры имеет тот же тип, что и пустая база, EBO отключается.

\begin{cppcode}[]
struct Empty {};

struct BadEBO : Empty {
    Empty e; // Первое поле совпадает по типу с базой
};
\end{cppcode}

В данном случае:
\begin{enumerate}
    \item Адрес объекта \texttt{BadEBO} совпадает с адресом его базы \texttt{Empty}.
    \item Адрес первого поля \texttt{e} также совпадает с адресом начала структуры.
\end{enumerate}

Если бы EBO сработало, то база и поле \texttt{e} имели бы один и тот же адрес. В C++ два \textit{разных} объекта (базовый подобъект и поле-член) одного типа не могут иметь одинаковый адрес. Компилятор вынужден добавить отступ (padding) для поля \texttt{e}.

\textbf{Результат:} \texttt{sizeof(BadEBO)} равен 2 (1 байт под базу + 1 байт под поле, без учета выравнивания).

\section{Современная оптимизация: атрибут [[no\_unique\_address]]}

С выходом стандарта C++20 необходимость в трюках с наследованием (вроде \texttt{compressed\_pair}) отпала. Появился атрибут \texttt{[[no\_unique\_address]]}.

Этот атрибут сообщает компилятору, что данное поле не обязательно должно иметь уникальный адрес среди других полей, если оно пустое. Фактически это EBO для композиции.

\begin{cppcode}[]
struct Vector20 {
    [[no_unique_address]] std::allocator<int> alloc; // Занимает 0 байт
    int* begin;
    int* end;
    int* cap;
};
\end{cppcode}

\texttt{sizeof(Vector20)} будет равен 24 байтам (на 64-битной системе). Компилятор переиспользует padding, имеющийся в структуре, или просто не выделяет место под поле.

Это позволяет писать более понятный код, используя композицию вместо приватного наследования, сохраняя при этом эффективность памяти.

\subsection{Визуализация Layout}

Сравним расположение в памяти для разных подходов (схематично для 64-bit):

\vspace{1em}
\textbf{1. Наивная композиция (32 байта):}
\begin{verbatim}
[ ptr (8) ][ ptr (8) ][ ptr (8) ][ alloc (1) ][ padding (7) ]
\end{verbatim}

\textbf{2. EBO через наследование (24 байта):}
\begin{verbatim}
[ Alloc (0) | ptr (8) ][ ptr (8) ][ ptr (8) ]
\end{verbatim}
*Базовый класс Alloc виртуально накладывается на начало структуры, не занимая места.*

\textbf{3. Атрибут [[no\_unique\_address]] (24 байта):}
\begin{verbatim}
[ ptr (8) ][ ptr (8) ][ ptr (8) ] (alloc field is optimized out)
\end{verbatim}

\section{Влияние виртуальных функций}

Важно помнить, что наличие хотя бы одной виртуальной функции делает класс непустым, даже если у него нет полей данных.

\begin{cppcode}[]
struct VEmpty {
    virtual ~VEmpty() = default;
};
static_assert(sizeof(VEmpty) == 8); // На 64-bit
\end{cppcode}

\textbf{Причина:} Объект должен хранить указатель на таблицу виртуальных функций (\texttt{vptr}), который добавляется компилятором неявно. EBO к таким классам неприменимо в том смысле, что размер не станет нулевым — он останется равным размеру указателя.

\begin{summary}
\begin{itemize}
    \item Пустые типы имеют размер 1 байт для обеспечения уникальности адресов.
    \item Композиция с пустыми типами вызывает overhead из-за выравнивания.
    \item \textbf{EBO} (через наследование) позволяет обнулить размер пустой базы.
    \item \textbf{C++20 [[no\_unique\_address]]} позволяет достичь того же эффекта при композиции.
    \item При совпадении типов базы и первого поля оптимизация отключается.
\end{itemize}
\end{summary}

