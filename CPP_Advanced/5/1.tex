\chapter{Эволюция обработки ошибок: От C до C++17}

Обработка ошибок — это механизм управления потоком выполнения при возникновении нештатных ситуаций. Любая операция, связанная с ресурсами (память, ввод-вывод), является потенциально сбойной.

Пример аллокации памяти:
\begin{itemize}
    \item \textbf{Явный сбой:} Запрос объема памяти, превышающего физические возможности (32 ГБ на машине с 16 ГБ).
    \item \textbf{Скрытый сбой:} Фрагментация адресного пространства, когда суммарно свободной памяти достаточно, но нет непрерывного блока нужного размера.
    \item \textbf{Внешний сбой:} OOM-killer (Out of Memory killer) в Linux, который может завершить процесс при оверкоммите (overcommit).
\end{itemize}

До появления стандартизированных исключений в C++ (и в языке C) доминировали подходы, основанные на кодах возврата. Рассмотрим их эволюцию и архитектурные недостатки, которые привели к появлению механизма исключений.

\section{Подход языка C: Коды возврата и errno}

В языке C функции сообщают об ошибке через возвращаемое значение. Это создает семантическую неоднозначность: одно и то же значение (например, \texttt{int}) используется и как результат вычисления, и как индикатор статуса.

\subsection{Глобальная переменная errno}
Классический механизм UNIX — использование глобальной переменной \texttt{errno}. Функция возвращает специальное маркерное значение (например, \texttt{-1} или \texttt{NULL}), а код ошибки записывается в глобальную целочисленную переменную.

\begin{cppcode}[minted language=c]
FILE* f = fopen("config.txt", "r");
if (f == NULL) {
    // Код ошибки в errno
    if (errno == ENOENT) {
        // Файл не найден
    } else if (errno == EACCES) {
        // Нет прав доступа
    }
}
\end{cppcode}

\textbf{Недостатки подхода:}
1.  **Потеря контекста.** \texttt{errno} — это просто число. Оно не сообщает, какой именно файл не удалось открыть или почему операция ввода-вывода была прервана.
2.  **Игнорирование ошибок.** Программист обязан проверять результат \textit{каждого} вызова. На практике это часто игнорируется (например, проверка результата \texttt{printf} или \texttt{close}).
3.  **Проблемы многопоточности.** Изначально \texttt{errno} была глобальной, что делало невозможным её использование в multithreading. В современных стандартах это \textit{thread-local} переменная, но архитектурная проблема разделения состояния остается.

\subsection{Паттерн очистки ресурсов в ядре Linux}
В отсутствие деструкторов (RAII) язык C требует ручной очистки ресурсов. Если функция захватывает несколько ресурсов (память, мьютексы, дескрипторы), обработка ошибок превращается в сложную задачу.

В ядре Linux стандартным паттерном является использование \texttt{goto} для обратной раскрутки инициализации. Это эмуляция деструкторов: метки располагаются в порядке, обратном захвату ресурсов.

\begin{cppcode}[minted language=c]
int process_file(const char* path) {
    int err = 0;
    
    void* page = alloc_page();
    if (!page) return -ENOMEM;

    struct inode* node = get_inode(path);
    if (!node) {
        err = -ENOENT;
        goto out_free_page; // Прыжок к освобождению памяти
    }

    if (lock_inode(node) != 0) {
        err = -EIO;
        goto out_put_inode; // Прыжок к освобождению иноды
    }

    // Основная работа...
    
    unlock_inode(node); // Успешное завершение: освобождаем в прямом порядке
out_put_inode:
    put_inode(node);
out_free_page:
    free_page(page);
    
    return err;
}
\end{cppcode}

Данный подход имитирует \texttt{switch-case} без \texttt{break}. Чем глубже произошла ошибка, тем «выше» по стеку очистки нужно прыгнуть. Это эффективно, но требует высокой дисциплины и подвержено ошибкам при рефакторинге (copy-paste ошибок меток).

\section{Подход Go и кортежи возврата (Tuple Returns)}

Современные языки (например, Go) пытаются решить проблему неявности \texttt{errno}, возвращая пару значений: \texttt{(результат, ошибка)}.

\begin{cppcode}[minted language=go]
// Пример на псевдокоде Go
file, err := os.Open("config.txt")
if err != nil {
    return err
}
// Работа с file...
\end{cppcode}

В C++ это можно эмулировать через возврат структуры или \texttt{std::pair}.

\begin{definition}{Product Type vs Sum Type}
С точки зрения теории типов, возврат пары \texttt{(Value, Error)} — это \textbf{Тип-Произведение} (Product Type). Множество возможных состояний равно декартову произведению $S = V \times E$.

Это создает семантически некорректные состояния:
\begin{enumerate}
    \item \texttt{Value} валиден, \texttt{Error} валиден (Противоречие: успех и ошибка одновременно).
    \item \texttt{Value} невалиден, \texttt{Error} невалиден (Отсутствие результата и отсутствие ошибки).
\end{enumerate}

Корректным подходом является \textbf{Тип-Сумма} (Sum Type), реализуемый через \texttt{std::variant<Value, Error>} или \texttt{std::expected} (C++23), где состояние может быть \textit{либо} результатом, \textit{либо} ошибкой, но не обоими сразу.
\end{definition}

Недостатки подхода Go/Tuple в C++:
1.  **Раздувание кода.** Проверка \texttt{if (err)} занимает 3-4 строки на каждый вызов.
2.  **Накладные расходы.** Постоянное конструирование и копирование объектов ошибок, даже если они не нужны (happy path).

\section{Современные оптимизации: std::from\_chars}

В C++17 был введен заголовок \texttt{<charconv>} и функции \texttt{std::from\_chars}, которые используют подход возврата структуры, напоминающий C-style, но по причинам производительности.

\begin{cppcode}[]
#include <charconv>

struct from_chars_result {
    const char* ptr; // Указатель на первый нераспарсенный символ
    std::errc ec;    // Код ошибки (0, если успех)
};

// ...
auto [ptr, ec] = std::from_chars(begin, end, value);
if (ec != std::errc()) {
    // Обработка ошибки
}
\end{cppcode}

\begin{note}
Почему не исключения? Парсинг чисел — операция, которая часто может завершаться неудачей (например, валидация пользовательского ввода). Выброс исключения — это тяжелая операция (раскрутка стека, RTTI), которая может быть в 100-1000 раз медленнее простой проверки кода возврата. Для высоконагруженных низкоуровневых операций (парсинг JSON, логов) возврат структуры оправдан.
\end{note}

\section{Фундаментальная проблема конструкторов}

Ключевая причина введения исключений в C++ — это архитектура объектно-ориентированного программирования, в частности, конструкторов.

\textbf{Конструктор не имеет возвращаемого значения.} Он возвращает сам созданный объект. Если внутри конструктора происходит ошибка (например, \texttt{new} не смог выделить память под буфер вектора), у него нет штатного способа сообщить об этом вызывающему коду через \texttt{return}.

\subsection{Антипаттерн: Двухфазная инициализация}
До исключений использовался подход с разделением создания и инициализации:

\begin{cppcode}
class Vector {
    int* data = nullptr;
public:
    Vector() {} // 1. Дешевое создание "пустого" объекта
    
    // 2. Метод, который может вернуть ошибку
    bool init(size_t size) {
        data = (int*)malloc(size * sizeof(int));
        return data != nullptr;
    }
};

// Клиентский код
Vector v;
if (!v.init(100)) {
    // Обработка ошибки
}
\end{cppcode}

\begin{important}
Этот подход порождает \textbf{"Zombie Objects"} — объекты, которые существуют, но находятся в невалидном состоянии.
\begin{itemize}
    \item Программист может забыть вызвать \texttt{init()}.
    \item Объект может быть передан в функцию, которая ожидает валидное состояние.
    \item Требуется постоянная проверка флагов \texttt{is\_initialized} внутри каждого метода.
\end{itemize}
\end{important}

\subsection{RAII и Исключения}
C++ решает эту проблему через идиому \textbf{RAII} (Resource Acquisition Is Initialization). Инвариант класса должен быть установлен в конструкторе. Если это невозможно (ошибка), конструктор должен прервать выполнение через выброс исключения.

\begin{cppcode}
class Vector {
public:
    Vector(size_t size) {
        data = new int[size]; // Если new упадет, полетит std::bad_alloc
        // Если мы здесь, объект ГАРАНТИРОВАННО валиден
    }
};
\end{cppcode}

Это гарантирует, что в программе не существует "полуживых" объектов. Либо объект создан корректно, либо его создание было прервано исключением и память очищена (при условии корректного Stack Unwinding, который мы рассмотрим далее).

\begin{summary}
\begin{enumerate}
    \item Коды возврата (C-style) приводят к игнорированию ошибок и смешиванию бизнес-логики с обработкой сбоев.
    \item Подход "Результат + Ошибка" (Go) теоретически некорректен (Product Type) и многословен.
    \item Исключения в C++ необходимы для корректной работы конструкторов и предотвращения появления Zombie Objects.
    \item Исключения имеют накладные расходы, поэтому в узких местах (парсинг) применяются специальные API без исключений (\texttt{std::from\_chars}).
\end{enumerate}
\end{summary}
