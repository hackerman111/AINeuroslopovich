\chapter{Продвинутая работа с исключениями: Транспортировка и Slicing}

Работа с исключениями в C++ не ограничивается простыми блоками \texttt{try-catch}. При построении сложных архитектур (например, асинхронных очередей задач или плагинных систем) возникает необходимость сохранять состояние ошибки, передавать его между потоками и корректно обрабатывать полиморфные иерархии исключений.

\section{Физическое расположение исключений}

Когда выполняется инструкция \texttt{throw}, среда выполнения (Runtime) должна аллоцировать память под объект исключения. Возникает вопрос: где именно живет этот объект?

\begin{enumerate}
    \item \textbf{Не на стеке.} Стек раскручивается (unwinding) в процессе поиска обработчика, поэтому объект исключения не может быть локальной переменной.
    \item \textbf{Не в статической памяти.} Исключения могут быть рекурсивными или возникать в нескольких потоках одновременно.
\end{enumerate}

Фактически, компиляторы (в соответствии с ABI, например, Itanium C++ ABI) выделяют память в отдельной области кучи (heap). Это накладывает специфические требования:
\begin{itemize}
    \item Операция \texttt{throw} может потребовать динамической аллокации.
    \item Если памяти нет (бросается \texttt{std::bad\_alloc}), Runtime использует заранее зарезервированный "аварийный буфер", чтобы гарантировать возможность сообщить об ошибке нехватки памяти.
\end{itemize}

Время жизни этого объекта управляется Runtime. Он существует до тех пор, пока последний обработчик \texttt{catch} не завершит свою работу с ним.

\section{Проблема срезки (Object Slicing)}

Одной из самых коварных ошибок в C++ является перехват исключений по значению, а не по ссылке. Это приводит к потере полиморфизма и данных, известной как \textbf{Object Slicing} (срезка объекта).

Рассмотрим иерархию ошибок:
\begin{cppcode}
struct ErrorBase {
    virtual const char* what() const { return "Base Error"; }
    virtual ~ErrorBase() = default;
};

struct DatabaseError : ErrorBase {
    int errorCode;
    DatabaseError(int code) : errorCode(code) {}
    
    const char* what() const override { return "DB Error"; }
};
\end{cppcode}

Если мы выбросим \texttt{DatabaseError}, но поймаем его как \texttt{ErrorBase} (по значению), произойдет следующее:

\begin{cppcode}
void unsafe_handler() {
    try {
        throw DatabaseError(505);
    } catch (ErrorBase e) { // ОШИБКА: Перехват по значению!
        // 1. Создается новый объект типа ErrorBase.
        // 2. Вызывается копирующий конструктор ErrorBase(const ErrorBase&).
        // 3. Поля DatabaseError (errorCode) отбрасываются.
        // 4. vptr теперь указывает на таблицу виртуальных функций Base.
        
        std::cout << e.what(); // Выведет "Base Error", а не "DB Error"
    }
}
\end{cppcode}

\begin{definition}{Механика Slicing}
При копировании объекта-наследника в переменную базового типа происходит физическое копирование только той части памяти, которая относится к базовому классу. Дополнительные поля наследника игнорируются. Указатель на таблицу виртуальных функций (\texttt{vptr}) инициализируется значением для базового класса, полностью стирая полиморфное поведение.
\end{definition}

\begin{important}
Всегда перехватывайте исключения по константной ссылке:
\texttt{catch (const ErrorBase\& e)}.
Это предотвращает копирование и сохраняет полиморфизм (вызов \texttt{e.what()} вернет "DB Error").
\end{important}

\section{Механика повторного выброса (Rethrow)}

Частый сценарий: перехватить ошибку, залогировать её и пробросить дальше для обработки на уровне выше. Здесь существует критическая разница между \texttt{throw e;} и \texttt{throw;}.

\subsection{Ошибочный проброс (throw e)}

\begin{cppcode}
try {
    // ... код ...
} catch (const ErrorBase& e) {
    log_error(e);
    throw e; // ОШИБКА: Повторная срезка!
}
\end{cppcode}

Даже если \texttt{e} — это ссылка на \texttt{DatabaseError}, инструкция \texttt{throw e} создает \textit{новый} объект исключения. Тип этого нового объекта определяется статическим типом переменной \texttt{e} (то есть \texttt{ErrorBase}). Мы снова теряем информацию о том, что это была ошибка базы данных.

\subsection{Корректный проброс (throw)}

\begin{cppcode}
try {
    // ... код ...
} catch (const ErrorBase& e) {
    log_error(e);
    throw; // КОРРЕКТНО: Проброс текущего активного исключения
}
\end{cppcode}

Инструкция \texttt{throw;} (без аргументов) сообщает Runtime: «Возьми тот самый объект исключения, который сейчас обрабатывается (со всеми его полиморфными свойствами), и запусти процесс раскрутки стека дальше». Копирования не происходит, тип сохраняется.

\section{Транспортировка исключений между потоками}

Исключения привязаны к стеку текущего потока (Thread Local). Вы не можете выбросить исключение в одном потоке и автоматически поймать его в другом (например, в \texttt{main}).

Для решения этой задачи в C++11 был введен механизм захвата и транспортировки исключений: \texttt{std::exception\_ptr}.

Это «умный указатель» (аналог \texttt{std::shared\_ptr}) для объектов исключений. Он копирует (или продлевает жизнь) объекту исключения, позволяя сохранить его в переменную и передать в другой контекст.

\subsection{Основные примитивы}

\begin{enumerate}
    \item \texttt{std::current\_exception()} — вызывается внутри блока \texttt{catch}. Возвращает \texttt{std::exception\_ptr}, указывающий на текущую ошибку. Если исключений нет, возвращает \texttt{nullptr}.
    \item \texttt{std::rethrow\_exception(ptr)} — принимает указатель и выбрасывает исключение заново.
\end{enumerate}

\subsection{Реализация паттерна Worker-Result}

Рассмотрим, как это работает на примере самодельного аналога \texttt{std::future}:

\begin{cppcode}[]
#include <exception>
#include <thread>
#include <iostream>

std::exception_ptr globalException = nullptr;

void worker() {
    try {
        // Имитация работы
        throw std::runtime_error("Failure in worker thread");
    } catch (...) {
        // 1. Не знаем тип исключения, но можем его захватить
        globalException = std::current_exception(); 
        // Теперь объект исключения живет в куче и удерживается указателем
    }
}

int main() {
    std::thread t(worker);
    t.join();

    if (globalException) {
        try {
            // 2. Пробрасываем захваченное исключение в текущем потоке
            std::rethrow_exception(globalException);
        } catch (const std::exception& e) {
            std::cout << "Caught from worker: " << e.what() << "\n";
        }
    }
    return 0;
}
\end{cppcode}

\begin{note}
\texttt{std::exception\_ptr} корректно работает с любыми типами исключений, даже если они не наследники \texttt{std::exception} (например, \texttt{throw 42;}). Однако, чтобы обработать их после \texttt{rethrow\_exception}, вам все равно понадобится соответствующий \texttt{catch}.
\end{note}

\begin{summary}
\begin{itemize}
    \item Объекты исключений живут в специальной области памяти (не стек), их время жизни управляется Runtime.
    \item Перехват по значению (\texttt{catch (Base e)}) разрушает полиморфизм (Object Slicing). Всегда используйте ссылки.
    \item Для проброса исключения используйте \texttt{throw;} (без аргументов), чтобы избежать повторной срезки.
    \item Для передачи ошибок между потоками используйте пару \texttt{std::current\_exception} и \texttt{std::rethrow\_exception}.
\end{itemize}
\end{summary}
