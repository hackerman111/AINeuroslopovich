\chapter{Механика исключений: Stack Unwinding и Гарантии}

Механизм исключений в C++ — это не просто альтернатива кодам возврата, а сложная инфраструктура времени выполнения (Runtime), тесно связанная с управлением памятью и временем жизни объектов. Понимание процесса «раскрутки стека» (Stack Unwinding) критически важно для написания корректного C++ кода.

\section{Анатомия раскрутки стека (Stack Unwinding)}

Когда оператор \texttt{throw} выбрасывает исключение, программа перестает выполняться линейно. Среда выполнения (C++ Runtime) начинает процесс поиска подходящего обработчика (\texttt{catch}), поднимаясь вверх по стеку вызовов. Этот процесс называется \textbf{Stack Unwinding}.

Ключевая особенность этого процесса: по мере выхода из каждой функции (scope), Runtime обязан корректно уничтожить все локальные объекты, созданные на стеке в этом блоке. Для каждого такого объекта вызывается деструктор.

\begin{definition}{RAII (Resource Acquisition Is Initialization)}
Именно гарантия вызова деструкторов при раскрутке стека делает возможной идиому RAII. Если ресурс (память, файл, мьютекс) обернут в объект с деструктором, исключение не приведет к утечке. Если же используется «сырой» \texttt{new} без \texttt{delete} (который мог бы стоять далее по коду, но выполнение перепрыгнуло его), произойдет утечка памяти.
\end{definition}

Рассмотрим класс \texttt{Noisy}, который сообщает о своем рождении и смерти:

\begin{cppcode}[]
#include <iostream>

struct Noisy {
    int id;
    Noisy(int i) : id(i) { 
        std::cout << "Ctor " << id << "\n"; 
    }
    ~Noisy() { 
        std::cout << "Dtor " << id << "\n"; 
    }
};

void func() {
    Noisy n1(1);
    Noisy n2(2);
    throw std::runtime_error("Error");
    // Сюда управление никогда не дойдет
    // Деструкторы n2 и n1 будут вызваны автоматически
}
\end{cppcode}

При вызове \texttt{func()} вывод будет следующим:
\begin{verbatim}
Ctor 1
Ctor 2
Dtor 2  <-- Обратный порядок уничтожения
Dtor 1
\end{verbatim}

Runtime гарантирует, что объекты уничтожаются строго в порядке, обратном их созданию (LIFO — Last In, First Out). Это важно, так как объект \texttt{n2} может зависеть от \texttt{n1}.

\section{Деструкторы и спецификатор noexcept}

До стандарта C++11 деструкторы могли выбрасывать исключения так же, как и любые другие функции. Однако практика показала, что это приводит к фатальным ошибкам в архитектуре приложений.

В современном C++ действует правило:
\begin{important}
Начиная с C++11, все деструкторы по умолчанию неявно помечены как \texttt{noexcept(true)}.
\end{important}

Это означает, что если вы попытаетесь выбросить исключение из деструктора и оно вылетит за его пределы, программа немедленно завершится вызовом \texttt{std::terminate()}.

Почему принято такое жесткое решение? Ответ кроется в механике взаимодействия двух исключений.

\section{Катастрофа Double Fault: std::terminate}

Представьте ситуацию:
1.  В блоке \texttt{try} происходит ошибка, выбрасывается исключение \texttt{E1}.
2.  Начинается раскрутка стека (Stack Unwinding).
3.  Runtime находит на стеке локальный объект и вызывает его деструктор.
4.  Внутри деструктора происходит сбой, и выбрасывается новое исключение \texttt{E2}, которое вылетает наружу.

В этот момент в одном потоке существуют два активных (unhandled) исключения: \texttt{E1} (которое еще не поймано) и \texttt{E2} (которое только что возникло). C++ Runtime не умеет обрабатывать две ошибки одновременно — непонятно, какую из них доставлять в \texttt{catch}, и как продолжать раскрутку.

\textbf{Результат:} Процесс немедленно убивается через \texttt{std::terminate()}. Никакие \texttt{catch} блоки не срабатывают, деструкторы остальных объектов не вызываются.

Пример кода «смертника»:

\begin{cppcode}
struct Bomb {
    ~Bomb() {
        // Попытка выбросить исключение из деструктора
        throw std::runtime_error("Boom in dtor"); 
    }
};

int main() {
    try {
        Bomb b;
        // 1. Бросаем первичное исключение
        throw std::logic_error("Primary error");
        
        // 2. Начинается unwinding. Вызывается ~Bomb().
        // 3. Из ~Bomb вылетает "Boom".
        // 4. ДВА исключения -> std::terminate().
    } catch (...) {
        std::cout << "Never printed\n";
    }
}
\end{cppcode}

Если убрать \texttt{throw "Primary error"}, программа все равно упадет (из-за \texttt{noexcept} по умолчанию на деструкторе), но уже по причине нарушения спецификации \texttt{noexcept}, а не из-за Double Fault. Если же явно пометить деструктор \texttt{noexcept(false)}, то одиночное исключение сработает, но двойное все равно убьет процесс.

\section{Проблема очистки ресурсов (на примере std::ofstream)}

Классический пример конфликта RAII и обработки ошибок — закрытие файла.

\begin{cppcode}
class FileWriter {
    std::ofstream file;
public:
    ~FileWriter() {
        file.close(); // Может вернуть ошибку или кинуть исключение (если включено)
    }
};
\end{cppcode}

Операция \texttt{close()} включает сброс буферов на диск (flush). Если диск переполнен, \texttt{close()} завершится с ошибкой.
\begin{itemize}
    \item Если деструктор игнорирует ошибку (глотает исключение), пользователь теряет данные, не узнав об этом.
    \item Если деструктор выбрасывает исключение, программа рискует упасть с \texttt{std::terminate}, если \texttt{FileWriter} уничтожался в процессе обработки другой ошибки.
\end{itemize}

\textbf{Решение:} Предоставить явный метод \texttt{close()}, а в деструкторе оставить «аварийную» логику.

\begin{cppcode}
void manual_close() {
    file.close();
    if (file.fail()) throw std::ios_base::failure("Write failed");
}

~FileWriter() {
    try {
        if (file.is_open()) file.close();
    } catch (...) {
        // Логируем, но НЕ бросаем дальше
        std::cerr << "Error closing file in dtor\n";
    }
}
\end{cppcode}

Это компромисс: ответственный пользователь вызывает \texttt{manual\_close()} и обрабатывает ошибки. Забывчивый пользователь полагается на деструктор, который гарантирует отсутствие утечек дескрипторов, но может "проглотить" ошибку записи.

\section{Проверка активных исключений: std::uncaught\_exceptions}

Иногда действительно необходимо выполнить опасную операцию в деструкторе, но только если это безопасно (т.е. если мы не находимся в процессе раскрутки стека).

Для этого существует функция \texttt{std::uncaught\_exceptions()} (обратите внимание на множественное число, C++17). Она возвращает количество активных исключений в текущем потоке.

\begin{note}
В C++98 существовала функция \texttt{std::uncaught\_exception()} (единственное число), возвращавшая \texttt{bool}. Она была признана архитектурно ошибочной и удалена в C++20, так как не позволяла корректно работать во вложенных сценариях (например, когда одно исключение уже обрабатывается, и внутри \texttt{catch} бросается новое).
\end{note}

Паттерн безопасного выброса из деструктора (используется крайне редко, например, в транзакционной памяти или сложных базах данных):

\begin{cppcode}
class Transaction {
public:
    ~Transaction() noexcept(false) { // Разрешаем исключения
        if (std::uncaught_exceptions() == 0) {
            // Стек спокоен, можно кидать исключения.
            // Например, коммит транзакции, который может упасть.
            commit_or_throw();
        } else {
            // Мы уже летим из-за ошибки.
            // Кидать новое нельзя -> terminate.
            // Поэтому делаем только безопасный откат.
            rollback_silent();
        }
    }
};
\end{cppcode}

\begin{summary}
\begin{enumerate}
    \item \textbf{Stack Unwinding} — механизм автоматического вызова деструкторов при возникновении исключения. Это основа RAII.
    \item \textbf{Деструкторы по умолчанию noexcept}. Выброс исключения из деструктора при наличии другого активного исключения приводит к \texttt{std::terminate}.
    \item Не стройте логику программы на исключениях в деструкторах. Деструктор должен заниматься освобождением ресурсов, которое (в идеале) не должно фейлиться.
    \item Если необходимо сообщить об ошибке при закрытии ресурса, используйте отдельный метод (например, \texttt{close()}) и вызывайте его явно перед разрушением объекта.
\end{enumerate}
\end{summary}
