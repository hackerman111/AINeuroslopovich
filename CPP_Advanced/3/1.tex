\chapter{Механика перемещения и специальные функции класса}

Современный C++ (начиная с C++11) ввел концепцию Move Semantics (семантика перемещения), которая фундаментально изменила подход к управлению ресурсами. Если раньше передача тяжелого объекта (например, \texttt{std::vector} на гигабайт данных) означала глубокое копирование, то теперь мы можем передать владение ресурсом за константное время. В этой главе мы детально разберем, как реализовать перемещающие операции, как избежать распространенных ошибок и как компилятор генерирует (или удаляет) специальные функции класса.

\section{Анатомия Move Assignment Operator}

Оператор перемещающего присваивания (\texttt{move assignment operator}) — это специальная функция-член класса, которая вызывается, когда объекту присваивается \textit{rvalue} того же типа. В отличие от копирующего присваивания, цель этой операции — не дублировать ресурс, а \textit{украсть} его у временного объекта, оставив последний в состоянии, пригодном для безопасного уничтожения.

\subsection{Паттерн реализации идиомы copy-and-swap}

Один из классических способов реализации операторов присваивания — идиома \textbf{copy-and-swap} (в контексте move — скорее \textit{move-and-swap}). Она выглядит следующим образом:

\begin{cppcode}[]
class Holder {
public:
    // ... конструкторы ...

    // Move assignment
    Holder& operator=(Holder&& other) noexcept {
        // Меняем местами текущее состояние с состоянием other
        swap(*this, other);
        return *this;
    }

private:
    void swap(Holder& a, Holder& b) {
        // ... реализация обмена полей ...
    }
};
\end{cppcode}

\begin{note}
\textbf{Механика:} При вызове \texttt{swap}, текущий ресурс объекта (который нужно уничтожить) перемещается в \texttt{other}, а ресурс из \texttt{other} перемещается в \texttt{*this}. Поскольку \texttt{other} — это \textit{rvalue}, который скоро будет уничтожен, он заберет старый ресурс нашего объекта с собой в могилу (вызовет деструктор).
\end{note}

Однако, у этого подхода есть недостатки:
\begin{enumerate}
    \item \textbf{Лишняя работа:} \texttt{swap} выполняет три перемещения (A -> tmp, B -> A, tmp -> B). Для простого присваивания это может быть избыточно.
    \item \textbf{Отложенное уничтожение:} Старый ресурс уничтожается не сразу, а только когда будет вызван деструктор \texttt{other}. Это может быть критично, если ресурс удерживает, например, файловый дескриптор или мьютекс.
\end{enumerate}

\subsection{Оптимизированная реализация через std::exchange}

Более современный и эффективный подход — использование \texttt{std::exchange} (C++14). Эта функция заменяет значение объекта новым и возвращает старое. Это позволяет реализовать перемещение "в одну строчку" с четкой семантикой передачи владения.

\begin{cppcode}[]
#include <utility> // для std::exchange

class Buffer {
    char* data_ = nullptr;
    size_t size_ = 0;

public:
    // ...

    Buffer& operator=(Buffer&& other) noexcept {
        if (this == &other) {
            return *this; // Защита от self-assignment
        }

        // 1. Освобождаем текущий ресурс
        delete[] data_;

        // 2. Забираем ресурс у other и "зануляем" его
        data_ = std::exchange(other.data_, nullptr);
        size_ = std::exchange(other.size_, 0);

        return *this;
    }
};
\end{cppcode}

В этом коде \texttt{std::exchange(other.data\_, nullptr)} делает следующее:
\begin{enumerate}
    \item Читает текущее значение \texttt{other.data\_}.
    \item Присваивает \texttt{other.data\_} значение \texttt{nullptr}.
    \item Возвращает прочитанное (старое) значение, которое мы записываем в \texttt{this->data\_}.
\end{enumerate}

Это устраняет промежуточные свопы и гарантирует, что объект-источник (\texttt{other}) останется в пустом состоянии.

\subsection{Проблема Self-Assignment (Самоприсваивание)}

В копирующем присваивании проверка \texttt{if (this == \&other)} обязательна, чтобы не удалить свой собственный ресурс перед копированием. В перемещающем присваивании ситуация тоньше.

\begin{important}
Если вы используете реализацию через \texttt{swap}, самоприсваивание безопасно (своп объекта с самим собой ничего не ломает), но бесполезно тратит такты процессора. Если вы используете прямую реализацию с \texttt{delete[] data\_}, то без проверки \texttt{if (this == \&other)} вы удалите ресурс, который собираетесь переместить в себя же -> \textbf{Undefined Behavior} (use-after-free).
\end{important}

Хотя самоприсваивание rvalue (написание \texttt{x = std::move(x)}) — это редкая и странная операция, корректная реализация должна её обрабатывать. Стандартная библиотека требует, чтобы объекты были устойчивы к самоприсваиванию.

\section{Концепция "Moved-from state"}

Когда мы перемещаем данные из объекта (источника), он остается в состоянии, которое стандарт называет \textbf{"valid but unspecified state"} (валидное, но неопределенное).

\begin{definition}{Moved-from state}
Объект, из которого переместили данные, должен находиться в таком состоянии, что:
\begin{itemize}
    \item Его деструктор отработает корректно (не упадет, не сделает double free).
    \item Ему можно присвоить новое значение (оператор присваивания сработает корректно).
    \item Значение его полей не гарантировано (если явно не оговорено классом).
\end{itemize}
\end{definition}

Рассмотрим пример "плохого" перемещения:

\begin{cppcode}
class BadString {
    char* str;
public:
    BadString(BadString&& other) {
        // Мы скопировали указатель...
        this->str = other.str;
        // ...НО ЗАБЫЛИ занулить other.str!
    }

    ~BadString() {
        delete[] str;
    }
};
\end{cppcode}

В этом случае, когда \texttt{other} выйдет из области видимости, его деструктор удалит память по адресу \texttt{str}. Позже деструктор нашего нового объекта снова попытается удалить \texttt{str}. Это классический \textbf{double free}.

Правило: **Всегда оставляйте источник в состоянии, безопасном для разрушения (обычно это null pointers, zero size).**

\section{Rule of 5 vs Rule of 0}

C++11 расширил "Правило трех" (Rule of 3) до "Правила пяти" (Rule of 5) из-за добавления семантики перемещения.

\begin{enumerate}
    \item \textbf{Деструктор}
    \item \textbf{Копирующий конструктор}
    \item \textbf{Копирующий оператор присваивания}
    \item \textbf{Перемещающий конструктор}
    \item \textbf{Перемещающий оператор присваивания}
\end{enumerate}

\subsection{Rule of 5}
Если классу требуется ручное управление ресурсом (например, сырой указатель, дескриптор файла), вы, скорее всего, должны реализовать (или явно объявить) все 5 специальных функций.

\begin{cppcode}[]
class ResourceManager {
    Resource* res;
public:
    ~ResourceManager() { delete res; } // 1

    ResourceManager(const ResourceManager& other) { ... } // 2
    ResourceManager& operator=(const ResourceManager& other) { ... } // 3

    ResourceManager(ResourceManager&& other) noexcept { ... } // 4
    ResourceManager& operator=(ResourceManager&& other) noexcept { ... } // 5
};
\end{cppcode}

\subsection{Rule of 0}
Если ваш класс не управляет ресурсами напрямую, а использует RAII-обертки (\texttt{std::string}, \texttt{std::vector}, \texttt{std::unique\_ptr}), вам \textbf{не нужно} писать ни одну из специальных функций. Компилятор сгенерирует их автоматически и корректно.

\begin{important}
\textbf{Rule of 0} — предпочтительный подход. Это принцип "Пиши меньше кода". Если вы можете выразить семантику класса через комбинацию стандартных типов, делайте это.
\end{important}

\subsection{Implicit Deletion (Неявное удаление)}

Правила генерации специальных функций в C++ довольно запутаны. Одно из важнейших правил:

\begin{note}
Если вы объявляете (или определяете) любую перемещающую операцию (конструктор или оператор присваивания), то \textbf{копирующие операции неявно удаляются} (становятся \texttt{delete}).
\end{note}

Это сделано для безопасности: если класс поддерживает перемещение, скорее всего, он владеет уникальным ресурсом (как \texttt{unique\_ptr}), который нельзя просто скопировать.

Пример ловушки:

\begin{cppcode}[]
class Widget {
public:
    Widget(Widget&&) noexcept; // Пользовательский move ctor
    // Copy ctor неявно удален!
    // Copy assignment неявно удален!
    // Move assignment не объявлен (но и не удален, просто не сгенерирован)
};

void func() {
    Widget w1;
    Widget w2 = w1; // ОШИБКА КОМПИЛЯЦИИ: call to deleted constructor
}
\end{cppcode}

Если вы хотите вернуть копирование, вы должны объявить его явно:
\texttt{Widget(const Widget\&) = default;}

\section{noexcept в перемещающих операциях}

Ключевое слово \texttt{noexcept} критически важно для производительности перемещения, особенно при работе со стандартными контейнерами, такими как \texttt{std::vector}.

\subsection{Проблема транзакционности вектора}

Рассмотрим, что происходит, когда \texttt{std::vector} исчерпывает свою емкость (\texttt{capacity}) и должен расшириться:
1. Выделяется новый, больший буфер памяти.
2. Элементы переносятся из старого буфера в новый.
3. Старый буфер удаляется.

В C++98 элементы всегда копировались. Если при копировании $N$-го элемента возникало исключение, вектор просто уничтожал уже созданные копии в новом буфере и освобождал его. Старый буфер оставался нетронутым. Это обеспечивало \textbf{Strong Exception Guarantee} (строгую гарантию исключений): операция либо выполняется полностью, либо не меняет состояние программы.

В C++11 мы хотим перемещать элементы (это дешевле). Но если перемещающий конструктор кинет исключение на $N$-м элементе, мы оказываемся в беде:
\begin{itemize}
    \item Часть элементов уже перемещена в новый буфер.
    \item Их "оригиналы" в старом буфере теперь находятся в \textit{moved-from state} (по сути, разрушены или пусты).
    \item Мы не можем "откатить" операцию, потому что обратное перемещение тоже может кинуть исключение!
    \item Данные безвозвратно потеряны.
\end{itemize}

\subsection{std::move\_if\_noexcept}

Чтобы сохранить Строгую гарантию исключений, \texttt{std::vector} использует утилиту \texttt{std::move\_if\_noexcept}. Логика при реаллокации следующая:

\begin{itemize}
    \item Если перемещающий конструктор типа элемента помечен как \texttt{noexcept}, вектор использует перемещение.
    \item Если \texttt{noexcept} нет, вектор \textbf{откатывается к копированию} (использует copy constructor), даже если доступен move constructor.
    \item Если тип \textit{move-only} (как \texttt{unique\_ptr}) и не \texttt{noexcept}, вектор не дает гарантий безопасности исключений (или не компилируется, в зависимости от реализации).
\end{itemize}

\begin{important}
Если вы забыли написать \texttt{noexcept} у перемещающего конструктора, ваш код будет компилироваться и работать, но \texttt{std::vector<MyType>} будет работать \textbf{медленно}, выполняя глубокое копирование при каждом расширении. Это "тихий убийца производительности".
\end{important}

\begin{cppcode}[]
class FastWidget {
public:
    // Обязательно noexcept!
    FastWidget(FastWidget&&) noexcept { /* ... */ }
    
    // Аналогично для присваивания
    FastWidget& operator=(FastWidget&&) noexcept { /* ... */ }
};
\end{cppcode}

\subsection{Техническое отступление: noexcept оператор}

В C++ \texttt{noexcept} — это не только спецификатор, но и оператор, который возвращает \texttt{bool} на этапе компиляции. Он проверяет, может ли выражение теоретически кинуть исключение.

\begin{cppcode}[]
template <typename T>
class Wrapper {
    T value;
public:
    // Move ctor является noexcept ТОЛЬКО если T имеет noexcept move ctor
    Wrapper(Wrapper&& other) noexcept(std::is_nothrow_move_constructible_v<T>)
        : value(std::move(other.value)) {}
};
\end{cppcode}

Это позволяет создавать гибкие шаблоны, которые транслируют гарантии исключений вложенных типов.

