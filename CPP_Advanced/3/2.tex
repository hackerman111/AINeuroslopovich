\chapter{Универсальные ссылки и идеальная передача (Perfect Forwarding)}

В предыдущей главе мы обсуждали rvalue-ссылки (\texttt{T\&\&}) как инструмент для реализации семантики перемещения. Однако в шаблонах C++ синтаксис \texttt{T\&\&} приобретает совершенно иное значение. Это одна из самых запутанных тем для новичков: одни и те же символы могут означать "rvalue-ссылка" или "универсальная ссылка" (Universal Reference), в зависимости от контекста.

В этой главе мы разберем механику вывода типов, правила схлопывания ссылок (Reference Collapsing) и современные способы работы с квалификаторами значений, включая нововведения C++23.

\section{Универсальные ссылки (Forwarding References)}

Термин "Universal Reference" был введен Скоттом Мейерсом, но в стандарте C++ он называется \textbf{Forwarding Reference}. Это ссылка, которая может вести себя и как lvalue-ссылка, и как rvalue-ссылка, в зависимости от того, чем она инициализирована.

\begin{definition}{Универсальная ссылка}
Ссылка является универсальной только при выполнении двух условий одновременно:
\begin{enumerate}
    \item Вывод типа (\textit{type deduction}) происходит именно для этой переменной.
    \item Переменная объявлена строго как \texttt{T\&\&} (где \texttt{T} — имя шаблонного параметра).
\end{enumerate}
\end{definition}

Рассмотрим разницу на примерах:

\begin{cppcode}[]
// 1. Обычная Rvalue-ссылка
void func(Widget&& w); // Тип Widget конкретен, вывода типов нет.
                       // Принимает ТОЛЬКО rvalue.

// 2. Универсальная ссылка
template <typename T>
void wrapper(T&& arg); // T выводится компилятором.
                       // Принимает И lvalue, И rvalue.

// 3. Подвох: это НЕ универсальная ссылка
template <typename T>
void vector_push(std::vector<T>&& v); // T выводится, но вид ссылки
                                      // искажен (vector<T>&&).
                                      // Это rvalue-ссылка на вектор.

// 4. Еще подвох: const убивает универсальность
template <typename T>
void const_wrapper(const T&& arg); // const T&& — это всегда rvalue-ссылка,
                                   // но только на const объекты.
\end{cppcode}

Главное свойство универсальной ссылки: она "впитывает" категорию значения (value category) переданного аргумента.

\section{Математика ссылок: Reference Collapsing}

Как компилятор понимает, во что превратить \texttt{T\&\&}? Здесь вступает в силу правило \textbf{схлопывания ссылок} (Reference Collapsing).

В C++ запрещено создавать "ссылку на ссылку" явно (нельзя написать \texttt{int\& \& x}), но компилятор может сгенерировать такую конструкцию в процессе инстанцирования шаблона. Когда это происходит, две ссылки объединяются в одну по строгим правилам.

Пусть мы передаем аргумент в функцию \texttt{template <typename T> void f(T\&\& param)}.

\begin{enumerate}
    \item \textbf{Сценарий 1: Передаем lvalue (например, int x).}
    Компилятор выводит \texttt{T} как \texttt{int\&} (lvalue-ссылка).
    Подставляем в сигнатуру \texttt{T\&\&}:
    $$ \texttt{int\&} + \texttt{\&\&} \rightarrow \texttt{int\&} $$
    \textit{Результат:} Функция принимает lvalue-ссылку.

    \item \textbf{Сценарий 2: Передаем rvalue (например, 42).}
    Компилятор выводит \texttt{T} как \texttt{int} (не ссылка).
    Подставляем в сигнатуру \texttt{T\&\&}:
    $$ \texttt{int} + \texttt{\&\&} \rightarrow \texttt{int\&\&} $$
    \textit{Результат:} Функция принимает rvalue-ссылку.
\end{enumerate}

Полная таблица правил схлопывания (где левая часть — тип \texttt{T}, правая — спецификатор параметра):

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Тип T} & \textbf{Спецификатор} & \textbf{Результат} \\ \hline
\texttt{type\&} & \texttt{\&} & \texttt{type\&} \\
\texttt{type\&} & \texttt{\&\&} & \texttt{type\&} \\
\texttt{type\&\&} & \texttt{\&} & \texttt{type\&} \\
\texttt{type\&\&} & \texttt{\&\&} & \texttt{type\&\&} \\ \hline
\end{tabular}
\caption{Правила Reference Collapsing}
\end{table}

\begin{important}
Интуитивное правило: \textbf{Lvalue-ссылка заразна}. Если в уравнении появляется хотя бы один одиночный амперсанд (\texttt{\&}), результат всегда будет lvalue-ссылкой. Rvalue-ссылка получается только из комбинации двух двойных амперсандов (или типа без ссылок + \texttt{\&\&}).
\end{important}

\section{Идеальная передача: std::forward vs std::move}

Универсальные ссылки чаще всего используются для \textit{Perfect Forwarding} — передачи аргументов в другую функцию с сохранением их категории (lvalue остается lvalue, rvalue остается rvalue).

\subsection{Почему нельзя использовать std::move?}

Рассмотрим, что произойдет, если мы применим \texttt{std::move} к универсальной ссылке.

\begin{cppcode}[]
void process(const Widget& lval) { std::cout << "Lvalue processed\n"; }
void process(Widget&& rval)      { std::cout << "Rvalue processed\n"; }

template <typename T>
void log_and_call(T&& arg) {
    std::cout << "Logging...\n";
    // ОШИБКА! std::move безусловно кастит к rvalue!
    process(std::move(arg));
}

int main() {
    Widget w;
    log_and_call(w); // Мы передаем lvalue...
}
\end{cppcode}

В примере выше:
1. Вызывается \texttt{log\_and\_call(w)}. \texttt{T} выводится как \texttt{Widget\&}.
2. \texttt{arg} имеет тип \texttt{Widget\&}.
3. \texttt{std::move(arg)} кастит его к \texttt{Widget\&\&} (rvalue).
4. Вызывается перегрузка \texttt{process(Widget\&\&)}.
5. \textbf{Результат:} Мы передали в функцию живой lvalue объект \texttt{w}, но функция \texttt{process} считает его временным и может "украсть" его данные. После возврата из \texttt{log\_and\_call} объект \texttt{w} может оказаться пустым. Это катастрофа.

\subsection{Решение: std::forward}

Для решения этой проблемы используется \texttt{std::forward<T>}. В отличие от \texttt{std::move}, который делает \textit{безусловный} каст, \texttt{std::forward} делает \textit{условный} каст.

\begin{itemize}
    \item Если \texttt{T} — lvalue-ссылка, \texttt{forward} возвращает lvalue.
    \item Если \texttt{T} — не ссылка (или rvalue-ссылка), \texttt{forward} возвращает rvalue.
\end{itemize}

\begin{cppcode}[]
template <typename T>
void log_and_call(T&& arg) {
    std::cout << "Logging...\n";
    // T передается явно как параметр шаблона forward
    process(std::forward<T>(arg));
}
\end{cppcode}

Теперь при вызове \texttt{log\_and\_call(w)} (lvalue), \texttt{std::forward} вернет \texttt{Widget\&}, и вызовется безопасная перегрузка. При вызове \texttt{log\_and\_call(Widget())} (rvalue), вернется \texttt{Widget\&\&}, и ресурсы будут эффективно перемещены.

\section{Ref-qualifiers: Перегрузка методов для *this}

Иногда нам нужно знать категорию значения не аргумента, а самого объекта, у которого вызывается метод (\texttt{*this}). Это особенно актуально для паттерна \textbf{Builder} или для оптимизации геттеров.

До C++11 мы могли перегружать методы только по \texttt{const}. C++11 добавил \textbf{Ref-qualifiers}: возможность указывать \texttt{\&} или \texttt{\&\&} после списка аргументов метода.

\subsection{Пример: Паттерн Builder}

Представим построитель сложного объекта (например, поискового индекса).

\begin{cppcode}[]
class IndexBuilder {
    std::vector<int> data;
public:
    void add(int x) { data.push_back(x); }

    // Возвращаем результат
    std::vector<int> finish() {
        return data; // Копирование! (или NRVO)
    }
};
\end{cppcode}

Мы хотим, чтобы метод \texttt{finish()} перемещал данные, если \texttt{Builder} является временным объектом, и копировал, если долгоживущим.

\begin{cppcode}[]
class EfficientBuilder {
    std::vector<int> data;
public:
    void add(int x) { data.push_back(x); }

    // Версия для lvalue (долгоживущий объект): копируем
    std::vector<int> finish() & {
        return data; 
    }

    // Версия для rvalue (временный объект): перемещаем
    std::vector<int> finish() && {
        return std::move(data);
    }
};

void usage() {
    EfficientBuilder b;
    b.add(1);
    
    // Вызывается finish() & -> копирование
    auto v1 = b.finish(); 

    // Вызывается finish() && -> перемещение
    // b становится пустым, но это безопасно, так как мы сделали move(b)
    auto v2 = std::move(b).finish(); 
    
    // Строим и сразу забираем -> перемещение
    auto v3 = EfficientBuilder().finish();
}
\end{cppcode}

Это мощный механизм, но он имеет недостаток: дублирование кода. Если логика метода сложная, нам приходится писать две (или четыре, с учетом \texttt{const}) почти одинаковые функции.

\section{C++23: Deducing This}

Стандарт C++23 представил революционное изменение в синтаксисе методов классов, названное \textbf{Deducing This} (или \textit{Explicit Object Parameter}).

Теперь мы можем явно объявить параметр, который будет представлять \texttt{this}, и сделать его шаблонным. Это позволяет "выводить" категорию значения самого объекта и использовать \textbf{Perfect Forwarding} для \texttt{*this}.

Синтаксис выглядит так: первым параметром метода идет \texttt{this Self\&\& self}.

\subsection{Упрощение Ref-qualifiers}

Перепишем пример с \texttt{EfficientBuilder} на C++23. Вместо двух функций нам понадобится одна.

\begin{cppcode}[]
#include <vector>
#include <utility> // для std::forward

class ModernBuilder {
    std::vector<int> data;
public:
    void add(int x) { data.push_back(x); }

    // Единый шаблонный метод
    // Self выведется как ModernBuilder& (для lvalue)
    // или ModernBuilder (для rvalue)
    template <typename Self>
    auto finish(this Self&& self) {
        // self — это наш *this, но теперь это обычный аргумент.
        // Мы можем применить std::forward к самому объекту!
        
        // forward_like - новая утилита C++23, аналогичная forward,
        // но применяющая категорию self к полю data.
        return std::forward<Self>(self).data; 
    }
};
\end{cppcode}

\begin{note}
\textbf{Как это работает:}
\begin{enumerate}
    \item Если мы зовем \texttt{b.finish()} (где \texttt{b} — lvalue), \texttt{Self} выводится как \texttt{ModernBuilder\&}. \texttt{std::forward} возвращает ссылку, происходит копирование вектора.
    \item Если мы зовем \texttt{std::move(b).finish()}, \texttt{Self} выводится как \texttt{ModernBuilder}. \texttt{std::forward} кастит \texttt{self} к rvalue. При доступе к \texttt{.data} мы получаем rvalue-доступ к полю, и срабатывает move-конструктор возвращаемого значения.
\end{enumerate}
\end{note}

\textbf{Преимущества Deducing This:}
\begin{itemize}
    \item \textbf{Дедупликация:} Одна реализация вместо 4-х (const/non-const, \&/\&\&).
    \item \textbf{Рекурсивные лямбды:} Теперь лямбда может легко ссылаться на саму себя через явный параметр \texttt{this auto\&\& self}.
    \item \textbf{CRTP:} Паттерн Curiously Recurring Template Pattern становится проще, так как в базовом классе можно принимать \texttt{this Derived\&\& self} без приведения типов.
\end{itemize}

\begin{summary}
\begin{itemize}
    \item \texttt{T\&\&} в шаблонах — это \textbf{Forwarding Reference}, а не rvalue-ссылка.
    \item \texttt{std::forward} обязателен при передаче универсальных ссылок дальше по стеку вызовов.
    \item Правила \textbf{Reference Collapsing} гарантируют, что lvalue превращает всю цепочку ссылок в lvalue.
    \item C++23 \textbf{Deducing This} позволяет писать обобщенный код, который автоматически адаптируется к \texttt{const} и \texttt{rvalue/lvalue} состоянию объекта.
\end{itemize}
\end{summary}
