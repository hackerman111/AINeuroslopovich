\chapter{Фундаментальное управление памятью и RAII}

Управление памятью является краеугольным камнем системного программирования на C++. Понимание того, где и как хранятся объекты, определяет не только производительность приложения, но и его корректность. Данная глава посвящена анатомии памяти процесса, проблемам ручного управления ресурсами, идиоме RAII и современным механизмам эксклюзивного владения.

\section{1.1 Анатомия памяти процесса}

В контексте C++ модель памяти процесса операционной системы традиционно разделяется на четыре основных сегмента. Каждый из них имеет свои характеристики времени жизни объектов и накладных расходов на доступ.

\begin{itemize}
    \item \textbf{Стек (Stack, Automatic Storage Duration):} Область памяти, работающая по принципу LIFO (Last In, First Out). Выделение памяти сводится к изменению значения регистра указателя стека (Stack Pointer), что делает операции аллокации и деаллокации чрезвычайно быстрыми (наносекунды). Размер стека фиксирован и невелик (обычно 2–8 МБ), что делает его непригодным для хранения больших структур данных.
    
    \item \textbf{Куча (Heap, Dynamic Storage Duration):} Область памяти произвольного доступа. Управление осуществляется через системные вызовы (например, \texttt{malloc/new}). Аллокация требует поиска свободного блока памяти подходящего размера, что значительно медленнее стековых операций и может приводить к фрагментации памяти. Время жизни объектов здесь полностью контролируется программистом.
    
    \item \textbf{Статическая память (Static Storage Duration):} Предназначена для глобальных переменных и переменных, объявленных с модификатором \texttt{static}. Память выделяется при запуске программы и освобождается при ее завершении. Объекты инициализируются один раз.
    
    \item \textbf{Thread-Local Storage (TLS):} Специфическая область памяти, уникальная для каждого потока выполнения. Переменные с модификатором \texttt{thread\_local} существуют в течение времени жизни потока.
\end{itemize}

\section{1.2 Проблемы ручного управления памятью (C-style)}

В языке C и в "legacy" C++ коде управление динамической памятью осуществлялось вручную через пары функций \texttt{malloc/free} или операторов \texttt{new/delete}. Этот подход порождает класс критических ошибок, связанных с человеческим фактором.

\section{Утечки памяти и обработка ошибок}

При возникновении исключительной ситуации или преждевременном возврате из функции программист обязан гарантировать вызов функции освобождения ресурсов. В коде с множественными точками выхода это приводит к дублированию логики очистки или использованию запутанных конструкций \texttt{goto}.

Рассмотрим пример обработки ресурсов в стиле C:

\begin{cppcode}[]
void process_data() {
    int* buffer = (int*)malloc(1024 * sizeof(int));
    if (!buffer) return;

    if (!init_network()) {
        free(buffer); // Ручная очистка при ошибке
        return;
    }

    if (!compute_hash(buffer)) {
        close_network(); // Необходимо закрыть предыдущий ресурс
        free(buffer);    // И освободить память
        return;
    }

    // Основная логика
    free(buffer);
    close_network();
}
\end{cppcode}

Любое изменение логики (добавление нового ресурса или условия) требует модификации всех веток обработки ошибок, что экспоненциально увеличивает риск утечки ресурса (resource leak) или двойного освобождения (double free).

\section{1.3 Идиома RAII (Resource Acquisition Is Initialization)}

RAII — фундаментальная идиома C++, связывающая время жизни ресурса (памяти, файлового дескриптора, мьютекса) с временем жизни объекта на стеке.

\begin{definition}{RAII}
Захват ресурса происходит в конструкторе объекта, а освобождение — в его деструкторе. Поскольку деструкторы автоматических переменных гарантированно вызываются при выходе из области видимости (в том числе при раскрутке стека из-за исключения), утечки ресурсов становятся невозможными при корректном использовании.
\end{definition}

Пример RAII-обертки для файлового дескриптора C-style:

\begin{cppcode}[]
#include <cstdio>
#include <stdexcept>

class FileHandle {
    FILE* file_;

public:
    explicit FileHandle(const char* filename) {
        file_ = std::fopen(filename, "r");
        if (!file_) {
            throw std::runtime_error("Failed to open file");
        }
    }

    ~FileHandle() {
        if (file_) {
            std::fclose(file_); // Гарантированное закрытие
        }
    }

    // Запрет копирования для избежания double-close
    FileHandle(const FileHandle&) = delete;
    FileHandle& operator=(const FileHandle&) = delete;

    // Метод доступа
    FILE* get() const { return file_; }
};

void safe_processing() {
    FileHandle fh("data.txt"); 
    // ... работа с файлом ...
    throw std::runtime_error("Error"); 
    // Деструктор fh вызывается автоматически, файл закрывается.
}
\end{cppcode}

Механизм размотки стека (stack unwinding) гарантирует вызов деструкторов для всех полностью сконструированных объектов в блоке до передачи управления обработчику исключения.

\section{1.4 Механика new и delete}

В C++ операторы \texttt{new} и \texttt{delete} выполняют две задачи: управление памятью и управление временем жизни объекта.

\begin{itemize}
    \item \textbf{new expression:} 
    1. Вызывает функцию \texttt{operator new} для выделения "сырой" памяти (аналог \texttt{malloc}).
    2. Конструирует объект в этой памяти (вызывает конструктор).
    3. Возвращает типизированный указатель.

    \item \textbf{delete expression:}
    1. Вызывает деструктор объекта.
    2. Вызывает функцию \texttt{operator delete} для освобождения памяти (аналог \texttt{free}).
\end{itemize}

\begin{important}
C++ требует строгого соответствия форм аллокации и деаллокации:
\begin{itemize}
    \item \texttt{new T} $\rightarrow$ \texttt{delete ptr}
    \item \texttt{new T[]} $\rightarrow$ \texttt{delete[] ptr}
\end{itemize}
Смешивание этих форм (например, \texttt{delete} для массива) является Undefined Behavior.
\end{important}

\section{Undefined Behavior при смешивании new[] и delete}

Рассмотрим детально, почему следующий код вызывает неопределенное поведение, часто приводящее к повреждению кучи (heap corruption).

\begin{cppcode}[]
int* arr = new int[10];
delete arr; // ОШИБКА! UB
\end{cppcode}

При использовании \texttt{new[]}, компилятор и аллокатор должны сохранить информацию о количестве элементов массива, чтобы \texttt{delete[]} мог вызвать деструкторы для \textbf{каждого} элемента. Часто это реализуется путем записи размера массива в памяти непосредственно \textit{перед} адресом, возвращаемым пользователю (так называемый "cookie" или "overhead").

\begin{figure}[h]
\centering
\begin{tikzpicture}
    % Память
    \draw[fill=nordCodeBg] (0,0) rectangle (8,1) node[midway] {Элементы массива (User Data)};
    \draw[fill=nordRed!20] (-2,0) rectangle (0,1) node[midway] {Size (N)};
    
    % Указатели
    \draw[->, thick, nordBlue] (0, -0.5) -- (0, 0);
    \node[below] at (0, -0.5) {Указатель \texttt{arr}};
    
    \draw[->, thick, nordRed] (-2, -0.5) -- (-2, 0);
    \node[below] at (-2, -0.5) {Реальный адрес блока};

    \node[above] at (4, 1) {Layout памяти при \texttt{new[]}};
\end{tikzpicture}
\end{figure}

\textbf{Сценарий сбоя:}
\begin{enumerate}
    \item \texttt{new int[10]} выделяет блок памяти размером $10 \times \text{sizeof(int)} + \text{sizeof(size\_t)}$. Размер (10) записывается в начало, указатель сдвигается и возвращается программе.
    \item \texttt{delete arr} (без скобок) предполагает, что удаляется \textit{один} объект.
    \item Если тип тривиальный (как \texttt{int}), деструкторы не вызываются, но \texttt{operator delete} получает адрес \texttt{arr}. Аллокатор ожидает, что ему передадут \textit{реальный адрес начала блока} (который может быть сдвинут на размер cookie).
    \item Передача неверного адреса в функцию освобождения памяти ломает внутренние структуры аллокатора (free list, метаданные страниц), что приводит к падению программы не сразу, а при следующей аллокации (delayed crash).
\end{enumerate}

Для нетривиальных типов последствия еще хуже: вызывается деструктор только первого элемента, а остальные 9 объектов остаются несконструированными "зомби" или утекают, если они владели ресурсами.

\section{1.5 Умные указатели: std::unique\_ptr}

Стандарт C++11 ввел \texttt{std::unique\_ptr} как замену устаревшему \texttt{std::auto\_ptr} и сырым указателям. Это шаблонный класс, реализующий семантику эксклюзивного владения (exclusive ownership).

\begin{definition}{std::unique\_ptr<T>}
Обертка над сырым указателем, которая:
\begin{itemize}
    \item Гарантирует вызов \texttt{delete} (или \texttt{delete[]}) в деструкторе.
    \item Не имеет оверхеда по памяти (размер равен \texttt{sizeof(void*)}, если используется дефолтный удалитель).
    \item Запрещает копирование (конструктор копирования и оператор присваивания удалены).
    \item Разрешает перемещение (Move Semantics), передавая владение другому объекту.
\end{itemize}
\end{definition}

Специализация \texttt{std::unique\_ptr<T[]>} корректно обрабатывает массивы, автоматически вызывая \texttt{delete[]}.

\begin{cppcode}[]
// Безопасное владение массивом
std::unique_ptr<int[]> safe_arr(new int[10]); 
// При выходе из scope вызовется delete[]
\end{cppcode}

\section{1.6 std::make\_unique vs new}

Начиная с C++14, рекомендуется использовать фабричную функцию \texttt{std::make\_unique} вместо прямого использования оператора \texttt{new}.

\textbf{Проблема безопасности исключений:}

Рассмотрим вызов функции, принимающей два уникальных указателя:

\begin{cppcode}[]
void process(std::unique_ptr<A> a, std::unique_ptr<B> b);

// ОПАСНЫЙ ВЫЗОВ
process(std::unique_ptr<A>(new A()), std::unique_ptr<B>(new B()));
\end{cppcode}

C++ не гарантирует порядок вычисления аргументов функции. Возможна следующая последовательность операций компилятором:
\begin{enumerate}
    \item \texttt{new A()} $\rightarrow$ выделена память для A.
    \item \texttt{new B()} $\rightarrow$ \textbf{Выброшено исключение} (например, \texttt{std::bad\_alloc}).
    \item Конструктор \texttt{std::unique\_ptr<A>} еще не был вызван.
    \item Указатель на A теряется, происходит утечка памяти.
\end{enumerate}

\texttt{std::make\_unique} решает эту проблему, так как внутри функции создание объекта и оборачивание в умный указатель — это одна неразрывная операция.

\begin{cppcode}[]
// БЕЗОПАСНЫЙ ВЫЗОВ
process(std::make_unique<A>(), std::make_unique<B>());
\end{cppcode}

Кроме безопасности, \texttt{make\_unique} избавляет от дублирования типа (\texttt{unique\_ptr<T>(new T)}) и делает код чище (принцип DRY).

\begin{summary}
\begin{itemize}
    \item Используйте RAII для всех ресурсов.
    \item Избегайте сырых \texttt{new/delete}. Используйте \texttt{std::unique\_ptr} и \texttt{std::make\_unique}.
    \item Никогда не смешивайте скалярные и векторные формы \texttt{new/delete}.
    \item \texttt{std::unique\_ptr} — это "бесплатная" абстракция с точки зрения производительности, обеспечивающая строгую семантику владения.
\end{itemize}
\end{summary}
