\chapter{Продвинутые идиомы C++ и Архитектурные паттерны}

Завершая изучение семантики перемещения и управления памятью, мы рассмотрим продвинутые техники, которые позволяют выжать максимум из системы типов C++. Эти идиомы часто используются в библиотечном коде (например, STL или Boost) для оптимизации использования памяти и улучшения эргономики API.

\section{7.1 Ref-qualifiers (Квалификаторы ссылок для методов)}

Традиционно методы класса в C++ перегружались только по константности объекта (\texttt{this}):

\begin{cppcode}[]
struct Data {
    std::string value;
    const std::string& get() const { return value; } // Для const объектов
    std::string& get() { return value; }             // Для non-const объектов
};
\end{cppcode}

Однако, что если мы вызываем \texttt{get()} у временного объекта (rvalue)?

\begin{cppcode}[]
auto str = Data{"heavy_string"}.get();
\end{cppcode}

В данном случае вызовется неконстантная версия \texttt{get()}, которая вернет lvalue-ссылку на поле. Затем произойдет \textbf{копирование} строки в переменную \texttt{str}, так как lvalue-ссылка не позволяет применить move-семантику. И это несмотря на то, что сам объект \texttt{Data} является временным и будет уничтожен сразу после этой строки! Мы упускаем возможность "украсть" данные.

C++11 позволяет перегружать методы по категории значения объекта \texttt{*this}, используя синтаксис \texttt{\&} и \texttt{\&\&}.

\begin{cppcode}[]
struct ModernData {
    std::vector<int> heavy;

    // 1. Вызывается для lvalue (именованных объектов)
    // Мы вынуждены вернуть const reference (копирование на стороне клиента)
    const std::vector<int>& items() const& {
        return heavy;
    }

    // 2. Вызывается для rvalue (временных объектов)
    // Мы можем безопасно отдать ресурсы, так как объект скоро умрет
    std::vector<int> items() && {
        return std::move(heavy);
    }
};

void demo() {
    ModernData d;
    auto v1 = d.items();             // Вызов (1): Копирование (безопасно)
    
    auto v2 = ModernData{}.items();  // Вызов (2): Перемещение!
    // v2 забирает буфер у временного вектора. 0 копий.
}
\end{cppcode}

Этот механизм позволяет писать API, которые автоматически оптимизируются для временных объектов, предотвращая ненужные глубокие копии.

\section{7.2 Empty Base Optimization (EBO)}

В C++ любой объект должен иметь уникальный адрес. Из этого следует, что размер даже пустой структуры не может быть равен нулю.

\begin{cppcode}[]
struct Empty {};
static_assert(sizeof(Empty) >= 1); // Обычно 1 байт
\end{cppcode}

Это создает проблему при композиции. Если мы включим пустой класс как поле в другой класс, он "съест" минимум 1 байт + возможный padding (выравнивание).

\begin{cppcode}[]
struct A {
    Empty e; // 1 байт
    int i;   // 4 байта
    // Итоговый размер может быть 8 байт из-за выравнивания!
};
\end{cppcode}

Однако стандарт разрешает оптимизацию: если пустой класс является \textbf{базовым}, он может иметь нулевой размер (его часть в layout объекта "схлопывается"). Это называется \textbf{Empty Base Optimization (EBO)}.

\begin{cppcode}[]
struct B : Empty { // EBO работает!
    int i;
};
static_assert(sizeof(B) == sizeof(int)); // 4 байта
\end{cppcode}

\textbf{Где это используется?}
В аллокаторах, делетерах и компараторах STL. Например, \texttt{std::unique\_ptr} хранит указатель и делетер. Если делетер — это пустая структура (без состояния, только \texttt{operator()}), то благодаря EBO размер \texttt{unique\_ptr} остается равным размеру сырого указателя. Если бы делетер хранился как поле, размер указателя удвоился бы.

\section{7.3 Опасность const T\&\&}

Тип \texttt{const T\&\&} (константная rvalue-ссылка) является синтаксически валидным, но семантически бесполезным и даже вредным.

\begin{enumerate}
    \item \textbf{Нельзя изменить:} Мы не можем "обворовать" объект, так как он \texttt{const}.
    \item \textbf{Нельзя смувить:} Конструктор перемещения требует \texttt{T\&\&}, а не \texttt{const T\&\&}.
\end{enumerate}

При попытке применить \texttt{std::move} к константному объекту происходит тихое "предательство":

\begin{cppcode}[]
const std::string s = "data";
// std::move(s) кастит к 'const string&&'
// Нет конструктора string(const string&&)
// Компилятор ищет ближайшее совпадение... string(const string&)
// ВЫЗЫВАЕТСЯ КОПИРОВАНИЕ!
std::string s2 = std::move(s); 
\end{cppcode}

Вывод: Никогда не используйте \texttt{const} для rvalue-ссылок и возвращаемых значений, если планируете перемещение. \texttt{const} блокирует move-семантику.

\section{7.4 Destructive Move vs Non-destructive Move}

C++ реализует \textbf{неразрушающее перемещение (Non-destructive Move)}. Это означает, что после перемещения исходный объект (\textit{source}) остается жить. Он переходит в состояние "валидное, но неопределенное". Для него обязательно будет вызван деструктор.

\begin{itemize}
    \item \textbf{Плюсы:} Совместимость с RAII. Деструктор всегда очищает ресурсы, даже у moved-from объекта (который просто ничего не делает, так как ресурсы обнулены).
    \item \textbf{Минусы:} Оверхед. Нам нужно вручную занулять указатели в источнике. Деструктор вызывается "вхолостую".
\end{itemize}

В языке \textbf{Rust}, напротив, реализовано \textbf{разрушающее перемещение (Destructive Move)}.
\begin{itemize}
    \item Перемещение — это просто \texttt{memcpy} битов.
    \item Исходный объект считается "мертвым" сразу после перемещения.
    \item Деструктор для исходного объекта \textbf{не вызывается}.
    \item Компилятор статически запрещает обращение к перемещенной переменной.
\end{itemize}

Подход Rust более эффективен (нет лишних записей нулей, нет лишних вызовов деструкторов), но требует более строгой системы типов (borrow checker), чтобы гарантировать безопасность на этапе компиляции. В C++ "зомби-объекты" (moved-from) — это плата за гибкость и совместимость с легаси-кодом.

\begin{summary}
\begin{itemize}
    \item \textbf{Ref-qualifiers} позволяют перегружать методы для rvalue-объектов, оптимизируя цепочки вызовов.
    \item \textbf{EBO} позволяет "бесплатно" хранить stateless-объекты (политики, аллокаторы) внутри классов.
    \item \texttt{const} и \texttt{move} несовместимы.
    \item В C++ перемещение оставляет "пустую оболочку", которую нужно корректно уничтожить. В Rust перемещение уничтожает оболочку логически.
\end{itemize}
\end{summary}
