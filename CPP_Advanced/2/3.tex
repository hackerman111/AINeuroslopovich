\chapter{Семантика перемещения (Move Semantics): Механика и История}

Семантика перемещения — это, пожалуй, самое значительное изменение в C++11, фундаментально изменившее подход к управлению ресурсами. Она позволяет не копировать данные, а передавать владение ими от одного объекта к другому. Чтобы понять, зачем это нужно, полезно взглянуть на историю языка.

\section{3.1 Исторический контекст: Проблема лишних копий}

До стандарта C++11 возврат тяжелых объектов из функций был сопряжен с накладными расходами. Рассмотрим классический пример фабричной функции, возвращающей вектор:

\begin{cppcode}[]
std::vector<int> LoadBigData() {
    std::vector<int> data(1000000);
    // ... заполнение данными ...
    return data;
}

void Process() {
    std::vector<int> my_data = LoadBigData();
}
\end{cppcode}

В наивной реализации компилятора C++98 здесь происходило следующее:
\begin{enumerate}
    \item Внутри \texttt{LoadBigData} создается локальный вектор (аллокация 4 МБ памяти).
    \item При возврате создается временный объект-результат: вызывается конструктор копирования. Выделяются новые 4 МБ, данные копируются (`memcpy`). Локальный вектор уничтожается (освобождение 4 МБ).
    \item В \texttt{Process} объект \texttt{my\_data} инициализируется копированием из временного объекта. Еще одна аллокация, еще одно копирование. Временный объект уничтожается.
\end{enumerate}

Итого: 3 аллокации, 2 глубоких копирования массивов. Хотя RVO (Return Value Optimization) существовала и раньше, она не была гарантирована во всех случаях (например, при сложной логике возврата или присваивании существующему объекту).

\section{Трюк со swap}
Чтобы избежать копирования, программисты использовали идиому \texttt{swap}. Вместо конструктора копирования "перемещение" имитировалось обменом внутреннего состояния с пустым объектом.

\begin{cppcode}[]
// Pre-C++11 стиль
std::vector<int> temp;
LoadBigData(temp); // Передача по ссылке (out-parameter)
std::vector<int> my_data;
my_data.swap(temp); // Обмен указателями за O(1)
\end{cppcode}
Это работало быстро, но делало код громоздким и лишало функции возможности возвращать значения естественным образом.

\section{3.2 Катастрофа std::auto\_ptr}

Попытка реализовать семантику владения до C++11 привела к созданию \texttt{std::auto\_ptr}. Это был класс умного указателя, который пытался "перемещать" ресурс при копировании.

\begin{cppcode}[]
// Упрощенная логика auto_ptr
template <typename T>
struct auto_ptr {
    T* ptr;
    
    // "Копирующий" конструктор, который на самом деле перемещает
    auto_ptr(auto_ptr& other) {
        ptr = other.ptr;
        other.ptr = nullptr; // МОДИФИКАЦИЯ ИСТОЧНИКА!
    }
};

void bad_idea() {
    std::auto_ptr<int> a(new int(10));
    std::auto_ptr<int> b = a; 
    // Теперь 'b' владеет ресурсом, а 'a' стал nullptr.
    // Это произошло при синтаксисе КОПИРОВАНИЯ.
}
\end{cppcode}

\textbf{Почему это плохо?}
Семантика копирования подразумевает создание независимого дубликата: оригинал не должен меняться. \texttt{auto\_ptr} нарушал этот контракт. Это приводило к багам при использовании в стандартных контейнерах.
Например, \texttt{std::sort} может брать "опорный" элемент копированием. В случае \texttt{auto\_ptr} оригинал в массиве внезапно обнулялся, что приводило к потере данных и крашам. В C++11 \texttt{auto\_ptr} был объявлен deprecated, а в C++17 удален из стандарта.

\section{3.3 Философия Move Semantics}

C++11 решил проблему, введя Rvalue-ссылки. Теперь мы можем перегружать функции для двух случаев:
\begin{enumerate}
    \item \texttt{const T\& source} — мы хотим \textbf{копировать} (источник важен, он останется неизменным).
    \item \texttt{T\&\& source} — мы хотим \textbf{перемещать} (источник временный или нам явно разрешили его "разграбить").
\end{enumerate}

\section{Анатомия Move Constructor}

Перемещающий конструктор "крадет" ресурсы у rvalue-объекта. Критически важно оставить источник в валидном состоянии, чтобы его деструктор отработал корректно.

Рассмотрим класс \texttt{Holder}, управляющий буфером памяти:

\begin{cppcode}[]
class Holder {
    int* data_;
    size_t size_;

public:
    Holder(int size) : size_(size), data_(new int[size]) {}
    
    ~Holder() { 
        delete[] data_; // Деструктор должен быть безопасным для nullptr
    }

    // Move Constructor
    // Принимает неконстантную rvalue-ссылку
    Holder(Holder&& other) noexcept 
        : data_(other.data_)  // 1. Крадем указатель
        , size_(other.size_)  // 2. Крадем метаданные
    {
        // 3. Зануляем источник!
        // Если этого не сделать, деструктор 'other' удалит память,
        // которой теперь владеем мы. Будет double free.
        other.data_ = nullptr;
        other.size_ = 0;
    }
};
\end{cppcode}

Затраты: копирование двух скаляров (указатель + size). 0 аллокаций.

\section{Анатомия Move Assignment Operator}

Оператор присваивания сложнее, так как объект уже может владеть ресурсом, который нужно предварительно освободить. Также обязательна защита от самоприсваивания (\texttt{x = std::move(x)}).

\begin{cppcode}[]
    Holder& operator=(Holder&& other) noexcept {
        if (this == &other) {
            return *this; // Защита от перемещения в себя
        }

        // 1. Освобождаем свой текущий ресурс
        delete[] data_;

        // 2. Крадем ресурсы
        data_ = other.data_;
        size_ = other.size_;

        // 3. Зануляем источник
        other.data_ = nullptr;
        other.size_ = 0;

        return *this;
    }
\end{cppcode}

\section{3.4 std::move — это ложь}

Одна из самых распространенных ошибок новичков — думать, что функция \texttt{std::move} что-то перемещает.

\begin{definition}{std::move}
Это функция приведения типа. Она принимает объект любого типа (lvalue или rvalue) и безусловно приводит его к \textbf{rvalue-ссылке} (\texttt{T\&\&}).
\end{definition}

Сам по себе вызов \texttt{std::move(x)} не генерирует никакого машинного кода для переноса данных. Он просто говорит компилятору: "Смотри на \texttt{x} как на временный объект". Перемещение происходит только тогда, когда результат \texttt{std::move} передается в конструктор или оператор присваивания, принимающий \texttt{T\&\&}.

\begin{cppcode}[]
std::vector<int> v1 = {1, 2, 3};
std::move(v1); // Ничего не происходит. v1 остался цел.

auto v2 = std::move(v1); // Вызывается vector(vector&&), вот теперь v1 пуст.
\end{cppcode}

\section{3.5 Ловушка реализации: Именованные Rvalue-ссылки}

Это самый тонкий момент, на котором ошибаются даже опытные разработчики.

\begin{important}
\textbf{Если у rvalue-ссылки есть имя, то она — lvalue.}
\end{important}

Рассмотрим некорректную реализацию конструктора обертки:

\begin{cppcode}[]
class Wrapper {
    std::string str_;
public:
    // Мы принимаем строку как rvalue-ссылку (text)
    explicit Wrapper(std::string&& text) 
        : str_(text) // ОШИБКА! Вызывается COPY constructor!
    {}
};
\end{cppcode}

\textbf{Разбор ошибки:}
\begin{enumerate}
    \item Параметр \texttt{text} имеет тип \texttt{std::string\&\&}.
    \item Внутри тела (или списка инициализации) функции, \texttt{text} — это переменная с именем. У нее есть адрес. Следовательно, выражение \texttt{text} имеет категорию значения \textbf{lvalue}.
    \item Конструктор \texttt{std::string} видит lvalue и вызывает копирование (\texttt{const string\&}).
\end{enumerate}

Мы потеряли эффективность. Чтобы исправить это, нужно снова превратить lvalue \texttt{text} в xvalue с помощью \texttt{std::move}:

\begin{cppcode}[]
    explicit Wrapper(std::string&& text) 
        : str_(std::move(text)) // Правильно: вызывается MOVE constructor
    {}
\end{cppcode}

\section{3.6 Правило пяти (Rule of 5)}

С появлением move-семантики "Правило трех" расширилось до "Правила пяти".
Если классу требуется пользовательский деструктор (для освобождения ресурса), то, скорее всего, ему требуются:
\begin{enumerate}
    \item Деструктор
    \item Конструктор копирования
    \item Оператор присваивания копированием
    \item \textbf{Конструктор перемещения}
    \item \textbf{Оператор присваивания перемещением}
\end{enumerate}

Если вы не реализуете move-методы, компилятор не сгенерирует их автоматически, если у вас уже есть пользовательский деструктор или copy-методы. В этом случае класс будет только копируемым, что "убьет" производительность при работе с контейнерами.

\textbf{Правило нуля (Rule of 0):}
Лучший способ написать класс — не управлять ресурсами вручную. Используйте \texttt{std::unique\_ptr}, \texttt{std::vector}, \texttt{std::string}. У этих классов уже реализованы все 5 методов. Компилятор автоматически сгенерирует корректные дефолтные версии для вашего класса, которые просто вызовут соответствующие методы для полей.

\begin{cppcode}[]
class ModernHolder {
    // std::vector сам управляет памятью.
    // Нам не нужно писать ни деструктор, ни конструкторы.
    // Все сгенерируется автоматически и будет поддерживать move.
    std::vector<int> data_; 
};
\end{cppcode}

\begin{summary}
\begin{itemize}
    \item Move-семантика заменяет глубокое копирование передачей указателей.
    \item \texttt{std::move} — это каст к rvalue, а не действие.
    \item Аргумент функции типа \texttt{T\&\&} внутри функции является lvalue. Используйте \texttt{std::move} для передачи его дальше.
    \item После перемещения объект находится в валидном, но неопределенном состоянии (valid but unspecified). Его можно уничтожить или присвоить ему новое значение, но читать из него нельзя.
\end{itemize}
\end{summary}
