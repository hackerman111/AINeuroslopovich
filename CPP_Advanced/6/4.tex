% =========================================================
% ГЛАВА 4
% =========================================================

\chapter{Глубокое погружение в исключения (Exception Safety)}

Механизм исключений в C++ — это мощный инструмент обработки ошибок, который часто понимается поверхностно. В отличие от кодов возврата (как в C или Go) или монад (как \texttt{Result<T, E>} в Rust), исключения в C++ предлагают автоматическую раскрутку стека и нелокальную передачу управления. Однако неправильное использование исключений ведет к утечкам ресурсов, неопределенному поведению и деградации производительности.

Эта глава посвящена не синтаксису \texttt{try-catch}, а внутренней механике процесса (\textit{Under the hood}), гарантиям безопасности (Exception Safety Guarantees) и правильному написанию устойчивого кода.

\section{Механика исключений: Zero-cost vs Stack Unwinding}

Часто можно услышать, что "исключения медленные". Это утверждение верно лишь отчасти. Современные компиляторы (GCC, Clang, MSVC) реализуют модель, называемую \textbf{Zero-cost exceptions} (на Itanium C++ ABI).

\subsection{Happy Path (Путь без ошибок)}
Пока исключение \textbf{не} брошено, накладные расходы на поддержку механизма исключений практически равны нулю. В коде нет проверок \texttt{if (error)} после каждого вызова функции. Процессор выполняет линейный поток инструкций, что благоприятно для предсказателя переходов (Branch Predictor) и кэша инструкций.

\subsection{Error Path (Путь ошибки)}
Когда выполняется оператор \texttt{throw}, происходит дорогая операция, называемая \textbf{Stack Unwinding} (Раскрутка стека):

\begin{enumerate}
    \item \textbf{Поиск обработчика:} Runtime-система (например, \texttt{libunwind}) просматривает таблицу исключений (\texttt{.eh\_frame} или аналогичную секцию), сгенерированную компилятором. Эта таблица сопоставляет диапазоны адресов инструкций (Program Counter) с информацией о том, какие деструкторы нужно вызвать в текущем кадре стека и есть ли здесь блок \texttt{catch}.
    \item \textbf{Вызов деструкторов:} Если в текущей функции нет подходящего \texttt{catch}, система вызывает деструкторы всех локальных объектов, созданных с начала функции до точки выброса.
    \item \textbf{Раскрутка:} Стек урезается (stack pointer смещается), управление передается вызывающей функции, и процесс повторяется (шаг 1), пока не будет найден \texttt{catch} или пока не будет достигнут \texttt{main}.
    \item \textbf{Terminate:} Если стек раскрутился до \texttt{main}, а обработчик не найден, вызывается \texttt{std::terminate()} (обычно \texttt{abort()}).
\end{enumerate}

Этот процесс включает парсинг таблиц, множество косвенных переходов и вызовов, что действительно очень медленно (тысячи тактов процессора). Поэтому исключения не должны использоваться для управления потоком выполнения в штатном режиме (например, для выхода из цикла).

\section{Правила перехвата исключений}

\subsection{Slicing (Срезка) объектов}
Ловить исключения нужно \textbf{строго по ссылке} (желательно константной). Ловля по значению приводит к срезке полиморфной части объекта.

\begin{cppcode}[]
#include <iostream>
#include <exception>

struct MyError : std::exception {
    const char* what() const noexcept override { 
        return "My Custom Error"; 
    }
    int errorCode = 500;
};

void badHandler() {
    try {
        throw MyError();
    } 
    // ПЛОХО: catch по значению. 
    // Создается копия std::exception, отбрасывая часть MyError.
    catch (std::exception e) { 
        // e.what() вызовет метод базового класса std::exception, 
        // а не переопределенный MyError::what()!
        std::cout << e.what() << "\n"; 
        // e.errorCode недоступен
    }
}

void goodHandler() {
    try {
        throw MyError();
    }
    // ХОРОШО: catch по ссылке. Полиморфизм работает.
    catch (const std::exception& e) {
        std::cout << e.what() << "\n"; // Выведет "My Custom Error"
    }
}
\end{cppcode}

\subsection{Порядок блоков catch}
Блоки \texttt{catch} проверяются сверху вниз. Компилятор не всегда предупредит вас, если вы попытаетесь поймать базовый тип раньше производного.

\begin{cppcode}
try {
    // ...
}
catch (const std::exception& e) {
    // Сюда попадут ВСЕ наследники std::exception
}
catch (const std::runtime_error& e) {
    // Мертвый код (Dead Code)!
    // runtime_error наследуется от exception, 
    // поэтому он будет перехвачен первым блоком.
}
\end{cppcode}

\section{Спецификатор noexcept}

Ключевое слово \texttt{noexcept} — это часть контракта функции.
\begin{itemize}
    \item \texttt{void func() noexcept;} — гарантирует, что функция не выбросит исключение.
    \item Если исключение всё же вылетит из \texttt{noexcept}-функции, программа немедленно вызовет \texttt{std::terminate()}. Раскрутка стека может не произойти (деструкторы не вызовутся).
\end{itemize}

Компилятор использует эту информацию для агрессивных оптимизаций. Если функция помечена \texttt{noexcept}, компилятору не нужно генерировать таблицы раскрутки стека для вызовов внутри неё.

\subsection{Вектор и noexcept move-конструкторы}
Это критически важный аспект для производительности контейнеров. Рассмотрим \texttt{std::vector::push\_back}. Если вектору не хватает места (capacity), он должен:
\begin{enumerate}
    \item Выделить новый блок памяти.
    \item Перенести элементы из старого блока в новый.
    \item Удалить старый блок.
\end{enumerate}

При переносе элементов вектор предпочитает использовать \textit{перемещение} (move constructor), так как это дешево (копирование указателей). Однако, если move-конструктор элемента может выбросить исключение, возникает проблема нарушения транзакционности.

Представьте, что мы перенесли 5 элементов из 10, и 6-й элемент выбросил исключение при перемещении.
\begin{itemize}
    \item Старый вектор испорчен (из 5 элементов ресурсы украдены).
    \item Новый вектор недостроен.
    \item Восстановить исходное состояние невозможно.
\end{itemize}

Поэтому \texttt{std::vector} использует идиому \texttt{std::move\_if\_noexcept}:
\begin{cppcode}
// Псевдокод логики вектора при реаллокации
if (std::is_nothrow_move_constructible<T>::value) {
    // Безопасно муваем. Если упадем - значит terminate, терять нечего.
    move_elements(); 
} else {
    // Приходится копировать. 
    // Если копия упадет, старый вектор останется нетронутым.
    copy_elements(); 
}
\end{cppcode}

\begin{important}
Всегда помечайте перемещающие конструкторы и операторы присваивания как \texttt{noexcept}, иначе стандартные контейнеры деградируют до копирования, что убьет производительность.
\end{important}

\section{Гарантии безопасности исключений (Exception Safety Guarantees)}

При проектировании классов вы должны документировать, что произойдет с объектом, если его метод выбросит исключение. Абстракция не должна "течь" или оставлять систему в рассогласованном состоянии.

Выделяют четыре уровня гарантий (от слабой к сильной):

\subsection{1. No-throw Guarantee (Гарантия отсутствия сбоев)}
Функция никогда не выбрасывает исключений. Это обязательное требование для:
\begin{itemize}
    \item \textbf{Деструкторов:} Выброс исключения из деструктора во время раскрутки стека (когда уже летит другое исключение) приводит к \texttt{std::terminate}.
    \item \textbf{Функций освобождения памяти} (\texttt{delete}, \texttt{free}).
    \item \textbf{Swap:} Функция обмена должна быть надежной, так как на ней строятся другие гарантии.
\end{itemize}

\subsection{2. Strong Guarantee (Строгая гарантия)}
Транзакционная семантика: "Commit or Rollback". Если функция завершилась с исключением, состояние программы остается таким же, каким было до вызова функции. Никаких побочных эффектов.

Пример реализации через идиому \textbf{Copy-and-Swap}:
\begin{cppcode}
class Widget {
private:
    std::vector<int> data;
public:
    // Мы хотим заменить данные, но безопасно.
    void updateData(const std::vector<int>& newData) {
        // 1. Создаем временную копию (может бросить исключение).
        // Если бросит здесь - this не изменится.
        std::vector<int> temp = newData; 
        
        // 2. Меняем состояние через небросающий swap.
        // std::vector::swap - noexcept.
        using std::swap;
        swap(this->data, temp);
        
        // 3. temp (со старыми данными) разрушается при выходе.
    }
};
\end{cppcode}

\subsection{3. Basic Guarantee (Базовая гарантия)}
Если произошло исключение:
\begin{itemize}
    \item Нет утечек ресурсов (память, файлы, мьютексы освобождены).
    \item Инварианты класса сохранены (внутреннее состояние согласовано).
    \item Однако данные могут быть изменены и непредсказуемы (но валидны).
\end{itemize}
Это минимальный уровень, требуемый от корректного C++ кода. Обычно обеспечивается использованием RAII (\texttt{std::unique\_ptr}, \texttt{std::lock\_guard}).

\subsection{4. No Guarantee (Отсутствие гарантий)}
Если произошло исключение, всё сломалось: память утекла, данные коррумпированы. Это недопустимо в качественном коде.

\section{Инварианты класса}

Инвариант — это логическое условие, которое всегда истинно для валидного объекта (кроме момента выполнения методов, меняющих состояние).

Пример класса, уязвимого к исключениям:
\begin{cppcode}
class Buffer {
    int* ptr = nullptr;
    size_t size = 0;
public:
    Buffer(size_t n) {
        // ОПАСНО!
        size = n;            // 1. Установили размер
        ptr = new int[n];    // 2. Пытаемся выделить память
        // Если new бросит std::bad_alloc:
        // - Конструктор прервется.
        // - Деструктор НЕ будет вызван (объект не достроен).
        // - У нас остался "объект" с size > 0, но без памяти.
        // Хотя самого объекта технически нет, это нарушение логики построения.
    }
};
\end{cppcode}

Более тонкий пример нарушения инварианта (Basic Guarantee):
\begin{cppcode}
void process() {
    size_t oldSize = size;
    size = 0;      // Ломаем инвариант "size соответствует данным"
    doWork();      // Если тут throw...
    size = oldSize; // ...восстановление не выполнится
    // Объект остался с size=0, но старыми данными. 
}
\end{cppcode}
Решение: использовать \texttt{ScopeGuard} или менять состояние в самом конце (после всех опасных операций).

\section{Function-try-block}

Специфическая конструкция C++, позволяющая перехватить исключения, возникающие в \textbf{списке инициализации конструктора} (Member Initializer List). Это единственный способ обработать ошибку в конструкторе базового класса или члена класса.

\begin{cppcode}
class Service {
    Resource res; // Конструктор Resource может бросить
public:
    Service() try : res(42) {
        // Тело конструктора
    }
    catch (const std::exception& e) {
        // Мы попадем сюда, если res(42) упадет.
        // ВАЖНО: Исключение здесь НЕЛЬЗЯ подавить.
        // Даже если мы не напишем throw;, оно будет перевыброшено автоматически.
        // Смысл блока только в логировании или трансляции исключения.
        std::cerr << "Init failed: " << e.what() << "\n";
    }
};
\end{cppcode}
Использовать \texttt{function-try-block} для обычных функций не рекомендуется (это эквивалентно \texttt{try} внутри всего тела), а в конструкторах он нужен крайне редко, так как обычно лучше дать исключению улететь наверх, чем пытаться починить недостроенный объект.

