\chapter{Физическая структура программы: Компиляция, Линковка и ODR}

Понимание того, как исходный код C++ превращается в исполняемый файл, является критическим навыком для системного программиста. В отличие от интерпретируемых языков или языков с JIT-компиляцией, C++ имеет строгую, многоступенчатую модель сборки, унаследованную от C. Ошибки на этапе линковки (Unresolved external symbol, Multiple definition) часто становятся следствием непонимания концепции единиц трансляции и правила одного определения (ODR).

\section{Пайплайн сборки C++}

Процесс преобразования кода можно разделить на три изолированных этапа: препроцессинг, компиляция и линковка.

\subsection{1. Препроцессинг}
Препроцессор — это инструмент текстовой подстановки. Он ничего не знает о синтаксисе C++, типах данных или областях видимости.
\begin{itemize}
    \item \texttt{\#include "file.h"}: Содержимое файла \texttt{file.h} копируется байт-в-байт в место вызова директивы. Рекурсивные включения раскрываются полностью.
    \item \texttt{\#define}, \texttt{\#ifdef}: Обрабатываются макросы и условная компиляция.
    \item Комментарии удаляются.
\end{itemize}
Результатом работы препроцессора является \textit{Translation Unit} (TU) — полный текст программы, готовый к компиляции. Если в исходном файле было 10 строк, а он включил заголовок на 10 000 строк, компилятор получит на вход 10 010 строк кода.

\subsection{2. Компиляция}
Компилятор работает с каждой единицей трансляции \textbf{изолированно}. При компиляции \texttt{a.cpp} компилятор не знает о существовании \texttt{b.cpp}.
\begin{enumerate}
    \item \textbf{Лексический и синтаксический анализ:} Построение абстрактного синтаксического дерева (AST).
    \item \textbf{Семантический анализ:} Проверка типов, перегрузок, шаблонов.
    \item \textbf{Оптимизация:} Преобразование AST в промежуточное представление (IR) и применение оптимизаций (inlining, loop unrolling).
    \item \textbf{Кодогенерация:} Создание объектного файла (\texttt{.o} или \texttt{.obj}).
\end{enumerate}

Объектный файл содержит машинный код функций и данных, а также \textbf{таблицу символов} (Symbol Table). Символы делятся на:
\begin{itemize}
    \item \textbf{Экспортируемые (Defined):} Функции и глобальные переменные, определенные в этом TU.
    \item \textbf{Импортируемые (Undefined):} Функции, которые были объявлены (declared), но не определены (defined) в текущем TU.
\end{itemize}

\subsection{3. Линковка (Компоновка)}
Линкер (Linker) собирает объектные файлы в единый исполняемый файл или библиотеку. Его задача — разрешить все Undefined символы, сопоставив их с Defined символами из других объектных файлов. Именно здесь проверяется правило ODR.

\section{One Definition Rule (ODR)}

Фундаментальное правило C++ (стандарт ISO/IEC 14882) гласит:

\begin{definition}{One Definition Rule (ODR)}
\begin{enumerate}
    \item В любой единице трансляции может быть не более одного определения любой переменной, функции, класса или шаблона.
    \item Во всей программе должно быть \textbf{ровно одно} определение каждой используемой переменной или функции (non-inline).
    \item Для классов и шаблонов разрешено иметь определения в нескольких TU, если они \textbf{побайтово идентичны} (token-for-token identical).
\end{enumerate}
\end{definition}

Нарушение пункта 2 приводит к ошибке линковки \texttt{multiple definition of symbol}. Нарушение пункта 3 (разные определения одного класса в разных файлах) приводит к неопределенному поведению (UB), которое крайне сложно диагностировать.

\subsection{Declaration vs Definition}
Важно различать объявление и определение:
\begin{itemize}
    \item \textbf{Declaration (Объявление):} Сообщает компилятору о существовании сущности и её типе. Не выделяет память.
    \begin{cppcode}
extern int x;       // Объявление переменной
void func();        // Объявление функции
class A;            // Forward declaration класса
    \end{cppcode}
    \item \textbf{Definition (Определение):} Создает сущность, выделяет память или генерирует код.
    \begin{cppcode}
int x = 0;          // Определение (даже без инициализатора int x;)
void func() { }     // Определение (есть тело)
class A { int f; }; // Определение класса
    \end{cppcode}
\end{itemize}

\section{Проблема глобальных переменных в хедерах}

Рассмотрим классическую ошибку нарушения ODR.

\textbf{header.h}
\begin{cppcode}[]
#ifndef HEADER_H
#define HEADER_H
// ОШИБКА: Это определение глобальной переменной
int globalVar = 42; 
#endif
\end{cppcode}

\textbf{a.cpp}
\begin{cppcode}[]
#include "header.h"
// После препроцессинга здесь появится: int globalVar = 42;
// Компилятор создаст a.o с символом globalVar (Defined)
\end{cppcode}

\textbf{b.cpp}
\begin{cppcode}[]
#include "header.h"
// После препроцессинга здесь тоже появится: int globalVar = 42;
// Компилятор создаст b.o с символом globalVar (Defined)
\end{cppcode}

При попытке слинковать \texttt{a.o} и \texttt{b.o} линкер обнаружит два сильных символа с именем \texttt{globalVar} и выдаст ошибку \texttt{duplicate symbol}.

\section{Стратегии решения конфликтов линковки}

Существует три основных механизма для корректного разделения кода между единицами трансляции.

\subsection{1. extern (External Linkage)}
Традиционный подход C. В хедере мы только \textit{объявляем} переменную, а \textit{определяем} её ровно в одном .cpp файле.

\begin{cppcode}
// header.h
extern int globalVar; // Только объявление

// a.cpp
#include "header.h"
int globalVar = 42;   // Определение (память выделена здесь)

// b.cpp
#include "header.h"
// Использует символ globalVar, который будет найден в a.o
\end{cppcode}

\subsection{2. static (Internal Linkage)}
Ключевое слово \texttt{static}, примененное к глобальной переменной или свободной функции, меняет тип линковки на \textit{внутренний}.

\begin{cppcode}
// header.h
static int globalVar = 42;
\end{cppcode}

Если включить такой хедер в \texttt{a.cpp} и \texttt{b.cpp}:
\begin{itemize}
    \item В \texttt{a.o} будет создана своя локальная копия \texttt{globalVar}.
    \item В \texttt{b.o} будет создана \textbf{другая}, независимая копия \texttt{globalVar}.
\end{itemize}
Линкер не увидит конфликта, так как символы не экспортируются наружу. Это решает ошибку сборки, но создает логическую ошибку, если вы ожидали, что переменная будет общей для всей программы (Singleton). Кроме того, это увеличивает размер бинарного файла.

\subsection{3. inline (Weak Linkage / COMDAT Folding)}
В C++17 появилась возможность объявлять переменные как \texttt{inline}. Это позволяет определять переменную в хедере.

\begin{cppcode}
// header.h
inline int globalVar = 42; // C++17
\end{cppcode}

Семантика \texttt{inline}: "Разрешено множественное определение". Компилятор помечает символ как слабый (weak). Линкер, встречая несколько копий такого символа, просто выбирает одну (обычно первую попавшуюся) и отбрасывает остальные. Все единицы трансляции будут ссылаться на один и тот же адрес памяти. Это идеальное решение для констант и глобальных настроек в современных стандартах.

\begin{important}
Шаблоны функций и классов неявно являются \texttt{inline}. Методы, определенные внутри тела класса, также неявно являются \texttt{inline}. Именно поэтому мы можем писать реализацию шаблонных классов полностью в .h файлах.
\end{important}

\section{Anonymous Namespaces}

В C++ вместо \texttt{static} для ограничения видимости внутри файла рекомендуется использовать анонимные пространства имен.

\begin{cppcode}
namespace {
    int localHelper = 10;
    void doSomethingInternal() { ... }
}
\end{cppcode}
С точки зрения линковки это эквивалентно генерации уникального имени для пространства имен (например, \texttt{namespace \_unique\_id\_123}), доступного только в текущем TU. Это предпочтительнее \texttt{static}, так как работает и для типов (классов), а не только для переменных и функций, позволяя передавать локальные типы в шаблоны.

\section{Библиотеки и LTO}

\subsection{Static (.a / .lib) vs Shared (.so / .dll)}
\begin{itemize}
    \item \textbf{Static Library:} Это просто архив объектных файлов (аналог \texttt{zip} или \texttt{tar} с индексом). При линковке нужные \texttt{.o} файлы извлекаются из архива и копируются в исполняемый файл. Размер бинарника растет, но он становится самодостаточным.
    \item \textbf{Shared Library:} Не копируется в бинарник. Линкер лишь проверяет наличие символов и оставляет "заглушки". При запуске программы операционная система (Dynamic Loader) загружает библиотеку в память.
        \begin{itemize}
            \item \textbf{Плюс:} Экономия оперативной памяти. Код библиотеки загружается в физическую память один раз и отображается в виртуальную память всех процессов, использующих её (механизм memory mapping).
            \item \textbf{Минус:} Проблема зависимостей (DLL Hell), необходимость распространять библиотеки вместе с приложением.
        \end{itemize}
\end{itemize}

\subsection{Link Time Optimization (LTO)}
Традиционная модель компиляции имеет недостаток: компилятор видит только один TU. Он не может заинлайнить функцию, определенную в другом \texttt{.cpp} файле, так как на этапе компиляции её тело недоступно.

LTO меняет этот процесс. При включении LTO (флаг \texttt{-flto} в GCC/Clang) компилятор вместо машинного кода генерирует в объектных файлах промежуточное представление (Intermediate Representation, IR — например, GIMPLE или LLVM Bitcode).

Реальная генерация кода откладывается до этапа линковки. Линкер собирает IR со всех модулей, видит всю программу целиком и может выполнять агрессивные оптимизации:
\begin{itemize}
    \item Cross-module inlining (инлайнинг функций между разными .cpp).
    \item Dead code elimination (удаление неиспользуемых функций, которые ранее считались экспортируемыми).
\end{itemize}
Цена LTO — значительное увеличение времени линковки и потребления памяти в процессе сборки.

\section{Практические рекомендации}
\begin{enumerate}
    \item Используйте \texttt{\#pragma once} для защиты хедеров. Это нестандартная директива, но она поддерживается всеми основными компиляторами и работает быстрее классических Include Guards (\texttt{\#ifndef ...}), так как компилятору не нужно перечитывать файл.
    \item Никогда не определяйте переменные в хедерах без \texttt{inline} или \texttt{constexpr}.
    \item Шаблоны должны быть полностью определены в хедерах, так как компилятору нужно видеть их тело для инстанцирования конкретных типов.
    \item Используйте анонимные пространства имен вместо \texttt{static} в \texttt{.cpp} файлах для сокрытия локальных помощников.
\end{enumerate}
