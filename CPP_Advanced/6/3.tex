% =========================================================
% ГЛАВА 3
% =========================================================

\chapter{Архитектурные паттерны: Singleton и Template Method}

Паттерны проектирования (Design Patterns) — это не готовые библиотеки и не строгие алгоритмы, которые можно скопировать в код. Это формализованные описания способов решения часто встречающихся архитектурных задач. В контексте C++ паттерны приобретают специфику, связанную с управлением временем жизни объектов, полиморфизмом и возможностями метапрограммирования (шаблонов).

В этой главе мы рассмотрим два фундаментальных паттерна: \textit{Template Method}, который позволяет выделять общий алгоритм в иерархиях классов, и \textit{Singleton}, реализация которого в C++ прошла долгий путь эволюции от простых глобальных переменных до потокобезопасных конструкций на основе CRTP.

\section{Шаблонный метод (Template Method)}

Часто при проектировании иерархии классов возникает ситуация, когда общий алгоритм действий одинаков для всех наследников, но отдельные шаги этого алгоритма должны различаться.

В языках без множественного наследования реализации или без детерминированного разрушения объектов часто приходится дублировать логику. В C++ этот паттерн реализуется естественно через механизм виртуальных функций.

\begin{definition}{Template Method}
Поведенческий паттерн, определяющий скелет алгоритма в базовом классе и делегирующий реализацию некоторых шагов подклассам. Подклассы могут переопределять шаги алгоритма, не меняя его общей структуры.
\end{definition}

Рассмотрим пример симуляции жизни животных. У всех животных день проходит по одному сценарию: проснуться, издать звук, поесть. Процесс пробуждения и приема пищи (в нашей упрощенной модели) одинаков, а вот звуки — уникальны.

\begin{cppcode}[]
#include <iostream>
#include <string>

// Базовый класс определяет алгоритм
class Animal {
public:
    virtual ~Animal() = default;

    // Шаблонный метод. 
    // Он НЕ виртуальный, чтобы зафиксировать структуру алгоритма.
    void liveOneDay() {
        wakeUp();
        makeSound(); // Точка кастомизации (Virtual Hook)
        eat();
    }

protected:
    // Общие шаги реализации
    void wakeUp() const {
        std::cout << "Opening eyes..." << std::endl;
    }

    void eat() const {
        std::cout << "Eating food..." << std::endl;
    }

    // Чисто виртуальный метод — обязан быть реализован в наследнике
    virtual void makeSound() const = 0;
};

// Конкретная реализация
class Dog : public Animal {
protected:
    void makeSound() const override {
        std::cout << "Woof! Woof!" << std::endl;
    }
};

class Cat : public Animal {
protected:
    void makeSound() const override {
        std::cout << "Meow..." << std::endl;
    }
};
\end{cppcode}

В идиоматике C++ этот подход часто пересекается с идиомой \textbf{NVI (Non-Virtual Interface)}. NVI рекомендует делать публичные методы невиртуальными (обеспечивая стабильный интерфейс и проверки инвариантов), а точки расширения (виртуальные методы) делать \texttt{protected} или \texttt{private}.

Это позволяет базовому классу \texttt{Animal} гарантировать, что звук будет издан именно между пробуждением и едой, и никакой наследник не сможет случайно сломать этот порядок, забыв вызвать базовый метод.

\section{Паттерн Singleton (Одиночка)}

Singleton — один из самых спорных, но часто используемых паттернов. Его задача:
\begin{enumerate}
    \item Гарантировать, что у класса есть только один экземпляр.
    \item Предоставить к нему глобальную точку доступа.
\end{enumerate}

Примеры использования:
\begin{itemize}
    \item \textbf{Аллокатор памяти:} Система управления памятью обычно глобальна для процесса.
    \item \textbf{Файловая система / Логгер:} Централизованная запись логов в один файл требует синхронизации, которую проще обеспечить через единый объект.
    \item \textbf{Драйвер видеокарты:} Физическое устройство одно, и доступ к нему должен быть монопольным.
\end{itemize}

\subsection{Критика Singleton}
Singleton часто называют "антипаттерном" из-за проблем, которые он привносит:
\begin{itemize}
    \item \textbf{Скрытые зависимости:} Если функция принимает аргументы, её зависимости явны. Если функция внутри себя вызывает \texttt{Logger::getInstance()}, зависимость скрыта.
    \item \textbf{Проблемы тестирования:} Невозможно изолировать тесты. Если один тест изменил состояние синглтона, второй тест может упасть. Нельзя запустить два экземпляра "приложения" параллельно в одном тестовом процессе.
    \item \textbf{Глобальное состояние:} Усложняет понимание потока данных и многопоточности.
\end{itemize}
Тем не менее, в системном программировании Singleton остается необходимым инструментом.

\section{Static Initialization Order Fiasco}

Почему нельзя просто создать глобальную переменную?

\begin{cppcode}
// Logger.h
class Logger { ... };
extern Logger globalLogger;

// Logger.cpp
Logger globalLogger;
\end{cppcode}

Проблема возникает, когда у нас есть \textbf{несколько} глобальных статических объектов в \textbf{разных} единицах трансляции (файлах .cpp), и один из них использует другой в своем конструкторе.

Представим ситуацию:
\begin{enumerate}
    \item В \texttt{Logger.cpp} определен \texttt{globalLogger}.
    \item В \texttt{Application.cpp} определен объект \texttt{Application app}, который в конструкторе пишет лог: \texttt{globalLogger.log("App started")}.
\end{enumerate}

Стандарт C++ \textbf{не определяет} порядок инициализации глобальных переменных, находящихся в разных единицах трансляции. Линкер может собрать их в любом порядке.

\begin{important}
Если \texttt{app} будет инициализировано раньше, чем \texttt{globalLogger}, конструктор \texttt{Application} обратится к неинициализированной памяти (в лучшем случае заполненной нулями). Это приведет к краху программы (Segmentation Fault) или неопределенному поведению до начала функции \texttt{main}.
\end{important}

Это явление называется \textit{Static Initialization Order Fiasco}.

\section{Meyers Singleton}

Решением проблемы инициализации является идиома, популяризированная Скоттом Мейерсом. Идея заключается в переносе статической переменной из глобальной области видимости внутрь функции.

\begin{cppcode}
class Logger {
private:
    Logger() { /* ... */ }
    // Запрещаем копирование
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;

public:
    static Logger& getInstance() {
        // Статическая локальная переменная.
        // Инициализируется ПРИ ПЕРВОМ вызове функции.
        static Logger instance; 
        return instance;
    }

    void log(const std::string& msg) { /* ... */ }
};
\end{cppcode}

Теперь порядок инициализации детерминирован. Если конструктор \texttt{Application} вызовет \texttt{getInstance()}, логгер будет создан именно в этот момент.

\subsection{Thread Safety (Потокобезопасность)}
До стандарта C++11 инициализация статических локальных переменных не была потокобезопасной. Если два потока одновременно заходили в \texttt{getInstance()} в первый раз, мог возникнуть race condition (двойное создание). Приходилось использовать паттерн \textit{Double-Checked Locking}.

В C++11 и новее стандарт гарантирует: \textbf{инициализация статических локальных переменных потокобезопасна}. Компилятор автоматически генерирует блокировки (обычно через атомарные флаги или мьютексы), чтобы только один поток выполнил инициализацию. Это называют "Magic Statics".

\section{Проблема разрушения (Dead Reference)}

Meyers Singleton решает проблему инициализации, но оставляет проблему разрушения. Статические объекты разрушаются в порядке, обратном созданию, после выхода из \texttt{main}.

Сценарий катастрофы:
\begin{enumerate}
    \item \texttt{main} завершается.
    \item Разрушается \texttt{Logger} (так как он был создан последним, лениво).
    \item Разрушается глобальный объект \texttt{Application}.
    \item В деструкторе \texttt{\~Application} происходит попытка записать прощальное сообщение: \texttt{Logger::getInstance().log("App stopped")}.
    \item Метод \texttt{getInstance} возвращает ссылку на уже уничтоженный объект \texttt{Logger}.
    \item Use-after-free, UB, крах.
\end{enumerate}

\subsection{Leaky Singleton}
Чтобы избежать этой проблемы, в системном программировании часто используют "утекающий" синглтон. Мы создаем объект через \texttt{new}, но никогда не вызываем \texttt{delete}.

\begin{cppcode}
static Logger& getInstance() {
    // Память выделяется в куче и никогда не освобождается.
    static Logger* instance = new Logger(); 
    return *instance;
}
\end{cppcode}

С точки зрения C++, это утечка памяти (Memory Leak). Однако, это \textit{безопасная} утечка. Когда процесс завершается, операционная система всё равно реиспользует все страницы памяти, принадлежавшие процессу. Зато объект \texttt{Logger} гарантированно живёт до самого последнего момента существования процесса, и любой деструктор может безопасно им воспользоваться.

\section{Обобщение через CRTP}

В крупном проекте писать метод \texttt{getInstance} и закрывать конструкторы для каждого синглтона утомительно. Мы можем захотеть создать базовый класс \texttt{Singleton<T>}, который инкапсулирует эту логику.

Однако, \texttt{Singleton} должен знать тип создаваемого класса, а создаваемый класс должен наследоваться от \texttt{Singleton}. Возникает циклическая зависимость, которая разрешается с помощью идиомы \textbf{CRTP (Curiously Recurring Template Pattern)} — Странно Рекурсивный Шаблон.

\begin{cppcode}[]
#include <utility> // для std::forward

template <typename T>
class Singleton {
public:
    // Variadic templates позволяют передать аргументы в конструктор T
    template <typename... Args>
    static T& getInstance(Args&&... args) {
        // Создаем через new (Leaky Singleton), чтобы избежать проблем с деструкцией
        static T* instance = new T(std::forward<Args>(args)...);
        return *instance;
    }

protected:
    Singleton() = default;
    ~Singleton() = default;

public:
    // Запрещаем копирование и перемещение для самого Singleton
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

// Пример использования
class FileSystem : public Singleton<FileSystem> {
    // Важно: Singleton<FileSystem> должен иметь доступ к приватному конструктору
    friend class Singleton<FileSystem>;

private:
    FileSystem(const std::string& root) {
        std::cout << "FS mounted at " << root << "\n";
    }

public:
    void readFile(const std::string& path) { /* ... */ }
};

int main() {
    // Первый вызов инициализирует объект
    FileSystem::getInstance("/var/data").readFile("config.txt");
    
    // Последующие вызовы возвращают тот же объект (аргументы игнорируются)
    FileSystem::getInstance().readFile("log.txt"); 
}
\end{cppcode}

\textbf{Разбор механизма CRTP:}
\begin{enumerate}
    \item \texttt{class FileSystem : public Singleton<FileSystem>}: В момент объявления класса \texttt{FileSystem}, шаблон \texttt{Singleton} инстанцируется типом \texttt{FileSystem}. Хотя \texttt{FileSystem} еще является неполным типом (incomplete type), его можно использовать как аргумент шаблона, если шаблон не обращается к внутренностям типа в момент объявления.
    \item Метод \texttt{getInstance} является статическим членом базового класса, но возвращает ссылку на \texttt{T} (то есть на наследника).
    \item \texttt{friend class Singleton<FileSystem>}: Это ключевой момент. Так как конструктор \texttt{FileSystem} приватен (чтобы никто не создал второй экземпляр), базовый класс не мог бы вызвать \texttt{new T(...)}. Дружба дает базовому классу права на доступ к приватным членам наследника.
\end{enumerate}

Этот паттерн позволяет элегантно вынести инфраструктурную логику (управление единственностью) из бизнес-логики класса.

