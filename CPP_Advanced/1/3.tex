\chapter{Динамическая память и RAII}

Мы разобрали автоматическую (стековую) и статическую память. Однако стека недостаточно для решения большинства реальных задач: его размер мал (мегабайты), а время жизни объектов жестко привязано к области видимости. Для работы с большими объемами данных (изображения, базы данных, сетевые буферы) или объектами, время жизни которых определяется бизнес-логикой, используется динамическая память (Heap или "Куча").

В "старом" C++ (до C++11) и в языке C работа с кучей требовала ручного микроменеджмента. В современном C++ мы используем идиому RAII, чтобы автоматизировать этот процесс.

\section{Низкоуровневые механизмы: malloc vs new}

В C++ существуют два способа выделить сырую память. Важно понимать разницу между ними, так как смешивать их — грубая ошибка.

\begin{enumerate}
    \item \textbf{C-style (\texttt{malloc}/\texttt{free}):}
    Функции из стандартной библиотеки C (\texttt{<cstdlib>}).
    \begin{itemize}
        \item \textbf{Типизация:} Возвращают \texttt{void*}. Требуют приведения типов.
        \item \textbf{Объекты:} Только выделяют байты. \textbf{Не вызывают конструкторы} и деструкторы.
        \item \textbf{Ошибки:} При нехватке памяти возвращают \texttt{nullptr}.
    \end{itemize}

    \item \textbf{C++ Operators (\texttt{new}/\texttt{delete}):}
    Операторы языка.
    \begin{itemize}
        \item \textbf{Типизация:} Типизированы, возвращают \texttt{T*}.
        \item \textbf{Объекты:} Сначала выделяют память (через \texttt{operator new}), затем \textbf{вызывают конструктор}. Оператор \texttt{delete} вызывает деструктор, затем освобождает память.
        \item \textbf{Ошибки:} При нехватке памяти бросают исключение \texttt{std::bad\_alloc}.
    \end{itemize}
\end{enumerate}

\begin{important}
В C++ использование \texttt{malloc} практически всегда является ошибкой, кроме случаев взаимодействия с legacy C-библиотеками или написания собственных аллокаторов. Для создания объектов всегда используется \texttt{new} (или его обертки).
\end{important}

\section{Проблема Exception Safety}

Почему ручные \texttt{new} и \texttt{delete} считаются плохим тоном ("моветоном")? Главная причина — сложность написания кода, устойчивого к исключениям (Exception Safety).

Рассмотрим классический пример утечки ресурсов, который сложно заметить невооруженным глазом:

\begin{cppcode}[label={lst:exception_leak}]
void process(Widget* w1, Widget* w2);

void problematic_usage() {
    // ОПАСНО: Порядок вычисления аргументов не определен (до C++17)
    // Даже в C++17, если конструктор второго Widget кинет исключение,
    // первый Widget уже создан, но указатель на него потерян.
    process(new Widget(1), new Widget(2));
}
\end{cppcode}

\textbf{Разбор сценария утечки:}
Компилятор может сгенерировать код в таком порядке:
\begin{enumerate}
    \item Выделение памяти под первый Widget.
    \item Вызов конструктора первого Widget (успех). Указатель лежит во временном регистре процессора.
    \item Выделение памяти под второй Widget.
    \item \textbf{Вызов конструктора второго Widget — бросает исключение!}
\end{enumerate}

В этот момент стек начинает разматываться (stack unwinding). Мы вылетаем из функции \texttt{problematic\_usage}. Но указатель на первый созданный Widget нигде не был сохранен в переменную, у которой есть деструктор. Адрес потерян. Память утекла.

Чтобы исправить это на "сырых" указателях, пришлось бы писать громоздкий код:

\begin{cppcode}
void safe_but_ugly() {
    Widget* w1 = new Widget(1);
    try {
        Widget* w2 = new Widget(2);
        try {
            process(w1, w2);
        } catch (...) {
            delete w2;
            throw;
        }
    } catch (...) {
        delete w1; // Очистка w1 в случае ошибки создания w2
        throw;
    }
    delete w2;
    delete w1;
}
\end{cppcode}
Очевидно, что писать так — невозможно. Здесь на помощь приходит RAII.

\section{Идиома RAII (Resource Acquisition Is Initialization)}

Это, пожалуй, самая важная идиома C++. Идея гениальна в своей простоте: \textbf{связать время жизни ресурса (память, файл, мьютекс) с временем жизни объекта на стеке}.

\begin{definition}{RAII}
Захват ресурса происходит в конструкторе объекта, а освобождение — в его деструкторе. Поскольку объекты на стеке гарантированно разрушаются при выходе из области видимости (в том числе при вылете исключения), утечки ресурсов становятся невозможными.
\end{definition}

Вместо сырого указателя мы используем "умный" объект-обертку. Стандартная библиотека предоставляет готовое решение.

\section{Умный указатель std::unique\_ptr}

\texttt{std::unique\_ptr<T>} (из заголовка \texttt{<memory>}) — это легковесная обертка над сырым указателем.
\begin{itemize}
    \item \textbf{Семантика:} Я владею объектом единолично.
    \item \textbf{Конструктор:} Принимает сырой указатель.
    \item \textbf{Деструктор:} Вызывает \texttt{delete} для хранимого указателя.
    \item \textbf{Копирование:} Запрещено (удален copy constructor).
    \item \textbf{Перемещение:} Разрешено (move constructor передает владение).
\end{itemize}

Исправим пример с \texttt{process} используя современный подход:

\begin{cppcode}[]
#include <memory>

void process(std::unique_ptr<Widget> w1, std::unique_ptr<Widget> w2);

void safe_usage() {
    // std::make_unique создает объект и сразу возвращает unique_ptr.
    // Если make_unique для w2 кинет исключение, 
    // unique_ptr для w1 уже будет создан и корректно уничтожится.
    process(
        std::make_unique<Widget>(1),
        std::make_unique<Widget>(2)
    );
}
\end{cppcode}

\begin{note}
Функция \texttt{std::make\_unique<T>(args...)} появилась в C++14. Всегда предпочитайте её использованию \texttt{new}. Она не только безопаснее (исключает утечку, описанную выше), но и избавляет от необходимости писать имя типа \texttt{T} дважды.
\end{note}

\section{Массивы: new[] и delete[]}

В C++ одиночные объекты и массивы объектов — это разные сущности с точки зрения управления памятью.

\begin{itemize}
    \item \texttt{new T} требует \texttt{delete ptr}.
    \item \texttt{new T[N]} требует \texttt{delete[] ptr}.
\end{itemize}

\begin{important}
Перепутать операторы удаления — это Неопределенное поведение (UB). Если вы выделили массив через \texttt{new int[10]}, а удалили через \texttt{delete}, программа может упасть или повредить кучу (Heap Corruption).
\end{important}

Почему? Обычно при выделении массива \texttt{new[]} компилятор сохраняет размер массива (например, 4 байта перед началом возвращаемого указателя), чтобы знать, сколько раз вызвать деструктор. Оператор \texttt{delete[]} читает этот размер и идет в цикле. Обычный \texttt{delete} просто удаляет один объект.

В современном C++ сырые массивы в динамической памяти (\texttt{new[]}) практически не нужны. Используйте:
\begin{itemize}
    \item \texttt{std::vector<T>} — для динамических массивов с изменяемым размером.
    \item \texttt{std::string} — для строк.
\end{itemize}

\begin{summary}
\begin{enumerate}
    \item Никогда не используйте \texttt{malloc} в C++ коде.
    \item Избегайте явных вызовов \texttt{new} и \texttt{delete}.
    \item Используйте \texttt{std::unique\_ptr} и \texttt{std::make\_unique} для управления одиночными объектами.
    \item Используйте \texttt{std::vector} вместо динамических массивов \texttt{new T[]}.
    \item \textbf{RAII} — ваш главный инструмент борьбы с утечками. Ресурс должен принадлежать объекту на стеке.
\end{enumerate}
\end{summary}
