\chapter{Экосистема разработки и Инструментарий}

Разработка на C++ существенно отличается от работы с интерпретируемыми языками (Python, JS) или языками с мощной стандартной экосистемой "из коробки" (Go, Rust). Здесь нет единого стандарта на сборку, управление пакетами или линтинг. Однако индустрия выработала набор инструментов де-факто, владение которыми является обязательным для написания качественного, переносимого и безопасного кода. В этой главе мы рассмотрим пайплайн сборки CMake, настройку IDE через LSP (ClangD) и инструменты динамического анализа памяти (Sanitizers).

\section{Система сборки CMake}

Нажатие кнопки "Play" в IDE скрывает за собой сложный процесс препроцессинга, компиляции каждого файла (Translation Unit), линковки объектных файлов и подключения библиотек. При переходе к проектам, состоящим из более чем одного файла, ручной вызов компилятора (например, \texttt{g++ main.cpp utils.cpp -o app}) становится неуправляемым.

\begin{definition}{CMake}
Кроссплатформенная система мета-сборки. Она не собирает проект сама, а генерирует инструкции для нативной системы сборки (Makefiles, Ninja, Visual Studio Project и т.д.) на основе конфигурационного файла \texttt{CMakeLists.txt}.
\end{definition}

Процесс работы с CMake всегда состоит из двух этапов:
\begin{enumerate}
    \item \textbf{Конфигурация (Configuration):} CMake читает \texttt{CMakeLists.txt}, проверяет наличие компилятора, библиотек и генерирует дерево сборки.
    \item \textbf{Сборка (Build):} Вызов нативного инструмента (например, \texttt{make}) для непосредственной компиляции исходного кода.
\end{enumerate}

Пример минимального \texttt{CMakeLists.txt}:

\begin{cppcode}[minted language=cmake]
cmake_minimum_required(VERSION 3.10)
project(MyProject)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Добавляем цель для сборки исполняемого файла
add_executable(my_app main.cpp utils.cpp)

# Пример подключения санитайзеров (опционально)
target_compile_options(my_app PRIVATE -fsanitize=address -g)
target_link_options(my_app PRIVATE -fsanitize=address)
\end{cppcode}

Для запуска сборки в терминале используется следующий паттерн out-of-source build (сборка в отдельной директории, чтобы не засорять исходники):

\begin{cppcode}[minted language=bash]
# 1. Создаем директорию build и запускаем конфигурацию
# -S . указывает, что исходники в текущей папке
# -B build указывает, что артефакты сборки кладем в папку build
cmake -S . -B build

# 2. Запускаем непосредственно сборку
# --build build — абстрактная команда, вызывающая make/ninja внутри папки build
cmake --build build
\end{cppcode}

\begin{important}
Никогда не редактируйте сгенерированные файлы (Makefiles) внутри папки \texttt{build}. Все изменения конфигурации должны производиться только в \texttt{CMakeLists.txt}. Если вам нужно пересобрать проект с нуля, безопасно просто удалить папку \texttt{build} и запустить шаг конфигурации заново.
\end{important}

\section{Интегрированная среда разработки (IDE) и LSP}

Для комфортной работы с C++ (автодополнение, навигация по коду, подсветка ошибок) обычного текстового редактора недостаточно. Современный стандарт — использование протокола Language Server Protocol (LSP).

\subsection{ClangD vs Стандартное расширение C++}

В редакторе VS Code по умолчанию предлагается расширение от Microsoft (C/C++). Однако для Unix-систем и сложного C++ кода предпочтительнее использовать \textbf{clangd}.

\begin{itemize}
    \item \textbf{Стабильность:} Clangd использует тот же фронтенд, что и компилятор Clang. Это гарантирует, что если код подсвечивается как ошибочный, он действительно не скомпилируется.
    \item \textbf{Скорость:} Индексация проекта происходит быстрее и точнее.
\end{itemize}

Для того чтобы Clangd (и любой другой языковой сервер) понимал структуру вашего проекта, ему нужен файл \texttt{compile\_commands.json}. Этот файл содержит точные команды, которые используются для компиляции каждого файла (включая флаги, пути к заголовочным файлам и макросы).

Чтобы CMake сгенерировал этот файл, необходимо добавить флаг при конфигурации:

\begin{cppcode}[minted language=bash]
cmake -S . -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
\end{cppcode}

После этого файл \texttt{compile\_commands.json} появится в папке \texttt{build}. Для корректной работы IDE часто требуется создать символическую ссылку на этот файл в корень проекта или настроить IDE на поиск файла в подпапках.

\begin{note}
Если IDE подчеркивает валидный код красным (например, не видит \texttt{<iostream>}), в 99\% случаев проблема в отсутствии или некорректности \texttt{compile\_commands.json}.
\end{note}

\section{Динамический анализ: AddressSanitizer (ASan)}

Ошибки работы с памятью — самый коварный класс багов в C++. Они могут приводить к неопределенному поведению (UB), которое не проявляется при локальном запуске, но роняет продакшн. Статический анализ не может поймать все ошибки. Здесь на помощь приходят санитайзеры.

\begin{definition}{AddressSanitizer (ASan)}
Инструмент динамического анализа, который встраивает проверки доступа к памяти непосредственно в исполняемый файл на этапе компиляции.
\end{definition}

\subsection{Механизм работы}
При компиляции с флагом \texttt{-fsanitize=address} компилятор инструментирует код, окружая каждый выделенный объект в памяти (как на стеке, так и в куче) специальными "красными зонами" (redzones). При любом обращении к памяти программа проверяет, не попадает ли адрес в красную зону. Если попадает — выполнение немедленно прерывается с подробным отчетом об ошибке.

ASan позволяет обнаруживать:
\begin{itemize}
    \item Выход за границы массива (Out-of-bounds access) на стеке и в куче.
    \item Использование памяти после освобождения (Use-after-free).
    \item Двойное освобождение (Double-free).
    \item Утечки памяти (Memory leaks) — работает как LeakSanitizer.
\end{itemize}

\subsection{Стоимость использования}
Использование ASan замедляет выполнение программы примерно в 2 раза и увеличивает потребление памяти. Это приемлемо для этапа тестирования и отладки (Debug builds), но обычно отключается в финальной сборке (Release builds), где важна максимальная производительность.

Пример включения в \texttt{CMakeLists.txt} (рекомендуется выносить в отдельный тип сборки):

\begin{cppcode}[minted language=cmake]
if(ENABLE_ASAN)
    add_compile_options(-fsanitize=address -g)
    add_link_options(-fsanitize=address)
endif()
\end{cppcode}

\section{Отладка: GDB}

Хотя современные IDE предоставляют графические интерфейсы для отладки, умение работать с консольным отладчиком GDB (GNU Debugger) является критическим навыком.

\begin{itemize}
    \item \textbf{Работа на сервере:} Если ваше приложение упало на удаленном сервере (headless environment), у вас не будет доступа к GUI. GDB — единственный способ проанализировать \texttt{core dump} (слепок памяти упавшего процесса).
    \item \textbf{Автоматизация:} GDB поддерживает скриптинг. Вы можете написать сценарий, который автоматически выполняет 100 итераций цикла и останавливается только при выполнении сложного условия, что утомительно делать "прокликиванием" в GUI.
\end{itemize}

Базовый сеанс отладки в GDB:
\begin{cppcode}[minted language=bash]
$ gdb ./my_app
(gdb) break main          # Поставить точку останова на main
(gdb) run                 # Запустить программу
(gdb) next                # Следующая строка (шаг без захода внутрь)
(gdb) step                # Шаг с заходом внутрь функции
(gdb) print variable_name # Вывести значение переменной
(gdb) continue            # Продолжить выполнение до следующей точки
(gdb) bt                  # Backtrace: показать стек вызовов
\end{cppcode}

\begin{summary}
Грамотно настроенное окружение — половина успеха.
\begin{enumerate}
    \item Используйте \textbf{CMake} для управления сборкой, разделяя исходный код и артефакты.
    \item Настройте \textbf{ClangD} и генерацию \texttt{compile\_commands.json} для умного автодополнения.
    \item Всегда собирайте отладочные версии с \textbf{AddressSanitizer} (\texttt{-fsanitize=address}), чтобы ловить ошибки памяти на ранних этапах.
    \item Изучите основы \textbf{GDB} для отладки в сложных окружениях.
\end{enumerate}
\end{summary}
