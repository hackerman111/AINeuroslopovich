 \chapter{Оптимизация строк: SSO и String View}

Строки — один из самых часто используемых типов данных в прикладном программировании. Поэтому эффективность реализации \texttt{std::string} критически важна для общей производительности C++ приложений. В этой главе мы разберем две важнейшие концепции: оптимизацию коротких строк (SSO), которая "прячет" аллокации, и \texttt{std::string\_view} — инструмент для эффективной работы с подстроками без копирования.

\section{Анатомия std::string и SSO}

Наивная реализация строки могла бы выглядеть как простая обертка над динамическим массивом:

\begin{cppcode}
class NaiveString {
    char* data_;
    size_t size_;
    size_t capacity_;
};
\end{cppcode}

На 64-битной архитектуре размер такого объекта составляет $8 + 8 + 8 = 24$ байта. Сама строка хранится в куче (heap). Это означает, что даже для строки "hello" (5 байт) мы вынуждены делать дорогостоящий системный вызов \texttt{malloc/new}, ловить cache miss при обращении к данным и фрагментировать память.

Учитывая, что в реальных программах огромное количество строк очень короткие (имена, ключи в JSON, идентификаторы), разработчики стандартной библиотеки применили оптимизацию \textbf{SSO (Small String Optimization)}.

\subsection{Механика SSO}

Идея SSO заключается в использовании памяти самого объекта (этих 24 байт на стеке) для хранения содержимого строки, если оно туда помещается.

Внутреннее устройство \texttt{std::string} можно представить как объединение (\texttt{union}) двух состояний:
\begin{enumerate}
    \item \textbf{Long String (Куча):} Классическая схема (Pointer, Size, Capacity).
    \item \textbf{Short String (SSO):} Буфер символов прямо внутри структуры + 1 байт для размера.
\end{enumerate}

Псевдокод реализации (упрощенно):

\begin{cppcode}[]
class String {
    static const size_t SSO_CAPACITY = 23; // 24 байта - 1 байт на размер/null

    union {
        // Режим "Длинная строка"
        struct {
            char* ptr;
            size_t size;
            size_t capacity;
        } heap_buf;

        // Режим "Короткая строка"
        struct {
            char buffer[SSO_CAPACITY];
            unsigned char size_byte; // Хранит размер и флаг режима
        } stack_buf;
    };
    
public:
    // ... методы ...
};
\end{cppcode}

\subsection{Как это работает?}
Поскольку объект занимает 24 байта, мы можем хранить строку длиной до 23 символов \textbf{без аллокации памяти}.
\begin{itemize}
    \item \textbf{23 символа:} полезная нагрузка.
    \item \textbf{24-й байт:} используется двояко. В режиме SSO он хранит размер оставшегося места (или длину). В режиме длинной строки это часть поля \texttt{capacity} или специальный флаг.
\end{itemize}

Компиляторы используют битовые хаки. Например, младший бит последнего байта может служить флагом:
\begin{itemize}
    \item $0$: Режим SSO.
    \item $1$: Режим длинной строки (указатель).
\end{itemize}

\begin{note}
Благодаря SSO, создание \texttt{std::string s = "test";} не приводит к обращению к куче. Это делает работу с короткими строками такой же быстрой, как использование автоматических массивов \texttt{char[N]}.
\end{note}

\section{std::string\_view (C++17)}

До C++17 существовала проблема передачи строк в функции.

\begin{itemize}
    \item \textbf{Передача по значению (\texttt{void f(std::string s)}):} Всегда вызывает копирование (глубокую аллокацию), если строка длинная. Дорого.
    \item \textbf{Передача по константной ссылке (\texttt{void f(const std::string\& s)}):} Избавляет от копирования. Но что, если мы хотим передать подстроку?
\end{itemize}

\begin{cppcode}
void process(const std::string& s);

std::string data = "Header: Value";
// Чтобы передать "Value", нужно создать временную строку (аллокация!)
process(data.substr(8)); 
\end{cppcode}

Решением стал \texttt{std::string\_view} — легковесная "вьюшка" (view), которая смотрит на кусок памяти, но не владеет им.

\subsection{Структура и Производительность}

\texttt{std::string\_view} состоит всего из двух полей:
\begin{cppcode}[]
class string_view {
    const char* ptr_; // Указатель на начало
    size_t size_;     // Длина
};
\end{cppcode}

Размер объекта — 16 байт (на 64-bit).

\begin{important}
\textbf{Передача параметров:} \texttt{std::string\_view} принято передавать \textbf{по значению}, а не по ссылке.
\begin{itemize}
    \item \texttt{void f(std::string\_view sv)}
\end{itemize}
Почему? Объект размером 16 байт идеально ложится в два 64-битных регистра процессора (например, RDI и RSI в System V ABI). Передача через регистры быстрее, чем передача ссылки (которая суть указатель), так как избегается лишнее разыменование (double indirection) при доступе к полям \texttt{ptr\_} и \texttt{size\_}.
\end{important}

Операция взятия подстроки (\texttt{substr}) для \texttt{string\_view} имеет сложность $O(1)$ — это просто сдвиг указателя и уменьшение размера. Никакой памяти не выделяется.

\section{Подводные камни (Pitfalls)}

С большой силой приходит большая ответственность. Поскольку \texttt{string\_view} \textbf{не владеет} памятью, программист обязан следить за тем, чтобы исходная строка жила дольше, чем \texttt{string\_view}.

\subsection{Проблема 1: Dangling View (Висячая ссылка)}

Классическая ошибка — создание \texttt{string\_view} от временного объекта.

\begin{cppcode}[label={lst:dangling_sv}]
std::string_view get_greeting() {
    std::string s = "Hello, World!"; // Локальная переменная
    return s; // Неявное преобразование string -> string_view
} // s уничтожается, память освобождается

int main() {
    std::string_view sv = get_greeting();
    std::cout << sv; // UB: чтение освобожденной памяти (Use-after-free)
}
\end{cppcode}

Также опасно комбинировать создание и использование в одной строке, если есть временные объекты:

\begin{cppcode}
std::string_view sv = std::string("Temporary") + " string"; 
// Временная строка умирает в конце выражения. sv смотрит в мусор.
\end{cppcode}

\subsection{Проблема 2: Отсутствие Null-Terminator}

\texttt{std::string} гарантирует, что после данных следует байт \texttt{\textbackslash0}, что позволяет использовать метод \texttt{.c\_str()} для совместимости с C-функциями (\texttt{printf}, \texttt{fopen}).

\texttt{std::string\_view} \textbf{не гарантирует} наличие нуль-терминатора, так как может указывать на середину другой строки.

\begin{cppcode}
std::string s = "Hello World";
std::string_view sv = s.substr(0, 5); // "Hello"

// ОШИБКА:
printf("%s", sv.data()); 
// sv.data() указывает на 'H'. printf будет печатать байты, пока не встретит \0.
// Он напечатает "Hello World" (в лучшем случае) или мусор за пределами s.
\end{cppcode}

Если вам нужно передать \texttt{string\_view} в функцию, ожидающую C-строку, вам придется сначала скопировать его в \texttt{std::string}:
\begin{cppcode}
std::string temp(sv);
legacy_function(temp.c_str());
\end{cppcode}

\begin{summary}
\begin{enumerate}
    \item \textbf{SSO} позволяет хранить короткие строки (обычно до 23 символов) без динамической аллокации. Это делает \texttt{std::string} очень эффективным для мелких данных.
    \item Используйте \texttt{std::string\_view} для передачи строк в функции и парсинга. Это избегает лишних копирований.
    \item Передавайте \texttt{std::string\_view} \textbf{по значению}.
    \item Будьте предельно осторожны с временем жизни. \textbf{Никогда} не сохраняйте \texttt{string\_view} на временные строки.
    \item Помните, что \texttt{string\_view} не является нуль-терминированной строкой.
\end{enumerate}
\end{summary}

\chapter{Кейс-стади: Внутреннее устройство std::deque}

Контейнер \texttt{std::deque} (Double-Ended Queue) — один из самых недооцененных и сложных контейнеров стандартной библиотеки. Часто его воспринимают просто как "вектор, в который можно быстро писать в начало". Однако его внутреннее устройство представляет собой уникальный компромисс между производительностью вектора и стабильностью ссылок связанного списка.

В этой главе мы разберем архитектуру \texttt{deque}, как она реализует "магию" расширения в обе стороны без копирования элементов и почему это важно для системного программирования.

\section{Архитектура: Карта и Чанки}

Наивная реализация двусторонней очереди могла бы быть кольцевым буфером на одном динамическом массиве. Но такая реализация имела бы проблему \texttt{std::vector}: при исчерпании емкости пришлось бы выделять новый огромный массив и переносить туда все элементы.

\texttt{std::deque} решает эту задачу иначе. Это \textbf{фрагментированный} контейнер.

\begin{definition}{Структура Deque}
Логически \texttt{deque} — это бесконечный непрерывный массив.
Физически — это набор фиксированных блоков памяти (\textbf{Chunks} или Buffers), управляемых центральным массивом указателей (\textbf{Map}).
\end{definition}

\subsection{Map (Карта)}
Центральный элемент управления — это динамический массив указателей (\texttt{T** map}).
\begin{itemize}
    \item Каждая ячейка карты указывает на отдельный блок памяти (чанк), хранящий элементы.
    \item Карта работает как кольцевой буфер: у нас есть индексы начала и конца последовательности заполненных блоков внутри карты.
\end{itemize}

\subsection{Chunks (Блоки)}
Сами данные хранятся в блоках фиксированного размера. Размер блока зависит от реализации (GCC, Clang, MSVC), но типичная эвристика — статический буфер размером около 512 байт (или минимум 16 элементов для мелких типов).

\begin{cppcode}[]
template <typename T>
class Deque {
private:
    // Параметры чанка
    static const size_t CHUNK_SIZE = 512 / sizeof(T);
    
    // Центральная "карта" - массив указателей на блоки
    T** map_;            
    size_t map_size_;    // Размер самой карты (емкость указателей)
    
    // Итераторы начала и конца
    // Хранят индекс в карте + индекс внутри конкретного чанка
    iterator start_;
    iterator finish_;
};
\end{cppcode}

\section{Двухуровневая индексация}

Доступ к произвольному элементу по индексу (\texttt{operator[]}) в \texttt{deque} сложнее, чем в векторе. Если в векторе это одна инструкция ассемблера (base + index * scale), то в деке это двухуровневая арифметика.

Чтобы получить элемент \texttt{deque[n]}, нужно:
\begin{enumerate}
    \item Определить, в каком блоке находится элемент.
    \item Определить смещение внутри этого блока.
\end{enumerate}

Формула (упрощенно):
\begin{cppcode}[]
T& operator[](size_t n) {
    // 1. Учитываем смещение начала данных
    size_t pos = start_.cur_index + n;
    
    // 2. Вычисляем индекс блока в карте
    size_t node_index = pos / CHUNK_SIZE;
    
    // 3. Вычисляем смещение внутри блока
    size_t offset = pos % CHUNK_SIZE;
    
    // 4. Двойное разыменование: сначала карту, потом блок
    return map_[node_index][offset];
}
\end{cppcode}

\begin{note}
Именно из-за двойного разыменования (double indirection) \texttt{std::deque} немного медленнее \texttt{std::vector} при последовательном проходе и случайном доступе. Однако он значительно быстрее \texttt{std::list}, так как данные в чанках лежат плотно, что обеспечивает хорошую локальность кэша (Cache Locality).
\end{note}

\section{Главная особенность: Reference Stability}

Киллер-фича \texttt{std::deque}, отличающая его от вектора — \textbf{стабильность ссылок}.

Рассмотрим сценарий:
\begin{cppcode}[]
std::vector<int> v = {1, 2, 3};
int& ref = v[0];
v.push_back(4); // Если capacity превышен, вектор реаллоцируется
// ref теперь указывает в освобожденную память (Dangling Reference)!
\end{cppcode}

У вектора при расширении происходит выделение нового буфера и перемещение всех элементов. Все итераторы и ссылки инвалидируются.

У \texttt{deque} поведение принципиально иное:

\begin{enumerate}
    \item При добавлении элементов (\texttt{push\_back}/\texttt{push\_front}) заполняются существующие чанки.
    \item Если текущий чанк полон, выделяется \textbf{новый чанк} и добавляется в \texttt{map}.
    \item Существующие элементы остаются на своих местах в старых чанках.
\end{enumerate}

\textbf{А что, если переполнилась сама карта (map)?}
В этот момент происходит реаллокация карты:
\begin{enumerate}
    \item Выделяется новый массив указателей (обычно в 2 раза больше).
    \item Указатели из старой карты копируются в центр новой.
    \item Сами чанки данных \textbf{не трогаются}. Они остаются по тем же адресам в куче.
\end{enumerate}

\begin{important}
Вставка в начало или конец \texttt{std::deque} \textbf{инвалидирует итераторы} (так как меняется внутренняя структура карты), но \textbf{НЕ инвалидирует ссылки и указатели} на элементы. Это критически важно, если вы храните указатели на элементы контейнера во внешних структурах.
\end{important}

\section{Сценарии использования}

Когда стоит выбрать \texttt{deque} вместо \texttt{vector}?

\begin{enumerate}
    \item \textbf{Очередь сообщений:} Если вам нужно активно добавлять и удалять элементы с \textit{обоих} концов. Вектор умеет быстро работать только с концом (\texttt{push\_back}). Вставка в начало вектора — $O(N)$.
    \item \textbf{Неинвалидация ссылок:} Если архитектура приложения требует, чтобы указатели на объекты сохранялись при росте контейнера.
    \item \textbf{Фрагментация памяти:} Если вы храните миллионы объектов, вектор потребует найти непрерывный кусок памяти в сотни мегабайт, что может быть невозможно. Дек спокойно "съест" память кусками по 512 байт, разбросанными по всей куче.
\end{enumerate}

\begin{summary}
\begin{itemize}
    \item \texttt{std::deque} — это массив указателей на блоки фиксированного размера.
    \item Обеспечивает $O(1)$ вставку в начало и конец.
    \item Доступ по индексу чуть медленнее вектора (две инструкции чтения памяти).
    \item При реаллокации (расширении) элементы не перемещаются в памяти, ссылки остаются валидными.
\end{itemize}
\end{summary}

