\chapter{Модель памяти и Жизненный цикл объектов}

Понимание работы с памятью — фундаментальный навык разработчика на C++. В отличие от языков с управляемой памятью (Java, Python, Go), где о расположении объектов заботится виртуальная машина и сборщик мусора, C++ предоставляет прямой доступ к управлению ресурсами. Это дает огромную власть, но налагает не меньшую ответственность: по статистике, около 70-80\% всех уязвимостей в безопасности ПО связаны именно с ошибками работы с памятью (memory safety issues).

В этой главе мы рассмотрим, что такое память с точки зрения стандарта C++, что такое "объект" и какие существуют классы хранения данных.

\section{Фундаментальная модель памяти}

\subsection{Миф о "Большом массиве байт"}
Интуитивно память часто представляют как единый, непрерывный массив байт, пронумерованный от 0 до $N$. На физическом уровне (RAM) это отчасти верно, однако программа на C++ работает не с физическими чипами, и даже не напрямую с виртуальной памятью операционной системы. Она работает с \textbf{Абстрактной машиной C++}.

\begin{important}
С точки зрения стандарта C++, память — это не "просто массив", а набор доступных \textbf{объектов}. Доступ к памяти, где не создан объект (или его время жизни истекло), является неопределенным поведением (Undefined Behavior).
\end{important}

Операционная система предоставляет процессу \textit{виртуальное адресное пространство}. Это пространство изолировано: программа не может случайно (или специально) прочитать данные соседнего процесса (например, браузера), просто обратившись по адресу $0x1234$. Адресное пространство процесса фрагментировано: оно состоит из сегментов кода, данных, стека и кучи, между которыми могут находиться огромные "дыры" невыделенной памяти.

\subsection{Байт и слово}
Минимальной адресуемой единицей памяти в C++ является байт.
\begin{itemize}
    \item \texttt{sizeof(char)} всегда равен 1. Это определение единицы измерения в языке.
    \item Количество бит в байте определяется макросом \texttt{CHAR\_BIT} из заголовка \texttt{<climits>}.
\end{itemize}

\begin{note}
Формально стандарт требует, чтобы \texttt{CHAR\_BIT >= 8}. Исторически существовали архитектуры с 9-битными или 16-битными байтами, но в современной индустрии (x86, ARM) байт всегда равен 8 битам (октету). Тем не менее, полагаться на хардкод константы 8 — плохой тон; лучше использовать \texttt{CHAR\_BIT}.
\end{note}

\section{Анатомия Объекта}

В C++ всё есть объект (или ссылка на него). Понимание свойств объекта критично для избежания UB.

\begin{definition}{Объект в C++}
Объект — это область памяти (region of storage), которая имеет:
\begin{itemize}
    \item \textbf{Size (Размер):} определяется \texttt{sizeof(T)}.
    \item \textbf{Alignment (Выравнивание):} требование процессора к адресу начала объекта (например, \texttt{int} часто должен лежать по адресу, кратному 4).
    \item \textbf{Storage Duration (Тип хранения):} где и сколько живет объект.
    \item \textbf{Lifetime (Время жизни):} интервал времени выполнения, когда объект существует.
    \item \textbf{Type (Тип):} интерпретация битов в этой памяти.
    \item \textbf{Value (Значение):} конкретное содержимое.
\end{itemize}
\end{definition}

Ключевой концепт: \textbf{Lifetime}.
\begin{enumerate}
    \item Память выделяется (allocation).
    \item Отрабатывает конструктор — начинается lifetime.
    \item ... Использование объекта ...
    \item Отрабатывает деструктор — заканчивается lifetime.
    \item Память освобождается (deallocation).
\end{enumerate}

Любое использование указателя или ссылки на объект до шага 2 или после шага 4 — это ошибка \textbf{Use-after-free} или использование неинициализированной памяти.

\section{Категории хранения (Storage Durations)}

Стандарт выделяет четыре типа продолжительности хранения. Понимание различий между ними позволяет отвечать на вопрос: "Когда умрет эта переменная?".

\begin{enumerate}
    \item \textbf{Automatic (Автоматическая):} Локальные переменные функций, аргументы. Живут на стеке.
    \item \textbf{Static (Статическая):} Глобальные переменные, \texttt{static} поля классов, \texttt{static} переменные внутри функций. Живут всё время работы программы.
    \item \textbf{Dynamic (Динамическая):} Объекты, созданные через \texttt{new/malloc}. Живут пока их явно не удалят. (Подробнее в следующей главе).
    \item \textbf{Thread-local (Локальная для потока):} Живут пока жив поток, создавший их (спецификатор \texttt{thread\_local}).
\end{enumerate}

\section{Автоматическая память (Stack)}

Самый быстрый и безопасный тип памяти. Обычно называется "стеком", так как реализуется через аппаратный стек процессора (регистры SP/ESP/RSP).

\subsection{Принцип работы}
При входе в функцию (scope) указатель стека сдвигается, выделяя место под все локальные переменные разом. При выходе — сдвигается обратно.
\begin{itemize}
    \item \textbf{Аллокация:} мгновенная (просто сложение регистра с константой).
    \item \textbf{Деаллокация:} автоматическая при выходе из скоупа (закрывающая фигурная скобка \texttt{\}}).
\end{itemize}

\begin{important}
Порядок разрушения объектов на стеке \textbf{строго обратен} порядку их создания. Это принцип LIFO (Last In, First Out).
\end{important}

\begin{cppcode}[]
void logic() {
    std::string a = "First";
    std::vector<int> b = {1, 2};
    // ... работа ...
} // Сначала вызывается ~vector (b), затем ~string (a)
\end{cppcode}

Это свойство является основой идиомы RAII (Resource Acquisition Is Initialization), о которой мы поговорим позже.

\subsection{Проблема Stack Overflow (Задача с семинара)}
Размер стека ограничен. В Linux это обычно 8 MiB, в Windows — 1-2 MiB (настраивается при компиляции). Исчерпание стека приводит к аварийному завершению программы (Segmentation Fault).

Рассмотрим задачу с семинара, демонстрирующую опасность рекурсии:

\begin{cppcode}[label={lst:stackoverflow}]
void recursive_boom(int depth) {
    // Массив выделяется на стеке в КАЖДОМ кадре рекурсии
    char buffer[1024]; 
    
    // Предотвращение оптимизации (чтобы компилятор не выкинул массив)
    buffer[0] = depth % 256; 
    
    if (depth > 0) {
        recursive_boom(depth - 1);
    }
}

int main() {
    recursive_boom(100000); // Глубина 100 тысяч
}
\end{cppcode}

\textbf{Анализ:}
Каждый вызов функции \texttt{recursive\_boom} создает новый стековый кадр (stack frame). В этом кадре хранится:
\begin{enumerate}
    \item Адрес возврата (8 байт на x64).
    \item Аргумент \texttt{depth} (4-8 байт с учетом выравнивания).
    \item Массив \texttt{buffer} (1024 байта).
\end{enumerate}
Итого один вызов занимает чуть больше 1 Кб. При глубине 100 000 рекурсивных вызовов мы пытаемся занять $100\,000 \times 1\,\text{KiB} \approx 100\,\text{MiB}$. Это значительно превышает лимит стека (8 MiB), что гарантированно приводит к краху программы.

\begin{note}
Крупные объекты (массивы на миллион элементов, тяжелые структуры) никогда не должны создаваться на стеке. Используйте \texttt{std::vector} или умные указатели для размещения их данных в куче.
\end{note}

\section{Статическая память (Static)}

Переменные со статической продолжительностью хранения инициализируются один раз (обычно до вызова \texttt{main} или при первом проходе управления) и разрушаются при завершении программы.

Сюда относятся:
\begin{itemize}
    \item Глобальные переменные.
    \item Переменные, объявленные как \texttt{static} внутри функций или классов.
\end{itemize}

\subsection{Static Initialization Order Fiasco}
Самая большая проблема глобальных переменных — неопределенный порядок инициализации между разными единицами трансляции (cpp-файлами).

Представьте два файла:
\begin{cppcode}
// File A.cpp
int x = func(); // func() возвращает 42

// File B.cpp
extern int x;
int y = x + 1;
\end{cppcode}

Стандарт C++ \textbf{не гарантирует}, что \texttt{A.cpp} будет инициализирован раньше \texttt{B.cpp}. Если инициализация \texttt{B} произойдет первой, переменная \texttt{x} будет иметь значение 0 (zero-initialization), и \texttt{y} станет равно 1. Если порядок будет обратным, \texttt{y} станет 43. Это классический "плавающий" баг, зависящий от фазы луны и линковщика.

\subsection{Решение: Meyers Singleton}
Для безопасной работы с глобальными состояниями (если они необходимы) Скотт Мейерс предложил паттерн, использующий \texttt{static} переменную \textit{внутри функции}.

Стандарт C++11 гарантирует, что статические переменные внутри функции инициализируются:
\begin{enumerate}
    \item Ровно один раз.
    \item В момент, когда поток управления \textbf{впервые} проходит через их объявление.
    \item Потокобезопасно (компилятор вставляет неявные блокировки/guard variables).
\end{enumerate}

\begin{cppcode}[]
class Database {
    // ... подключение к БД ...
};

Database& GetDB() {
    // Инициализация произойдет только при первом вызове GetDB()
    static Database db_instance; 
    return db_instance;
}

void ClientCode() {
    // Гарантированно инициализированный объект
    GetDB().query("SELECT * FROM users");
}
\end{cppcode}

Этот подход решает проблему порядка инициализации (ленивая инициализация по требованию) и является стандартным способом реализации синглтонов в современном C++.

\begin{summary}
\begin{itemize}
    \item Память в C++ — это набор объектов с временем жизни, а не просто байты.
    \item \textbf{Стек (Automatic)}: быстро, автоматически чистится, но размер ограничен. LIFO.
    \item \textbf{Глобальные (Static)}: живут вечно, опасны из-за порядка инициализации. Используйте локальные статики (Meyers Singleton).
    \item Избегайте глубокой рекурсии и больших массивов на стеке во избежание \textbf{Stack Overflow}.
\end{itemize}
\end{summary}
